<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>细节之中自有天地，整洁成就卓越代码</title>
      <link href="/blog/989b2900.html"/>
      <url>/blog/989b2900.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/138547/1554043693485-6d3c23e0-0192-4d46-bcde-8c43f247da84.jpeg#align=left&amp;display=inline&amp;height=638&amp;name=joyee-zhou-1449764-unsplash.jpg&amp;originHeight=1095&amp;originWidth=1280&amp;size=206576&amp;status=done&amp;width=746" alt="joyee-zhou-1449764-unsplash.jpg"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>踩着三月的尾巴，拜读完了 Bob 大叔的《代码整洁之道》一书，来分享一下阅读心得。(其实我也不知道看了几遍了)</p><p>《代码整洁之道》的原名是 Clean Code — A Handbook of Agile Software Craftsmanship.</p><p>就像书名一样，本书提出了一个观念：「代码质量与其整洁度成正比」；并且给出了一系列行之有效的代码整洁操作实践。(确实有手册的样子)</p><p>通过学习并遵守这些实践建议就能写出整洁的代码。</p><a id="more"></a><h3 id="简评"><a href="#简评" class="headerlink" title="简评"></a>简评</h3><p>对于内容我给8分，Bob 大叔的实力自不必说，也确确实实给出了非常非常多的实践原则，并且对坏的代码丝毫不留情面，看了后仿佛遭当头棒喝，醍醐灌顶。</p><p>不过该书也有些缺点，比如内容显得有点啰嗦，冗余的内容稍多，并且附录有很多代码，没法看；</p><p>另外翻译差评，没见过这么水的翻译，充斥着类似 油漆工模式 这种<strong>非常不专业的翻译</strong>，多次看的我跳戏，可以说翻译拖了后腿。</p><p>总体上还是值得一看的，用来垫显示器也还不错，偶尔可以拿来翻翻，毕竟它的定位是一本 Handbook。</p><p>谈下一些阅读心得吧（最后有思维导图版本笔记）。</p><h3 id="何为整洁的代码？"><a href="#何为整洁的代码？" class="headerlink" title="何为整洁的代码？"></a>何为整洁的代码？</h3><p>该书的第一章讲了 Bob 大叔以及一票国外大佬对 整洁代码的 定义。</p><p>我最喜欢的对于整洁的代码的描述是：</p><ol><li><strong>整洁的代码总是看起来像是某位特别在意它的人写的；</strong></li><li><strong>可读，像散文一样，令人愉悦</strong>。</li></ol><p>真正用心写代码的人，可以像写散文一样写代码，代码也一定是可阅读的，阅读起来也一定是心情愉悦的，而不是 FxxK。</p><h3 id="如何做到写整洁代码？"><a href="#如何做到写整洁代码？" class="headerlink" title="如何做到写整洁代码？"></a>如何做到写整洁代码？</h3><p>Bob 大叔真的给了很多实践意见，大到系统，小到类、函数。</p><h4 id="关于命名"><a href="#关于命名" class="headerlink" title="关于命名"></a>关于命名</h4><blockquote><p>选个好名字要花时间，但省下来的时间比花掉的多。</p></blockquote><p>以前我觉得取名字很麻烦，还觉得用缩写很酷，会尽量尝试时用缩写，不管是否能缩写，是否语法正确，最后导致的结果是，<strong>没过几天我自己都看不懂这个名字</strong>，后来慢慢地就养成了个习惯：不管名字多长，我也要尽力取号名字，保证名字的表达力。</p><h4 id="关于函数"><a href="#关于函数" class="headerlink" title="关于函数"></a>关于函数</h4><blockquote><p>函数的第一规则是要短小，提二条规则还是更短小。</p></blockquote><p>基本上超过100行的行数就很有可能是不合格的了，Bob 大叔指导我们写出一个整洁的函数。</p><h4 id="关于注释："><a href="#关于注释：" class="headerlink" title="关于注释："></a>关于注释：</h4><blockquote><p>别给糟糕的代码加注释，重新写吧</p></blockquote><p>相信你肯定跟我一样，看到过大片被注释掉的代码，不知所云的注释，跟代码实际逻辑完全向左的注释。</p><p>Bob 大叔就很直接了，直接指出 <strong>注释并不能美化糟糕的代码</strong> 、 <strong>注释总是一种失败</strong> 。</p><h3 id="该书适合我吗？"><a href="#该书适合我吗？" class="headerlink" title="该书适合我吗？"></a>该书适合我吗？</h3><p>如果你不止一次的遇到如下的情况：</p><ol><li>本来只需要几个小时就能做完的需求却花费了数个星期；</li><li>本来只需要改一行代码， 却牵扯到 N 多个模块。</li></ol><p>说明你的代码不 Clean ，那么我建议你阅读一下本书，并且再配一本设计模式的书，如《深入浅出设计模式》，<strong>绝对能够让你写代码的实力提升一个档次</strong>；当然想提升一下自己的代码质量，那这本书也是不容错过的哟。</p><p>个人建议重点阅读第 1、2、3、4、5、10、17这些章节，其他的看兴趣阅读。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当阅读这本书后，我写代码的时候都仿佛感觉 Bob 大叔就站在我背后，紧盯着我的屏幕，时刻准备挑我代码中的毛病。</p><p>关注公众号，后台回复：代码整洁之道，获取思维导图版本笔记。</p>]]></content>
      
      
      <categories>
          
          <category> 万般皆下品惟有读书高 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码整洁之道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandora 的魔盒里装了什么？</title>
      <link href="/blog/ac0ded91.html"/>
      <url>/blog/ac0ded91.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/138547/1552395257989-c45f8979-92f7-4c8e-8fb7-d38e280b45df.jpeg#align=left&amp;display=inline&amp;height=497&amp;name=preston-goff-686707-unsplash.jpg&amp;originHeight=853&amp;originWidth=1280&amp;size=211622&amp;status=done&amp;width=746" alt="preston-goff-686707-unsplash.jpg"></p><blockquote><p>文章可能会过时，最新信息请查阅 Github<br>Github 地址 ： <a href="https://github.com/AlanCheen/Pandora" target="_blank" rel="noopener">https://github.com/AlanCheen/Pandora</a></p></blockquote><p>在古希腊的神话中 Pandora 是世界上第一个女人，一个 all-gifted 的女人（具有一切天赋的女人），而潘多拉的魔盒里装着希望。</p><p>借着 all-gifted 的寓意，我创建了一个开源库 Pandora，一个非常常用的工具类的集合。</p><p>虽然算是 Utils 的集合，但是跟其他的库并不同，这里的类&amp;方法的数量非常少，我只选了极少数我觉得真的非常有用且有大概率复用的类，在保证避免编写大量样板代码的基础之上，减少引入不必要类的可能，防止包体积增大。。</p><p>所以也可以算是一个『Utils 心选』。</p><p>那么就介绍一下 Pandora 的能力啦。</p><a id="more"></a><h4 id="ApplicationUtils"><a href="#ApplicationUtils" class="headerlink" title="ApplicationUtils"></a>ApplicationUtils</h4><p>一个可以设置、获取全局 Application 的工具类，Context 在 Android 中非常常用，但是其实很多时候我们不需要传递 Activity 类型的 Context ， <strong>使用 <code>ApplicationUtils</code> 可以缓解我们到处传递 Context 的困境</strong>。（默认会从 ActivityThread 获取 Application）</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/138547/1552393743899-e8fbd18b-6e4b-46eb-b06a-d72f226a96b9.png#align=left&amp;display=inline&amp;height=665&amp;name=applicationutils.png&amp;originHeight=1814&amp;originWidth=2036&amp;size=416310&amp;status=done&amp;width=746" alt="applicationutils.png"><br></p><h4 id="MainThread"><a href="#MainThread" class="headerlink" title="MainThread"></a>MainThread</h4><p>一个关于主线程的工具类，<strong>可以方便地将 Runnable post 到主线程执行</strong>。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/138547/1552393753662-56c4eedc-1262-4d42-8c17-efb61f485578.png#align=left&amp;display=inline&amp;height=565&amp;name=mainthread.png&amp;originHeight=1274&amp;originWidth=1682&amp;size=249004&amp;status=done&amp;width=746" alt="mainthread.png"><br></p><h4 id="ToastUtils"><a href="#ToastUtils" class="headerlink" title="ToastUtils"></a>ToastUtils</h4><p>一个全局单例 Toast ，<strong>解决多次实例化 Toast 导致不停弹 Toast 的问题</strong>。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/138547/1552393761623-08d6fa55-f082-4192-ae6b-4770e51a2c69.png#align=left&amp;display=inline&amp;height=759&amp;name=toastutils.png&amp;originHeight=1850&amp;originWidth=1818&amp;size=339540&amp;status=done&amp;width=746" alt="toastutils.png"><br></p><h4 id="LifecycleHandler"><a href="#LifecycleHandler" class="headerlink" title="LifecycleHandler"></a>LifecycleHandler</h4><p>在使用 Handler 的时候我们总是担心 Handler 会导致内存泄露，于是我们每次都会在 onDestroy 方法里移除 Handler 的消息，编写样板代码，LifecycleHandler 的出现就是为了解决这个困境，<strong>使用它，你不再需要关注 onDestroy 啦！</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/138547/1552393772690-41dd5d27-7f6c-42ef-bdb8-6503f1cd1143.png#align=left&amp;display=inline&amp;height=648&amp;name=lifecyclehandler.png&amp;originHeight=1778&amp;originWidth=2048&amp;size=433814&amp;status=done&amp;width=746" alt="lifecyclehandler.png"></p><h4 id="UiUtils"><a href="#UiUtils" class="headerlink" title="UiUtils"></a>UiUtils</h4><p>Android 开发不可避免的要跟像素 dp 等打交道，UiUtils 包含一些数据单位转换的操作。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/138547/1552393779118-570b8456-a809-49e3-9c6c-b0ba13da7c0a.png#align=left&amp;display=inline&amp;height=503&amp;name=uiutils.png&amp;originHeight=1382&amp;originWidth=2048&amp;size=345732&amp;status=done&amp;width=746" alt="uiutils.png"></p><h4 id="Predictions"><a href="#Predictions" class="headerlink" title="Predictions"></a>Predictions</h4><p>一个用来做”断言”的功能的工具类，用来验证判断参数是否合法。<br>虽然我们有 NonNull 等注解 ，但是依然避免不了外部传递非法参数，这个时候我们避免不了写样板代码，检测参数是否非法，如果是则抛出异常，<strong>Predictions 可以让你少写一些检查抛、异常的样板代码</strong>。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/138547/1552393788306-83ae27da-1e1e-4a1c-9b8a-bc544cb0c726.png#align=left&amp;display=inline&amp;height=741&amp;name=predictions.png&amp;originHeight=1958&amp;originWidth=1970&amp;size=440124&amp;status=done&amp;width=746" alt="predictions.png"><br></p><p>一句依赖即可拥有以上所有能力哟：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'me.yifeiyuan.pandora:pandora-basic:1.0.3'</span></span><br></pre></td></tr></table></figure><p>github 地址：<a href="https://github.com/AlanCheen/Pandora" target="_blank" rel="noopener">https://github.com/AlanCheen/Pandora</a></p><p>欢迎 star !~</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一文看穿 Handler</title>
      <link href="/blog/f77487d3.html"/>
      <url>/blog/f77487d3.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/98900c07ly1g0ayzd2nzsj20zk0mjjxc.jpg" alt=""></p><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>做 Android 开发肯定离不开跟 Handler 打交道，它通常被我们用来做主线程与子线程之间的通信工具，而 Handler 作为 Android 中消息机制的重要一员也确实给我们的开发带来了极大的便利。</p><p>可以说<strong>只要有异步线程与主线程通信的地方就一定会有 Handler</strong>。</p><p>那么，Handler 的通信机制的背后的原理是什么？</p><p>本文带你揭晓。</p><a id="more"></a><p><strong>注意：本文所展示的系统源码基于 Android-27 ，并有所删减。</strong></p><h2 id="1-重识-Handler"><a href="#1-重识-Handler" class="headerlink" title="1. 重识 Handler"></a>1. 重识 Handler</h2><p>我们可以使用 Handler <strong>发送并处理</strong>与一个线程关联的 Message 和 Runnable 。（注意：<strong>Runnable 会被封装进一个 Message，所以它本质上还是一个 Message</strong> ）</p><p>每个 Handler 都会跟一个线程绑定，并与该线程的 MessageQueue 关联在一起，从而实现消息的管理以及线程间通信。</p><h3 id="1-1-Handler-的基本用法"><a href="#1-1-Handler-的基本用法" class="headerlink" title="1.1 Handler 的基本用法"></a>1.1 Handler 的基本用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android.os.Handler handler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里接受并处理消息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//发送消息</span></span><br><span class="line">handler.sendMessage(message);</span><br><span class="line">handler.post(runnable);</span><br></pre></td></tr></table></figure><p>实例化一个 Handler 重写 <code>handleMessage</code> 方法 ，然后在需要的时候调用它的 <code>send</code> 以及 <code>post</code> <strong>系列方法</strong>就可以了，非常简单易用，并且支持延时消息。（更多方法可查询 API 文档）</p><p>但是奇怪，<strong>我们并没有看到任何 MessageQueue 的身影，也没看到它与线程绑定的逻辑，这是怎么回事</strong>？</p><h2 id="2-Handler-原理解析"><a href="#2-Handler-原理解析" class="headerlink" title="2. Handler 原理解析"></a>2. Handler 原理解析</h2><p>相信大家早就听说过了 Looper 以及 MessageQueue 了，我就不多绕弯子了。</p><p>不过在开始分析原理之前，先<strong>明确我们的问题</strong>：</p><ol><li><strong>Handler 是如何与线程关联的？</strong></li><li><strong>Handler 发出去的消息是谁管理的？</strong></li><li><strong>消息又是怎么回到 handleMessage() 方法的？</strong></li><li><strong>线程的切换是怎么回事？</strong></li></ol><h3 id="2-1-Handler-与-Looper-的关联"><a href="#2-1-Handler-与-Looper-的关联" class="headerlink" title="2.1 Handler 与 Looper 的关联"></a>2.1 Handler 与 Looper 的关联</h3><p>实际上我们在实例化 Handler 的时候 Handler 会去检查当前线程的 Looper 是否存在，如果不存在则会报异常，也就是说<strong>在创建 Handler 之前一定需要先创建 Looper</strong> 。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查当前的线程是否有 Looper</span></span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Looper 持有一个 MessageQueue</span></span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个异常相信很多同学遇到过，而我们平时直接使用感受不到这个异常是因为主线程已经为我们创建好了 Looper，先记住，后面会讲。（见【3.2】）</p><p>一个完整的 Handler 使用例子其实是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// process incoming messages here</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Looper.prepare() :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Looper</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Looper 提供了 <code>Looper.prepare()</code>  方法来创建 Looper ，并且会<strong>借助 ThreadLocal 来实现与当前线程的绑定</strong>功能。<strong>Looper.loop() 则会开始不断尝试从 MessageQueue 中获取 Message , 并分发给对应的 Handler（见【2.3】）</strong>。</p><p><strong>也就是说 Handler 跟线程的关联是靠 Looper 来实现的。</strong></p><h3 id="2-2-Message-的存储与管理"><a href="#2-2-Message-的存储与管理" class="headerlink" title="2.2 Message 的存储与管理"></a>2.2 Message 的存储与管理</h3><p>Handler 提供了一些列的方法让我们来发送消息，如 send()系列 post()系列 。</p><p>不过不管我们调用什么方法，最终都会走到 <code>MessageQueue.enqueueMessage(Message,long)</code> 方法。</p><p>以 <code>sendEmptyMessage(int)</code>  方法为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Handler</span></span><br><span class="line">sendEmptyMessage(<span class="keyword">int</span>)</span><br><span class="line">  -&gt; sendEmptyMessageDelayed(<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br><span class="line">    -&gt; sendMessageAtTime(Message,<span class="keyword">long</span>)</span><br><span class="line">      -&gt; enqueueMessage(MessageQueue,Message,<span class="keyword">long</span>)</span><br><span class="line">  -&gt; queue.enqueueMessage(Message, <span class="keyword">long</span>);</span><br></pre></td></tr></table></figure><p><strong>到了这里，消息的管理者 MessageQueue 也就露出了水面</strong>。<br>MessageQueue 顾明思议，就是个队列，负责消息的入队出队。</p><h3 id="2-3-Message-的分发与处理"><a href="#2-3-Message-的分发与处理" class="headerlink" title="2.3 Message 的分发与处理"></a>2.3 Message 的分发与处理</h3><p>了解清楚 Message 的发送与存储管理后，就该揭开分发与处理的面纱了。</p><p>前面说到了 <code>Looper.loop()</code>  负责对消息的分发，本章节进行分析。</p><p>先来看看所涉及到的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Looper</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">       <span class="comment">// 不断从 MessageQueue 获取 消息</span></span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="comment">//退出 Looper </span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            end = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"><span class="comment">//回收 message, 见【3.5】</span></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>loop()</code> 里调用了 <code>MessageQueue.next()</code> :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MessageQueue</span></span><br><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers. 关于 IdleHandler 自行了解</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还调用了 <code>msg.target.dispatchMessage(msg)</code> ，msg.target 就是发送该消息的 Handler，这样就回调到了 Handler 那边去了:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Handler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//msg.callback 是 Runnable ，如果是 post方法则会走这个 if</span></span><br><span class="line">  <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">    handleCallback(msg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//callback 见【3.4】</span></span><br><span class="line">    <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回调到 Handler 的 handleMessage 方法</span></span><br><span class="line">    handleMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：dispatchMessage() 方法针对 Runnable 的方法做了特殊处理，如果是 ，则会直接执行 <code>Runnable.run()</code> 。</strong></p><p><strong>分析：</strong>Looper.loop() 是个死循环，会<strong>不断调用 MessageQueue.next() 获取 Message ，并调用 <code>msg.target.dispatchMessage(msg)</code> 回到了 Handler 来分发消息，以此来完成消息的回调</strong>。</p><p><strong>注意：loop()方法并不会卡死主线程，见【6】。</strong></p><p>那么<strong>线程的切换又是怎么回事</strong>呢？<br>很多人搞不懂这个原理，但是其实非常简单，我们将所涉及的方法调用栈画出来，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread.foo()&#123;</span><br><span class="line">Looper.loop()</span><br><span class="line"> -&gt; MessageQueue.next()</span><br><span class="line">   -&gt; Message.target.dispatchMessage()</span><br><span class="line">    -&gt; Handler.handleMessage()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>显而易见，Handler.handleMessage() 所在的线程最终由调用 Looper.loop() 的线程所决定。</strong></p><p>平时我们用的时候从异步线程发送消息到 Handler，这个 Handler 的 <code>handleMessage()</code> 方法是在主线程调用的，所以消息就从异步线程切换到了主线程。</p><h3 id="2-3-图解原理"><a href="#2-3-图解原理" class="headerlink" title="2.3 图解原理"></a>2.3 图解原理</h3><p>文字版的原理解析到这里就结束了，如果你看到这里还是没有懂，没关系，我特意给你们准备了些图，配合着前面几个章节，再多看几遍，一定可以吃透。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/138547/1550387635477-6e23e33e-e74d-48f0-82b0-61eb6b40cb61.jpeg#align=left&amp;display=inline&amp;height=484&amp;linkTarget=_blank&amp;name=handler-looper-mq.jpg&amp;originHeight=484&amp;originWidth=500&amp;size=53021&amp;width=500" alt="handler-looper-mq.jpg"></p><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/138547/1550410927812-f71e9b16-9d2f-45e0-bfc2-2665ae5e2b44.jpeg#align=left&amp;display=inline&amp;height=275&amp;linkTarget=_blank&amp;name=handler_java.jpg&amp;originHeight=550&amp;originWidth=902&amp;size=75596&amp;width=451" alt="handler_java.jpg"><br>图片来源见【6】</p><h3 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h3><p>Handler 的背后有着 Looper 以及 MessageQueue 的协助，三者通力合作，分工明确。</p><p>尝试小结一下它们的职责，如下：</p><ul><li>Looper ：<strong>负责关联线程以及消息的分发</strong>，会与创建它的线程绑定，并负责<strong>在该线程下</strong>从 MessageQueue 获取 Message，分发给 Handler ；</li><li>MessageQueue ：<strong>是个队列，负责消息的存储与管理</strong>，负责管理由 Handler 发送过来的 Message ；</li><li>Handler : <strong>负责发送并处理消息</strong>，面向开发者，提供 API，并隐藏背后实现的细节。</li></ul><p>对【2】章节提出的问题用一句话总结：</p><p><strong>Handler 发送的消息由 MessageQueue 存储管理，并由 Loopler 负责回调消息到 handleMessage()。</strong></p><p><strong>线程的转换由 Looper 完成，handleMessage() 所在线程由 Looper.loop() 调用者所在线程决定。</strong></p><h2 id="3-Handler-的延伸"><a href="#3-Handler-的延伸" class="headerlink" title="3. Handler 的延伸"></a>3. Handler 的延伸</h2><p>Handler 虽然简单易用，但是要用好它还是需要注意一点，另外 Handler相关 还有些鲜为人知的知识技巧，比如 IdleHandler。</p><p>由于 Handler 的特性，它在 Android 里的应用非常广泛，比如： AsyncTask、HandlerThread、Messenger、IdleHandler 和 IntentService 等等。</p><p>这些我会讲解一些，我没讲到的可以自行搜索相关内容进行了解。</p><h3 id="3-1-Handler-引起的内存泄露原因以及最佳解决方案"><a href="#3-1-Handler-引起的内存泄露原因以及最佳解决方案" class="headerlink" title="3.1 Handler 引起的内存泄露原因以及最佳解决方案"></a>3.1 Handler 引起的内存泄露原因以及最佳解决方案</h3><p>Handler 允许我们发送<strong>延时消息</strong>，如果在延时期间用户关闭了 Activity，那么该 Activity 会泄露。</p><p>这个泄露是因为 Message 会持有 Handler，而又因为 <strong>Java 的特性，内部类会持有外部类</strong>，使得 Activity 会被 Handler 持有，这样最终就导致 Activity 泄露。</p><p>解决该问题的最有效的方法是：<strong>将 Handler 定义成静态的内部类，在内部持有 Activity 的弱引用，并及时移除所有消息</strong>。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;HandlerActivity&gt; ref;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafeHandler</span><span class="params">(HandlerActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ref = <span class="keyword">new</span> WeakReference(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</span><br><span class="line">        HandlerActivity activity = ref.get();</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            activity.handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且再在 <code>Activity.onDestroy()</code> 前移除消息，加一层保障：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  safeHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">super</span>.onDestroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样双重保障，就能完全避免内存泄露了。</p><p><strong>注意：单纯的在 <code>onDestroy</code> 移除消息并不保险，因为 <code>onDestroy</code> 并不一定执行。</strong></p><h3 id="3-2-为什么我们能在主线程直接使用-Handler，而不需要创建-Looper-？"><a href="#3-2-为什么我们能在主线程直接使用-Handler，而不需要创建-Looper-？" class="headerlink" title="3.2 为什么我们能在主线程直接使用 Handler，而不需要创建 Looper ？"></a>3.2 为什么我们能在主线程直接使用 Handler，而不需要创建 Looper ？</h3><p>前面我们提到了每个Handler 的线程都有一个 Looper ，主线程当然也不例外，但是我们不曾准备过主线程的 Looper 而可以直接使用，这是为何？</p><p><strong>注意：通常我们认为 ActivityThread 就是主线程。事实上它并不是一个线程，而是主线程操作的管理者，所以吧，我觉得把 ActivityThread 认为就是主线程无可厚非，另外主线程也可以说成 UI 线程。</strong></p><p>在 ActivityThread.main() 方法中有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//android.app.ActivityThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">  ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">  thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    sMainThreadHandler = thread.getHandler();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  Looper.loop();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Looper.prepareMainLooper(); 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the current thread as a looper, marking it as an</span></span><br><span class="line"><span class="comment"> * application's main looper. The main looper for your application</span></span><br><span class="line"><span class="comment"> * is created by the Android environment, so you should never need</span></span><br><span class="line"><span class="comment"> * to call this function yourself.  See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<strong>在 ActivityThread 里 调用了 Looper.prepareMainLooper() 方法创建了 主线程的 Looper ,并且调用了 loop() 方法</strong>，所以我们就可以直接使用 Handler 了。</p><p><strong>注意：<code>Looper.loop()</code> 是个死循环，后面的代码正常情况不会执行。</strong></p><h3 id="3-3-主线程的-Looper-不允许退出"><a href="#3-3-主线程的-Looper-不允许退出" class="headerlink" title="3.3 主线程的 Looper 不允许退出"></a>3.3 主线程的 Looper 不允许退出</h3><p>如果你尝试退出 Looper ，你会得到以下错误信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: Main thread not allowed to quit.</span><br><span class="line">  at android.os.MessageQueue.quit(MessageQueue.java:<span class="number">415</span>)</span><br><span class="line">  at android.os.Looper.quit(Looper.java:<span class="number">240</span>)</span><br></pre></td></tr></table></figure><p>why? 其实原因很简单，<strong>主线程不允许退出</strong>，退出就意味 APP 要挂。</p><h3 id="3-4-Handler-里藏着的-Callback-能干什么？"><a href="#3-4-Handler-里藏着的-Callback-能干什么？" class="headerlink" title="3.4 Handler 里藏着的 Callback 能干什么？"></a>3.4 Handler 里藏着的 Callback 能干什么？</h3><p>在 Handler 的构造方法中有几个 要求传入 Callback ，那它是什么，又能做什么呢？</p><p>来看看 <code>Handler.dispatchMessage(msg)</code>  方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这里的 callback 是 Runnable</span></span><br><span class="line">  <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">    handleCallback(msg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果 callback 处理了该 msg 并且返回 true， 就不会再回调 handleMessage</span></span><br><span class="line">    <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到 Handler.Callback 有<strong>优先处理消息的权利</strong> ，当一条消息被 Callback 处理<strong>并拦截（返回 true）</strong>，那么 Handler 的 <code>handleMessage(msg)</code> 方法就不会被调用了；如果 Callback 处理了消息，但是并没有拦截，那么就意味着<strong>一个消息可以同时被 Callback 以及 Handler 处理</strong>。</p><p>这个就很有意思了，这有什么作用呢？</p><p><strong>我们可以利用 Callback 这个拦截机制来拦截 Handler 的消息！</strong></p><p>场景：Hook ActivityThread.mH ， 在 ActivityThread 中有个成员变量 <code>mH</code> ，它是个 Handler，又是个极其重要的类，几乎所有的插件化框架都使用了这个方法。</p><h3 id="3-5-创建-Message-实例的最佳方式"><a href="#3-5-创建-Message-实例的最佳方式" class="headerlink" title="3.5 创建 Message 实例的最佳方式"></a>3.5 创建 Message 实例的最佳方式</h3><p>由于 Handler 极为常用，所以为了节省开销，Android 给 Message 设计了回收机制，所以我们在使用的时候尽量复用 Message ，减少内存消耗。</p><p>方法有二：</p><ol><li>通过 Message 的静态方法 <code>Message.obtain();</code>   获取；</li><li>通过 Handler 的公有方法 <code>handler.obtainMessage();</code> 。 </li></ol><h3 id="3-6-子线程里弹-Toast-的正确姿势"><a href="#3-6-子线程里弹-Toast-的正确姿势" class="headerlink" title="3.6 子线程里弹 Toast 的正确姿势"></a>3.6 子线程里弹 Toast 的正确姿势</h3><p>当我们尝试在子线程里直接去弹 Toast 的时候，会 crash ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: Can<span class="string">'t create handler inside thread that has not called Looper.prepare()</span></span><br></pre></td></tr></table></figure><p><strong>本质上是因为 Toast 的实现依赖于 Handler</strong>，按子线程使用 Handler 的要求修改即可（见【2.1】），同理的还有 Dialog。</p><p>正确示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Looper.prepare();</span><br><span class="line">    Toast.makeText(HandlerActivity.<span class="keyword">this</span>, <span class="string">"不会崩溃啦！"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    Looper.loop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h3 id="3-7-妙用-Looper-机制"><a href="#3-7-妙用-Looper-机制" class="headerlink" title="3.7 妙用 Looper 机制"></a>3.7 妙用 Looper 机制</h3><p>我们可以利用 Looper 的机制来帮助我们做一些事情：</p><ol><li>将 Runnable post 到主线程执行；</li><li>利用 Looper 判断当前线程是否是主线程。</li></ol><p>完整示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Handler HANDLER = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(@NonNull Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMainThread()) &#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            HANDLER.post(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Looper.myLooper() == Looper.getMainLooper();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>能够省去不少样板代码。</p><h2 id="4-知识点汇总"><a href="#4-知识点汇总" class="headerlink" title="4. 知识点汇总"></a>4. 知识点汇总</h2><p>由前文可得出一些知识点，汇总一下，方便记忆。</p><ol><li>Handler 的背后有 Looper、MessageQueue 支撑，Looper 负责消息分发，MessageQueue 负责消息管理；</li><li>在创建 Handler 之前一定需要先创建 Looper；</li><li>Looper 有退出的功能，但是主线程的 Looper 不允许退出；</li><li>异步线程的 Looper 需要自己调用 <code>Looper.myLooper().quit();</code>  退出；</li><li>Runnable 被封装进了 Message，可以说是一个特殊的 Message；</li><li><code>Handler.handleMessage()</code> 所在的线程是 Looper.loop() 方法被调用的线程，也可以说成 Looper 所在的线程，并不是创建 Handler 的线程；</li><li>使用内部类的方式使用 Handler 可能会导致内存泄露，即便在 Activity.onDestroy 里移除延时消息，必须要写成静态内部类；</li></ol><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>Handler 简单易用的背后藏着工程师大量的智慧，要努力向他们学习。</p><p>看完并理解本文可以说你对 Handler 有了一个非常深入且全面的了解，应对面试肯定是绰绰有余了。</p><h2 id="6-参考和推荐"><a href="#6-参考和推荐" class="headerlink" title="6. 参考和推荐"></a>6. 参考和推荐</h2><p><a href="https://developer.android.com/reference/android/os/Handler" target="_blank" rel="noopener">Handler</a><br><a href="https://stackoverflow.com/questions/12877944/what-is-the-relationship-between-looper-handler-and-messagequeue-in-android" target="_blank" rel="noopener">what-is-the-relationship-between-looper-handler-and-messagequeue-in-android</a><br><a href="http://gityuan.com/2015/12/26/handler-message-framework/" target="_blank" rel="noopener">Android消息机制1-Handler（Java 层）</a><br><a href="https://www.zhihu.com/question/34652589/answer/90344494" target="_blank" rel="noopener">Android中为什么主线程不会卡死</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTFSC </tag>
            
            <tag> Handler </tag>
            
            <tag> ActivityThread </tag>
            
            <tag> Looper </tag>
            
            <tag> MessageQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么我们能在主线程直接使用 Handler，而不需要创建 Looper ？</title>
      <link href="/blog/58a7bfe2.html"/>
      <url>/blog/58a7bfe2.html</url>
      
        <content type="html"><![CDATA[<p>每个Handler 的线程都有一个 Looper ，主线程当然也不例外，但是我们不曾准备过主线程的 Looper 而可以直接使用，这是为何？</p><p><strong>注意：通常我们认为 ActivityThread 就是主线程。事实上它并不是一个线程，而是主线程操作的管理者，所以吧，我觉得把 </strong>ActivityThread <strong>认为就是主线程无可厚非，另外主线程也可以说成 UI 线程。</strong></p><p>在 ActivityThread.main() 方法中有如下代码：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//android.app.ActivityThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">  ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">  thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    sMainThreadHandler = thread.getHandler();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  Looper.loop();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Looper.prepareMainLooper(); 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the current thread as a looper, marking it as an</span></span><br><span class="line"><span class="comment"> * application's main looper. The main looper for your application</span></span><br><span class="line"><span class="comment"> * is created by the Android environment, so you should never need</span></span><br><span class="line"><span class="comment"> * to call this function yourself.  See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<strong>在 ActivityThread 里 调用了 Looper.prepareMainLooper() 方法创建了 主线程的 Looper ,并且调用了 loop() 方法</strong>，所以我们就可以直接使用 Handler 了。</p><p><strong>注意：<code>Looper.loop()</code> 是个死循环，后面的代码正常情况不会执行。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Handler </tag>
            
            <tag> ActivityThread </tag>
            
            <tag> Looper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不要让你的学历拦住你前进的脚步</title>
      <link href="/blog/c2a1f504.html"/>
      <url>/blog/c2a1f504.html</url>
      
        <content type="html"><![CDATA[<p>上次我发布<a href="http://mp.weixin.qq.com/s?__biz=MzIxNDE1NjQ2Mw==&amp;mid=2649872335&amp;idx=1&amp;sn=d03ff6e6aee026f1065ce6a41fd2ba2a&amp;chksm=8faea20fb8d92b1964e0080e15955c375d5fd1719f2673e8860228e823b06620b5adec6d5310&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">毕业三年内要怎么样加入阿里？</a>之后，受到了一些关注，也收到了一些留言，对于如何进阿里还有些疑问。</p><p>有人就问道：进阿里需要什么学历？楼主什么学历？阿里看学历吗？</p><p>可能大部分人也会有同样的疑问，<strong>阿里到底看不看学历</strong>？</p><p>今天就来讲讲<strong>学历</strong>。</p><a id="more"></a><h2 id="那么，进阿里到底看不看学历呢？"><a href="#那么，进阿里到底看不看学历呢？" class="headerlink" title="那么，进阿里到底看不看学历呢？"></a>那么，进阿里到底看不看学历呢？</h2><p><strong>先说结论：看！但是学历只是众多招聘筛选条件中的一个，并且随着工作年限的增长，权重逐渐减低的一个</strong>。</p><p>什么意思呢？</p><p>首先，招聘是一个筛选的过程，对候选人们的各项条件对比进行筛选，比如学历，工作经验，是否有大厂经验，英语能力怎么样，期望薪资多少等等等等，这些条件也都有权重，结果几番筛选，最终选出和岗位相对更合适人，学历是其中一种。</p><p>之前我提到过，阿里招聘分<strong>校招</strong>和<strong>社招</strong>，其他很多大厂也一样，这两种招聘学历占的权重是有很大差别的。</p><h3 id="校招"><a href="#校招" class="headerlink" title="校招"></a>校招</h3><p>校招是 校园招聘 的意思，是从学生里招聘，往往会挑选学习能力更强的人，毕竟学生嘛，<strong>基本都没什么工作经验</strong>。</p><p>全国乃至全世界，这么多大学，这么多学生，你怎么高效地去筛选呢？</p><p>这时候学历就是个很好的条件了，比如加上学历要求：只招博士，这样就能筛选掉一大部分人，再从里面筛选就简单多了。</p><p>当然肯定有人不服，tm 博士就一定比我牛逼吗？ <strong>说句不客气的，大概率是的，至少学生时代是的。</strong></p><p>要知道，不可能每个人都叫来面试，招人也是有成本的！</p><h3 id="社招"><a href="#社招" class="headerlink" title="社招"></a>社招</h3><p>社招是 社会招聘 的意思，是从社会上招聘，往往会挑选专业能力更强，工作经验更丰富的人。</p><p>这个时候的招聘面向的范围更广了，不止当界的应届生，还有已经参加工作的人了。</p><p>社招往往更看重专业能力以及工作经验，学历在这时候的价值体现相对没有校招那么多了。</p><p><strong>简单说，只要你足够牛逼，学历不是问题。</strong><br><strong><br></strong>但是学历相对低的人要表现出『我很牛逼』，必然要在其他条件表现得更加突出，学生时代的欠下的，到了社会，依然是要还的。<strong><br></strong><br>所以，学历相对低的同学不要再纠结自己的学历了，好好加强一下专业能力，进大厂，还是有机会的。</p><p>还在上学的学生，要继续努力，好好学习，学历依然是一个好用的招牌，建议争取读个本科吧，毕竟国家在发展，能够读上大学的人越来越多，自然学历的要求会越来越高，更何况高的学历的好处也不止在找更好的工作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就说到这里吧，总结一下吧，<strong>学历它并不是一个能决定一个人能否进阿里的充分必要条件</strong>。</p><p>以后就不要再问我看不看学历了， 再问自杀。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>毕业三年内要怎么样加入阿里？</title>
      <link href="/blog/97266db6.html"/>
      <url>/blog/97266db6.html</url>
      
        <content type="html"><![CDATA[<p>在<a href="http://mp.weixin.qq.com/s?__biz=MzIxNDE1NjQ2Mw==&amp;mid=2649872304&amp;idx=1&amp;sn=43ca3ae85f1d0a9030a1b4d7791232b4&amp;chksm=8faea270b8d92b66d0f21e1568fd876af9d97f6f0f0eba42ac6d9b4aa16840c50dacb1cd153a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">之前的文章</a>里我提到过，2017年我实现了一个小目标，<strong>毕业三年加入阿里</strong>。</p><p>听上去好像挺厉害，挺光鲜，但是实际上并不那么容易，在这背后有很多我自己摸索和努力的故事。</p><p>在这里我想分享一些我的经验，<strong>送给那些跟我一样，没名校背景没大厂背景，但是想进阿里（或其他大厂），又有点迷茫不知该如何前进的人</strong>。</p><hr><a id="more"></a><p>其实在进阿里之前，我也挺迷茫，内心有一些谜团一直困扰着我，比如<strong>阿里招人标准是什么？</strong>，自己距离这个标准有多少差距？那时候一直不知道，就好像<strong>置身于沙漠之中，却不知道往哪里走</strong>。这时候，找到方向最为关键。（很多人跟我那时候一样迷茫，因为不少人问过我，到底怎么样才能加入阿里。）</p><p>当时我问了几个在阿里的朋友：</p><p>我问：要进阿里是什么标准啊？</p><p>朋友答：社招的话一般P6起招，三年工作经验。</p><p>我又会问：<strong>P6是什么</strong>？</p><p>这时候往往得到的回答就不一样了。</p><blockquote><p>这里普及一下，每个公司都有职别定级系统，阿里也是，技术岗以 P 定级，一般校招 P5,社招 P6起。<br><br>以前我入职淘宝的title是『资深无线开发工程师』是 P6级别， 那时候 P6还分 高级 与 资深，现在都统一成高级了。</p></blockquote><p>那 P6 的标准到底是什么呢？</p><p>其实还挺难说清，这个不像是考试的分数定级那样清晰，到了60分就是及格。</p><p>在我的理解里，一句话概括就是：<strong>拥有独立负责某个或多个模块的开发工作的能力</strong>。（说得再白话一点，就是老板放心你一个人负责某个或多个模块的开发工作）</p><p>听着好像还是很抽象，别急，我尝试着把这个能力拆分了一下，包括但不限于：</p><ol><li><strong>专业能力</strong></li><li><strong>解决问题的能力</strong></li><li><strong>学习能力</strong></li></ol><p>如果这几项能力达标或突出，我觉得就可以负责多个模块的开发工作了，也意味着进阿里，技术问题不大。</p><p>那么我们能怎么去提升自己达到目标呢？限于篇幅，我着重讲怎么提升专业能力。</p><h2 id="专业能力的提升"><a href="#专业能力的提升" class="headerlink" title="专业能力的提升"></a>专业能力的提升</h2><p>计算机专业要学习的内容非常多，专业能力包含很多，光Android还不够，还有比如数据结构、算法、Linux、网络编程、计算机原理等等等等等等，由于我做的是 Android，那么这里就偏向 Android 来讲解了。</p><h3 id="深入理解原理，不要只会使用"><a href="#深入理解原理，不要只会使用" class="headerlink" title="深入理解原理，不要只会使用"></a>深入理解原理，不要只会使用</h3><p>由于开源的精神以及互联网的伟大，我们能够不费吹灰之力使用世界上顶尖的三方库，比如很火的 RxJava、EventBus、Retrofit、OkHttp 、Glide 等等等等。只要添加一行依赖，就能起飞，<strong>有一种自己掌握了全世界最牛逼的技术的错觉</strong>。</p><p>我见过不少人，也看到不少 人的Github 的库里写着 MVP+RxJava+Glide+Dagger 等等类似的内容，他们可能一线开源库用得很六，但是一旦问及原理，可能就一脸茫然，说不太上来。</p><p><strong>这其实就是停留在使用阶段的表现</strong>。</p><p>你要知道，<strong>一个库再牛逼，这个牛逼是属于作者的</strong>，而不是你。</p><p>站在面试官的角度讲，这么多人都会用，又凭什么选你呢？对吧？！</p><p>这时候如果你懂一些原理，那你就能比别人更优秀一些了。</p><p>那么，怎么去深入理解原理呢？<strong>阅读源码</strong>！</p><p>（退后，我要装 X 了！）</p><p><strong>其实所谓的原理，全都写在源码里面，毫无保留</strong>。</p><p>有的人一听看源码就会慌，不知所措，<strong>代码那么多，怎么看啊</strong>？</p><p>其实阅读源码也是有很多诀窍的，这里分享几点心得：</p><ol><li><strong>首先要会用</strong>。你要知道这个库是干什么的，掌握它基本的使用方法；</li><li><strong>有目的性</strong>。针对某个功能有目的的去挖掘，这样就不会在茫茫源码中迷失方向；</li><li><strong>不需要看完所有细节</strong>。有的人阅读源码爱钻牛角尖，非要把每一个小细节都搞清楚，以至于看了一天可能都没看明白主干是什么。</li></ol><p>是不是有点道理？比如 EventBus ，你发送个 Event 怎么就传递到了订阅的地方？带着这么个小问题有目的的去看，会轻松很多。</p><p>阅读源码确实不简单，但是不要着急，从简单的源码开始，慢慢提升，学会抽丝剥茧，层层递进，逐渐培养阅读源码的习惯与能力。</p><p><strong>相信我，学会看源码，对专业能力的提升有巨大的帮助。</strong></p><h3 id="保持学习，多看官方的一手资料"><a href="#保持学习，多看官方的一手资料" class="headerlink" title="保持学习，多看官方的一手资料"></a>保持学习，多看官方的一手资料</h3><p>在平时保证完成工作的情况下依然要保持学习，做不到每天学习，也要做到每周学习，扩大知识面，加深深度。</p><p>技术的发展非常快，要跟上得不断持续的学习，这很重要。</p><h5 id="那么为什么要多看官方的一手资料？"><a href="#那么为什么要多看官方的一手资料？" class="headerlink" title="那么为什么要多看官方的一手资料？"></a>那么为什么要多看官方的一手资料？</h5><p>说实在的，<strong>这个时代，已经不缺少学习资料了</strong>。但是呢，资料也是有好有坏的，众所周知，你用 google 搜跟 某度 搜到的资料会有很大的差别，所以<strong>第一步，把 google 作为默认搜索引擎</strong>。</p><p>官方资料 跟别人的二手资料，差别也是很大的。</p><p>这里不是说所有别人写的资料都是差的都是不值得看的，而是说其实别人可能也是看了官方的资料，经过自己的理解加工输出一个资料，而这个加工过程可能删减了部分内容，也可能扭曲/误解了官方的意思，以至于你看到的时候可能变了味。</p><p>所要尽量去看一手资料，它能让你学到<strong>最基本、最全面、也是最有用的知识</strong>，更何况，现在 Android 官方的文档 视频 越做越好，甚至都做了中文翻译，还有什么借口不看？</p><h3 id="保持学习，多看官方的一手资料-1"><a href="#保持学习，多看官方的一手资料-1" class="headerlink" title="保持学习，多看官方的一手资料"></a>保持学习，多看官方的一手资料</h3><p>前面我既让你看官方的资料，又让你去看源码，那么光看就够了吗？</p><p>显然不是，纸上得来终觉浅。</p><p><strong>学习，要做到有输入有输出，这样才能更好地把知识掌握在脑子里</strong>。</p><p>输入就是那些资料，源码等各种知识，那么输出是什么？对于开发者来说输出可以是笔记，可以是博客，也可以是代码。</p><p>作为过来人，劝你一句，如果时间允许的话，<strong>尝试维护个博客吧</strong>！</p><p>当你开始尝试针对某个知识点写文章的时候，你可能会有如下经历：</p><ol><li><strong>我明明已经懂了，为什么解释不清楚？（其实还没真的懂）</strong></li><li><strong>这个知识点好像涉及到了其他东西，我去看看，然后发现不懂的还有很多;</strong></li><li><strong>写得多了，本来星星点点散布在大脑各个角落的地方的零碎的知识点，在某个时刻突然就被串了起来，形成一张了知识图谱。</strong></li></ol><p>这是我之前写博客的真实经历，自己觉得懂了，跟 把知识说清楚让别人懂，感觉是两个层次的事。在写作的过程中会强迫你自己把知识点组合起来，用通俗的语言表达你的想法，其实要求你对知识有更透彻的理解，这也能促使你变得更专业。</p><p>另外，写博客其实也是对外展示自己的机会，写得好，会有阿里员工或猎头找上门的，帮你推荐工作的。</p><p><strong>好的博客或 Github 也是一块可以</strong>敲开阿里大门的砖。</p><hr><p>要加入阿里，你可能还需要学会如何写好简历，找个靠谱的阿里员工帮你内推，另外可能还需要一些运气，但这都是后话了，最最重要的前提就是<strong>自身的技术实力要过硬</strong>。</p><p>2019年伊始，全新的开始，相信很多人都给自己定了个小目标，希望我的这些经验能够帮到你实现其中的某一个，祝愿所有人能有个更加精彩美好的2019。</p><p>新的一年，要加油鸭！！！冲鸭！！！                                               </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阿里巴巴 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android多渠道打包技术对比</title>
      <link href="/blog/d27e6b00.html"/>
      <url>/blog/d27e6b00.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本文整理自我去年在公司内部做的一次分享，去掉了公司的信息，整理出来分享一下。<br>希望对读者有所帮助。</p></blockquote><p>加入公司后，就一直负责App的多渠道打包，今天来分享一下多渠道打包技术的介绍与对比，以及我们最后的选择。</p><h2 id="什么是多渠道打包技术"><a href="#什么是多渠道打包技术" class="headerlink" title="什么是多渠道打包技术"></a>什么是多渠道打包技术</h2><p>我们知道，由于某种黑暗力量，Android的亲爹市场 GooglePlay 不能进入大陆，导致大陆 Android 市场众多，如：小米、豌豆荚、华为等等等。  </p><p>当新版本发布，我们需要通过<strong>渠道号</strong>来区分不同的市场，为不同市场生成不同的包，再把对应的包上传到各个市场。这种为App打出不同渠道包的技术称为<strong>多渠道打包技术</strong>。</p><a id="more"></a><h2 id="怎么去做多渠道打包"><a href="#怎么去做多渠道打包" class="headerlink" title="怎么去做多渠道打包"></a>怎么去做多渠道打包</h2><p>多渠道打包实现有多种，但是有两点不会变：</p><ol><li>渠道区分</li><li>打包</li></ol><p>接下去介绍一下现今的多渠道打包技术，以及它们之间的对比。</p><h3 id="Umeng-Gradle"><a href="#Umeng-Gradle" class="headerlink" title="Umeng+Gradle"></a>Umeng+Gradle</h3><p>我们 App 集成了 Umeng 的服务，所以就拿它举例了，事实上，不用 Umeng 也没有丝毫关系。</p><h4 id="渠道的区分"><a href="#渠道的区分" class="headerlink" title="渠道的区分"></a>渠道的区分</h4><p>在<code>AndroidManifest.xml</code>中配置一个<code>meta-data</code>：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data</span><br><span class="line">    android:<span class="attribute">name</span>=<span class="string">"UMENG_CHANNEL"</span></span><br><span class="line">    android:<span class="attribute">value</span>=<span class="string">"<span class="variable">$&#123;CHANNEL_NAME&#125;</span>"</span>/&gt;</span><br></pre></td></tr></table></figure><p>然后在<code>app/build.gradle</code>里配置<code>productFlavors</code>：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">productFlavors</span> &#123;</span><br><span class="line">    <span class="attribute">def</span> path = <span class="string">"channels.txt"</span></span><br><span class="line">    file(path).eachLine &#123; <span class="attribute">channel</span> -&gt;</span><br><span class="line">        <span class="string">"<span class="variable">$channel</span>"</span> &#123;</span><br><span class="line">            <span class="attribute">manifestPlaceholders</span> = [CHANNEL_NAME: channel]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>PS：channels.txt 是渠道列表文件，每一行代表一个渠道，这样方便管理。</code></pre><h4 id="打包方法"><a href="#打包方法" class="headerlink" title="打包方法"></a>打包方法</h4><p>使用 <code>./gradlew assembleRelease</code>命令，就可以打出多渠道的包了。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>该种方式的打包原理是利用了 Gradle 的<code>flavors</code>功能来实现的，渠道的获取是通过如下代码方式获取。  </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ApplicationInfo appInfo</span> = cxt.getPackageManager().getApplicationInfo(cxt.getPackageName(), PackageManager.GET_META_DATA);</span><br><span class="line"><span class="attribute">String channel</span> = String.valueOf(appInfo.metaData.get(<span class="string">"UMENG_CHANNEL"</span>));</span><br></pre></td></tr></table></figure><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：  </p><ol><li>简单，易懂，没什么门槛，也不需要依赖其他工具与插件。</li><li>Gradle强大的<code>flavor</code>功能，可以实现不同渠道拥有不同的代码实现，可以给渠道做定制包。</li><li>扩展性强大，没有兼容性问题。</li></ol><p>缺点：</p><ol><li>打包速度极慢，因为每个渠道包都是从“0到1”，渠道一多，打包时间以小时为单位。  </li></ol><p>PS：我们 App 几百个渠道，用这种方式打包需要2多个小时，怎么受得了？。</p><p>所以，该方式适合渠道不多的时候使用，或者不同渠道需要使用不同的代码。</p><h2 id="美团的打包方案"><a href="#美团的打包方案" class="headerlink" title="美团的打包方案"></a><a href="http://tech.meituan.com/mt-apk-packaging.html" target="_blank" rel="noopener">美团的打包方案</a></h2><p>  上面说到，每个渠道包都是从“0到1”，然而实际上，渠道包之间的唯一差别仅仅在于一个渠道号（这里暂时只考虑不同渠道的代码相同），如果能拿已经打好的包，拿来修改一下渠道号，变成另一个渠道包，那这速度就能大幅度提高了。  </p><p><a href="http://tech.meituan.com/mt-apk-packaging.html" target="_blank" rel="noopener">美团的打包方案</a>，利用<code>META-INF</code>（解压APK可以看到）不参与 APK 签名的原理，在<code>META-INF</code>新增空的文件来代表渠道，实现了这个功能，极大的提高了打包的速度。</p><h4 id="渠道的区分-1"><a href="#渠道的区分-1" class="headerlink" title="渠道的区分"></a>渠道的区分</h4><p> <code>META-INF</code>目录下新增空文件，再在代码中读取文件名获取()。</p><p> PS：可以去市场下载一个美团 APP 来解压一下看看。</p><h4 id="打包方法-1"><a href="#打包方法-1" class="headerlink" title="打包方法"></a>打包方法</h4><p>由于美团并没有给出具体的实现代码，所以我当时尝试的是开源实现：<a href="https://github.com/GavinCT/AndroidMultiChannelBuildTool" target="_blank" rel="noopener">安卓多渠道打包工具</a> </p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>上面已经提到了，<code>META-INF</code>不参与 APK 签名。  </p><p>在<code>META-INF</code>目录下新增一个空的文件来代表渠道名。  </p><p>这样就可以只打一次签名包，后续只需拷贝，新增渠道文件即可。  </p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ol><li>速度极快,每打一个包就只需要复制一个APK，并新增一个空文件即可。（900个包一分钟，我天）</li><li>可以利用已存在的包打新的渠道包。（可多个）</li></ol><p>第2点其实也是非常棒的优点，当需要一个新的渠道包时，不再需要停下工作，去保存代码，切分支，build，打包，只要一个已存在的包，一个命令就好，非常方便。  </p><p>缺点：</p><ol><li>不安全，由于不需要签名，所以任何人都可以拿到已有的包，修改成任意其他渠道的包，可能会被恶意利用污染渠道数据。</li><li>扩展性较差。（暂时没有<code>Gradle</code>的实现方案，相对来说选择余地较小，扩展性也差一些）</li><li>不支持 <code>flavors</code></li><li>潜在风险，现在<code>META-INF</code>不参与APK签名，万一以后参与了，那么这套方案就失效了，当然这个概率估计很小。</li><li>似乎不支持 android 7.0？<a href="https://github.com/GavinCT/AndroidMultiChannelBuildTool/issues/16" target="_blank" rel="noopener">issue</a>(没亲测，未知)</li><li>需要修改代码，修改渠道的获取方式（Umeng配置修改）</li></ol><p>美团打包方式是一次大创新，最吸引人的就是速度快，真心快，就是打包的时间喝杯水再也不够了。</p><h2 id="packer-ng-plugin"><a href="#packer-ng-plugin" class="headerlink" title="packer-ng-plugin"></a><a href="https://github.com/mcxiaoke/packer-ng-plugin" target="_blank" rel="noopener">packer-ng-plugin</a></h2><p>名字太长，简称为 <code>packer</code> 吧。号称『下一代Android打包工具』，拥有与美团的方案相媲美的打包速度。</p><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>我们知道，其实 APK 是一个 Zip 文件，所以 APK 拥有 Zip 格式的特点。</p><p>该方法利用 Zip 格式的特点，修改<code>Comment Length</code>和<code>File Comment</code>两个字段，不会对ZIP文件造成破坏，将渠道信息放入其中，达到修改渠道的目的。由于修改以上内容也不需要重新签名打包，所以拥有与美团的方案相媲美的打包速度。</p><p>更多详情，见原项目Github。</p><h4 id="渠道区分"><a href="#渠道区分" class="headerlink" title="渠道区分"></a>渠道区分</h4><p>渠道信息存放在APK文件的注释字段<code>File Comment</code>，在代码中使用 packer 提供的方法获取。</p><h4 id="打包方法-2"><a href="#打包方法-2" class="headerlink" title="打包方法"></a>打包方法</h4><p>提供了三种实现方式，Gradle、Java、Python，都可以使用。</p><h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ol><li>打包速度极快。（与美团方案速度差不多）  </li><li>选择性更多，作者很良心，提供了Gradle，Java，Python三种实现。  </li><li>扩展性强大，由于有 Gradle 的实现方案，所以扩展性有了保障。  </li></ol><p>缺点：</p><ol><li>不支持 <code>flavors</code>。  </li><li>需要修改代码，修改渠道的获取方式。（Umeng配置修改）</li><li>有潜在兼容性问题，具体可见 <a href="https://github.com/mcxiaoke/packer-ng-plugin/blob/master/compatibility.md" target="_blank" rel="noopener">兼容性问题(已经解决)</a></li><li>潜在风险，Zip 格式万一修改，那么该方式失效，这概论应该也非常低。</li><li>已知360加固后，重新签名Apk后会抹去渠道信息。</li></ol><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><code>packer</code> 利用 Zip 格式，又一个多渠道打包的创新，速度极快，又安全，非常棒！</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><table><thead><tr><th style="text-align:center">对比项</th><th style="text-align:center">Gradle</th><th style="text-align:center">美团</th><th style="text-align:center">packer</th></tr></thead><tbody><tr><td style="text-align:center">是否支持 flavors</td><td style="text-align:center">是</td><td style="text-align:center">否</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">打包速度</td><td style="text-align:center">慢</td><td style="text-align:center">极快</td><td style="text-align:center">极快</td></tr><tr><td style="text-align:center">安全性</td><td style="text-align:center">高</td><td style="text-align:center">有风险</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">扩展性</td><td style="text-align:center">高</td><td style="text-align:center">较低</td><td style="text-align:center">较高</td></tr><tr><td style="text-align:center">兼容性问题</td><td style="text-align:center">无</td><td style="text-align:center">无</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">风险</td><td style="text-align:center">无</td><td style="text-align:center">极低</td><td style="text-align:center">极低</td></tr><tr><td style="text-align:center">加固影响</td><td style="text-align:center">无</td><td style="text-align:center">未测试</td><td style="text-align:center">丢失渠道信息(360加固)</td></tr></tbody></table><h2 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h2><p>目前只有Gradle支持<code>flavors</code>功能，所以如果这个需求强烈，那么就只能选择Gradle。</p><p>如果没有这个需求，那么相对于美团打包的方式，第三种方式packer更加安全一些，速度方面也令人满意。</p><p>当然如果使用美团方式，可以在服务端过滤非法的渠道，也是可以的！~（看了美团的 APK，渠道是明文的，所以估计也是在服务端处理的，如果用的是 Umeng 统计，那么就不行喽）。</p><p>最后我们的选择是，以<code>packer</code>为主，Gradle为辅。  </p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="http://tech.meituan.com/mt-apk-packaging.html" target="_blank" rel="noopener">美团Android自动化之旅—生成渠道包</a><br><a href="https://github.com/GavinCTAndroidMultiChannelBuildTool" target="_blank" rel="noopener">安卓多渠道打包工具</a>    </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多渠道打包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>invalidate和postInvalidate的关系与区别</title>
      <link href="/blog/d49b37a3.html"/>
      <url>/blog/d49b37a3.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我们知道，当我们需要重绘一个 View 的时候（onDraw ），通常我们有两个方法可供选择，invalidate 和 postInvalidate。</p><p>那么它们之间的关系与区别是什么呢？</p><p>本篇从源码角度分析 invalidate 与 postInvalidate 之间的关系区别。  </p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><code>invalidate</code>的代码调用路径：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    invalidate(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(<span class="keyword">boolean</span> invalidateCache)</span> </span>&#123;</span><br><span class="line">    invalidateInternal(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop, invalidateCache, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 invalidate 最后调用 invalidateInternal 去刷新，这里暂时不关心它们的具体实现。</p><p>然后再看看<code>postInvalidate</code>的代码调用路径：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">postInvalidate</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    postInvalidateDelayed(<span class="number">0</span>, left, top, right, bottom);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method can be invoked from outside of the UI thread</span></span><br><span class="line"><span class="comment"> * only when this View is attached to a window.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">postInvalidateDelayed</span><span class="params">(<span class="keyword">long</span> delayMilliseconds)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We try only with the AttachInfo because there's no point in invalidating</span></span><br><span class="line">    <span class="comment">// if we are not attached to our window</span></span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        attachInfo.mViewRootImpl.dispatchInvalidateDelayed(<span class="keyword">this</span>, delayMilliseconds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ViewRootImpl</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">dispatchInvalidateDelayed</span><span class="params">(View view, <span class="keyword">long</span> delayMilliseconds)</span> </span>&#123;</span><br><span class="line">    Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view);</span><br><span class="line">    mHandler.sendMessageDelayed(msg, delayMilliseconds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ViewRootImpl$ViewRootHandler extends Handler</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">    <span class="keyword">case</span> MSG_INVALIDATE:</span><br><span class="line">        ((View) msg.obj).invalidate();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> xxx:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>postInvalidate 其实是把 invalidate 这个操作封装成了一个 Message，post 到了 ViewRootImpl$ViewRootHandler 中去，最终在UI线程中调用了 View 的 invalidate。</p><p>我们知道，异步更新一个 View 会报<code>&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</code>（来自 ViewRootImplement$checkThread）的错误，</p><p>而 postInvalidate 可以在任意线程去调用，而不需要担心线程问题。  </p><p>PS：很多人说『一定要在主线程更新 UI』，其实不然，仔细看这报错信息指得是 original thread,而这个线程是创建 ViewRootImpl 的线程，而不是特指主线程，只不过是绝大部分情况下是主线程，仅此而已。  </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>关系：</p><ul><li>postInvalidate 其实最终调用的就是 invalidate</li></ul><p>差别：</p><ul><li>invalidate只能在 original thread 调用（一般就是主线程），而 postInvalidate 可以在任意线程调用。</li></ul><p>这结论其实早就知道了，但是光知道这结论是远远不够的，要深入源码去理解，找出结论的由来；</p><p>慢慢地，会发现，其实那些知识点以及结论其实就是从源码里得来的；</p><p>自己看源码，会收获更多意想不到的知识。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTFSC </tag>
            
            <tag> invalidate </tag>
            
            <tag> postInvalidate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LayoutInflater 源码分析（四）闪耀的彩蛋</title>
      <link href="/blog/25ab2ed0.html"/>
      <url>/blog/25ab2ed0.html</url>
      
        <content type="html"><![CDATA[<h2 id="BlinkLayout源码分析"><a href="#BlinkLayout源码分析" class="headerlink" title="BlinkLayout源码分析"></a>BlinkLayout源码分析</h2><pre><code>private static class BlinkLayout extends FrameLayout</code></pre><p>首先，我猜，你肯定不知道有这个<code>BlinkLayout</code>的存在！！！  </p><p>据我所知，没有一本书里讲到过它（反正我是没见过），甚至国内的博客都没有人提及过它！！  </p><p>因为它隐藏的非常深，是<code>LayoutInflater</code>的静态内部类，是我在看<code>LayoutInflater</code>源码的时候发现的！简直是个彩蛋！！    </p><a id="more"></a><p>在这里发现的：  </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (name.<span class="keyword">equals</span>(TAG_1995)) &#123;</span><br><span class="line">    <span class="comment">// Let's party like it's 1995!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BlinkLayout(context, attrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>oh,它其实还真算是个彩蛋，似乎是为了庆祝1995年的复活节，有兴趣可以看看<br><a href="https://www.reddit.com/r/androiddev/comments/3sekn8/lets_party_like_its_1995_from_the_layoutinflater/" target="_blank" rel="noopener">reddit</a>上的讨论。  </p><p>blink 有 使…闪烁的意思，可以用来做一闪一闪的效果哦！！！ </p><p>先上个简单的效果图看看它的效果：  </p><p><img src="http://ww2.sinaimg.cn/large/98900c07jw1f6pxwz67aqg207l0ckq30.gif" alt="效果图"></p><p>是不是很闪？  </p><p>明明这么闪耀，为何要躲起来？</p><p><code>BlinkLayout</code>的使用也有些特殊，它跟<code>merge</code>、<code>include</code>这些标签一样，用标签<code>blink</code>来表示。</p><p>贴一下上图效果的XML：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blink</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ImageView</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Hello World!"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blink</span>&gt;</span></span><br></pre></td></tr></table></figure><p>非常简单！</p><p>那么它是怎么实现的呢？</p><p>接下去源码分析。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><code>BlinkLayout</code>的源码非常简单，只有几十行！我就全部贴出来啦！  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BlinkLayout</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_BLINK = <span class="number">0x42</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BLINK_DELAY = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mBlink;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mBlinkState;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlinkLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler(<span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (msg.what == MESSAGE_BLINK) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mBlink) &#123;</span><br><span class="line">                        mBlinkState = !mBlinkState;</span><br><span class="line">                        <span class="comment">// 循环调用 makeBlink</span></span><br><span class="line">                        makeBlink();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 触发 dispatchDraw</span></span><br><span class="line">                    invalidate();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送blink指令</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeBlink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Message message = mHandler.obtainMessage(MESSAGE_BLINK);</span><br><span class="line">        mHandler.sendMessageDelayed(message, BLINK_DELAY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onAttachedToWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onAttachedToWindow();</span><br><span class="line">        <span class="comment">// 设置为可以闪啦</span></span><br><span class="line">        mBlink = <span class="keyword">true</span>;</span><br><span class="line">        mBlinkState = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        makeBlink();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDetachedFromWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDetachedFromWindow();</span><br><span class="line"></span><br><span class="line">        mBlink = <span class="keyword">false</span>;</span><br><span class="line">        mBlinkState = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 移除消息 避免内存泄漏</span></span><br><span class="line">        mHandler.removeMessages(MESSAGE_BLINK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过这个开关来控制是否分发绘制事件，来达到一闪一闪的效果</span></span><br><span class="line">        <span class="keyword">if</span> (mBlinkState) &#123;</span><br><span class="line">            <span class="keyword">super</span>.dispatchDraw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出，<code>BlinkLayout</code>通过Handler循环调用<code>invalidate()</code>方法，触发并控制<code>dispatchDraw</code>来做到一闪一闪的效果，默认的闪烁间隔为Handler的DELAY时间，即500毫秒。  </p><p>##　小结</p><p><code>BlinkLayout</code>的使用场景或许不多，但是它的代码还是非常漂亮哒！~  </p><p>如果有类似需求，仿造它的源码写一个功能更强的View也是非常简单的！  </p><p>深入源码阅读是一件相对枯燥的事情，能发现这么个小彩蛋也是棒棒的，心情也美丽了些，哈哈！~~  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTFSC </tag>
            
            <tag> LayoutInflater </tag>
            
            <tag> BlinkLayout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LayoutInflater源码分析（三）fragment 标签的处理</title>
      <link href="/blog/4b58bbac.html"/>
      <url>/blog/4b58bbac.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇<a href="http://yifeiyuan.me/2017/01/03/analyze-layoutinflater2-include-and-merge/">LayoutInflater 源码分析（二）</a>中分析了<code>LayoutInflater</code>对<code>include</code>以及<code>merge</code>标签的处理，但是并没有找到对<code>fragment</code>的处理痕迹。</p><p>本文将继续探索以求揭晓答案。</p><p>可能有同学不知道，在这里提一下<code>fragment</code>标签的使用方式： </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;fragment</span><br><span class="line">    android:<span class="attribute">layout_width</span>=<span class="string">"match_parent"</span></span><br><span class="line">    android:<span class="attribute">layout_height</span>=<span class="string">"match_parent"</span></span><br><span class="line">    <span class="attribute">class</span>=<span class="string">"me.yifeiyuan.MainFragment"</span></span><br><span class="line">    android:<span class="attribute">tag</span>=<span class="string">"Main"</span></span><br><span class="line">    android:<span class="attribute">id</span>=<span class="string">"@+id/main"</span></span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure><p>这属于加载 Fragment 中的<strong>静态加载</strong>，在 XML 中写死了 class，缺乏灵活性，实际开发中并不常用，甚至已经淘汰了，所以不推荐使用。</p><p>不过这并不妨碍对它的原理探究。</p><a id="more"></a><h2 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h2><p>在第一篇分析中提到了 Factory 的 Hook 机制，代码如下:</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">View</span> <span class="built_in">view</span>;</span><br><span class="line"><span class="keyword">if</span> (mFactory2 != <span class="built_in">null</span>) &#123;</span><br><span class="line">    view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="built_in">null</span>) &#123;</span><br><span class="line">    view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    view = <span class="built_in">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mPrivateFactory 是个 FactoryMerger </span></span><br><span class="line"><span class="keyword">if</span> (view == <span class="built_in">null</span> &amp;&amp; mPrivateFactory != <span class="built_in">null</span>) &#123;</span><br><span class="line">    view = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了便于理解那些个 Factory，特意大致的画了一张类图：</p><p><img src="http://ww2.sinaimg.cn/large/98900c07jw1f6y3urd07wj21560lsjul.jpg" width="741" height="392"></p><p>注意：前面代码中的mPrivateFactory 是个 FactoryMerger 对象。  </p><p>可能看到这里还是会有些茫然，不过仔细一回想我们在使用 Fragment 的时候都会继承 FragmentActivity，所以去 FragmentActivity 寻找答案感觉比较靠谱。</p><p>接下去开始分析。</p><h2 id="寻找踪迹之-FragmentActivity"><a href="#寻找踪迹之-FragmentActivity" class="headerlink" title="寻找踪迹之 FragmentActivity"></a>寻找踪迹之 FragmentActivity</h2><p>查看了源码后发现，FragmentActivity 的继承结构如下 </p><p><img src="http://ww3.sinaimg.cn/large/98900c07jw1f6wnvk60gkj20fq0r0wfs.jpg" width="398" height="400"></p><p>其实 Activity 就已经实现了 LayoutInflater.Factory2 接口，具体实现如下：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> View onCreateView(View <span class="keyword">parent</span>, <span class="built_in">String</span> name, Context context, AttributeSet attrs) &#123;</span><br><span class="line">    <span class="comment">// 如果不是 fragment 则调用另一个onCreateView，而它返回的是 null</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="string">"fragment"</span>.<span class="keyword">equals</span>(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> onCreateView(name, context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是 fragment 标签 则交给了 mFragments</span></span><br><span class="line">    <span class="keyword">return</span> mFragments.onCreateView(<span class="keyword">parent</span>, name, context, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> View onCreateView(<span class="built_in">String</span> name, Context context, AttributeSet attrs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如果是 fragment 标签，则会交给一个叫 mFragments 的FragmentController类的对象。</p><p>但是需要注意的是：<strong>Activity 并没有调用 LayoutInflater.setFactory 使之生效，所以 Activity 并不支持 fragment 的解析</strong>。</p><p>继续看它的子类的实现。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Donut 好古老的版本啊~</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseFragmentActivityDonut</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">Build</span>.<span class="type">VERSION</span>.<span class="type">SDK_INT</span> &lt; <span class="number">11</span> &amp;&amp; getLayoutInflater().getFactory() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// On pre-HC devices we need to manually install ourselves as a Factory.</span></span><br><span class="line">            <span class="comment">// On HC and above, we are automatically installed as a private factory</span></span><br><span class="line">            getLayoutInflater().setFactory(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写 onCreateView</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">View</span> onCreateView(<span class="type">String</span> name, <span class="type">Context</span> context, <span class="type">AttributeSet</span> attrs) &#123;</span><br><span class="line">    <span class="comment">//　优先调用 dispatchFragmentsOnCreateView</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> v = dispatchFragmentsOnCreateView(<span class="literal">null</span>, name, context, attrs);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onCreateView(name, context, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="type">View</span> dispatchFragmentsOnCreateView(<span class="type">View</span> parent, <span class="type">String</span> name,</span><br><span class="line">            <span class="type">Context</span> context, <span class="type">AttributeSet</span> attrs);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Honeycomb</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseFragmentActivityHoneycomb</span> <span class="keyword">extends</span> <span class="title">BaseFragmentActivityDonut</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">View</span> onCreateView(<span class="type">View</span> parent, <span class="type">String</span> name, <span class="type">Context</span> context, <span class="type">AttributeSet</span> attrs) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> v = dispatchFragmentsOnCreateView(parent, name, context, attrs);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="literal">null</span> &amp;&amp; <span class="type">Build</span>.<span class="type">VERSION</span>.<span class="type">SDK_INT</span> &gt;= <span class="number">11</span>) &#123;</span><br><span class="line">            <span class="comment">// If we're running on HC or above, let the super have a go</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onCreateView(parent, name, context, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// FragmentActivity 并没有重写 onCreateView</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FragmentActivity</span> <span class="keyword">extends</span> <span class="title">BaseFragmentActivityHoneycomb</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">View</span> dispatchFragmentsOnCreateView(<span class="type">View</span> parent, <span class="type">String</span> name, <span class="type">Context</span> context,</span><br><span class="line">            <span class="type">AttributeSet</span> attrs) &#123;</span><br><span class="line">        <span class="keyword">return</span> mFragments.onCreateView(parent, name, context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在<code>BaseFragmentActivityDonut</code>中调用了<code>setFactory</code>，并定义了一个<code>dispatchFragmentsOnCreateView</code>抽象方法，并在<code>onCreateView</code>里调用了它，这样就把创建 View 的工作交给了<code>dispatchFragmentsOnCreateView</code>。</p><p>接着，在 FragmentActivity 重写<code>dispatchFragmentsOnCreateView</code>，又把它交给了<code>mFragments</code>，咦，又回去了。</p><p>其实到这里已经可以知道，<code>LayoutInflater</code>把处理<code>fragment</code>的事情最终交给了<code>FragmentManagerImpl</code>。</p><p>而对于<code>FragmentManagerImpl</code>的分析其实已经超过了本文的界限。  </p><p>但是我想再深入，看看<code>Fragment</code>的<code>onCreateView</code>方法究竟是什么时候调用的！！</p><p>所以继续跟下去：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> View onCreateView(View <span class="keyword">parent</span>, <span class="built_in">String</span> name, Context context, AttributeSet attrs) &#123;</span><br><span class="line">    <span class="comment">//mFragmentManager 是 FragmentManagerImpl 的实例</span></span><br><span class="line">    <span class="keyword">return</span> mHost.mFragmentManager.onCreateView(<span class="keyword">parent</span>, name, context, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #FragmentManagerImpl </span></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> View onCreateView(View <span class="keyword">parent</span>, <span class="built_in">String</span> name, Context context, AttributeSet attrs) &#123;</span><br><span class="line">    <span class="comment">// 不为 fragment 直接 return null 说明确实只处理 fragment</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="string">"fragment"</span>.<span class="keyword">equals</span>(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// xml 中的 各种 属性 fname为 Fragemnt 的全路径</span></span><br><span class="line">    <span class="built_in">String</span> fname = attrs.getAttributeValue(<span class="built_in">null</span>, <span class="string">"class"</span>);</span><br><span class="line">    TypedArray a =  context.obtainStyledAttributes(attrs, FragmentTag.Fragment);</span><br><span class="line">    <span class="keyword">if</span> (fname == <span class="built_in">null</span>) &#123;</span><br><span class="line">        fname = a.getString(FragmentTag.Fragment_name);</span><br><span class="line">    &#125;</span><br><span class="line">    int id = a.getResourceId(FragmentTag.Fragment_id, View.NO_ID);</span><br><span class="line">    <span class="built_in">String</span> <span class="built_in">tag</span> = a.getString(FragmentTag.Fragment_tag);</span><br><span class="line">    a.recycle();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Fragment.isSupportFragmentClass(mHost.getContext(), fname)) &#123;</span><br><span class="line">        <span class="comment">// Invalid support lib fragment; let the device's framework handle it.</span></span><br><span class="line">        <span class="comment">// This will allow android.app.Fragments to do the right thing.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果配置的信息不够 则会抛异常</span></span><br><span class="line">    int containerId = <span class="keyword">parent</span> != <span class="built_in">null</span> ? <span class="keyword">parent</span>.getId() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (containerId == View.NO_ID &amp;&amp; id == View.NO_ID &amp;&amp; <span class="built_in">tag</span> == <span class="built_in">null</span>) &#123;</span><br><span class="line">        throw <span class="literal">new</span> IllegalArgumentException(attrs.getPositionDescription()</span><br><span class="line">                + <span class="string">": Must specify unique android:id, android:tag, or have a parent with an id for "</span> + fname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we restored from a previous state, we may already have</span></span><br><span class="line">    <span class="comment">// instantiated this fragment from the state and should use</span></span><br><span class="line">    <span class="comment">// that instance instead of making a new one.</span></span><br><span class="line">    <span class="comment">// 尝试着先去找 fragment</span></span><br><span class="line">    Fragment fragment = id != View.NO_ID ? findFragmentById(id) : <span class="built_in">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (fragment == <span class="built_in">null</span> &amp;&amp; <span class="built_in">tag</span> != <span class="built_in">null</span>) &#123;</span><br><span class="line">        fragment = findFragmentByTag(<span class="built_in">tag</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fragment == <span class="built_in">null</span> &amp;&amp; containerId != View.NO_ID) &#123;</span><br><span class="line">        fragment = findFragmentById(containerId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FragmentManagerImpl.DEBUG) <span class="keyword">Log</span>.v(<span class="built_in">TAG</span>, <span class="string">"onCreateView: id=0x"</span></span><br><span class="line">            + <span class="built_in">Integer</span>.toHexString(id) + <span class="string">" fname="</span> + fname</span><br><span class="line">            + <span class="string">" existing="</span> + fragment);</span><br><span class="line">    <span class="comment">// 如果没有 则去实例化</span></span><br><span class="line">    <span class="keyword">if</span> (fragment == <span class="built_in">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用 instantiate 其实也是反射来实例化的。</span></span><br><span class="line">        fragment = Fragment.instantiate(context, fname);</span><br><span class="line">        fragment.mFromLayout = <span class="literal">true</span>;</span><br><span class="line">        fragment.mFragmentId = id != <span class="number">0</span> ? id : containerId;</span><br><span class="line">        fragment.mContainerId = containerId;</span><br><span class="line">        fragment.mTag = <span class="built_in">tag</span>;</span><br><span class="line">        fragment.mInLayout = <span class="literal">true</span>;</span><br><span class="line">        fragment.mFragmentManager = this;</span><br><span class="line">        fragment.mHost = mHost;</span><br><span class="line">        fragment.onInflate(mHost.getContext(), attrs, fragment.mSavedFragmentState);</span><br><span class="line">        addFragment(fragment, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fragment.mInLayout) &#123;</span><br><span class="line">        <span class="comment">// A fragment already exists and it is not one we restored from</span></span><br><span class="line">        <span class="comment">// previous state.</span></span><br><span class="line">        throw <span class="literal">new</span> IllegalArgumentException(attrs.getPositionDescription()</span><br><span class="line">                + <span class="string">": Duplicate id 0x"</span> + <span class="built_in">Integer</span>.toHexString(id)</span><br><span class="line">                + <span class="string">", tag "</span> + <span class="built_in">tag</span> + <span class="string">", or parent id 0x"</span> + <span class="built_in">Integer</span>.toHexString(containerId)</span><br><span class="line">                + <span class="string">" with another fragment for "</span> + fname);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This fragment was retained from a previous instance; get it</span></span><br><span class="line">        <span class="comment">// going now.</span></span><br><span class="line">        fragment.mInLayout = <span class="literal">true</span>;</span><br><span class="line">        fragment.mHost = mHost;</span><br><span class="line">        <span class="comment">// If this fragment is newly instantiated (either right now, or</span></span><br><span class="line">        <span class="comment">// from last saved state), then give it the attributes to</span></span><br><span class="line">        <span class="comment">// initialize itself.</span></span><br><span class="line">        <span class="keyword">if</span> (!fragment.mRetaining) &#123;</span><br><span class="line">            fragment.onInflate(mHost.getContext(), attrs, fragment.mSavedFragmentState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we haven't finished entering the CREATED state ourselves yet,</span></span><br><span class="line">    <span class="comment">// push the inflated child fragment along.</span></span><br><span class="line">    <span class="keyword">if</span> (mCurState &lt; Fragment.CREATED &amp;&amp; fragment.mFromLayout) &#123;</span><br><span class="line">        moveToState(fragment, Fragment.CREATED, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        moveToState(fragment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fragment.mView == <span class="built_in">null</span>) &#123;</span><br><span class="line">        throw <span class="literal">new</span> IllegalStateException(<span class="string">"Fragment "</span> + fname</span><br><span class="line">                + <span class="string">" did not create a view."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (id != <span class="number">0</span>) &#123;</span><br><span class="line">        fragment.mView.setId(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fragment.mView.getTag() == <span class="built_in">null</span>) &#123;</span><br><span class="line">        fragment.mView.setTag(<span class="built_in">tag</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fragment.mView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在处理 xml 中的属性后，会先去寻找要加载的 fragment 是否已经加载过了，如果没有则会调用<code>fragment = Fragment.instantiate(context, fname);</code>，这个方法也是<br>反射，这点其实跟 View 的处理是一样的。  </p><p>接着会去调用<code>moveToState</code>方法，而这个方法里，我看了<code>onCreateView</code>方法的调用时机。</p><p>伪代码如下（太复杂，删减了绝大部分代码）：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// # FragmentManager</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(Fragment f, <span class="keyword">int</span> newState, <span class="keyword">int</span> transit, <span class="keyword">int</span> transitionStyle,<span class="keyword">boolean</span> keepActive)</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">f.mView = f.performCreateView(xxx);</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 真正的调用时机在这里！！</span></span><br><span class="line"><span class="comment">// # Fragment</span></span><br><span class="line">View performCreateView(LayoutInflater inflater, ViewGroup container,</span><br><span class="line">        Bundle savedInstanceState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mChildFragmentManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mChildFragmentManager.noteStateNotSaved();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用onCreateView 熟悉吧？</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">onCreateView</span><span class="params">(inflater, container, savedInstanceState)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>FragmentManager</code>的<code>moveToState</code>中会去调用<code>Fragment</code>的<code>performCreateView</code>方法，而它里面，调用了<code>onCreateView</code>！！</p><p><code>onCreateView</code>熟悉吧？就是我们使用 <code>Fragment</code> 第一个重写的方法！</p><p>终于找到啦！！  </p><p>呼，藏得真深。  </p><p>不过功夫不负有心人！~~~  </p><p>爽！~  </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>FragmentActivity</code>通过 <code>setFactory</code>把对<code>fragment</code>标签的处理委托给了 <code>FragmentManageImpl</code>的<code>onCreateView</code>方法。</p><p>最终通过反射，实例化指定的 <code>Fragment</code>，并调用了<code>Fragment.performCreateView</code>，最后到我们所熟悉的<code>onCreateView</code>。  </p><p>整体的流程分析完毕。  </p><p>另外要说的是，<code>LayoutInflater.Factory</code>的作用其实非常强大，我们可以 Hook 每个 View 的创建于设置，比如 <code>AppCompact</code>库通过<code>AppCompactViewInflater</code> Hook 了大部分 View，给我们提供了向下兼容的功能；</p><p>另外它也还可以配合 DayNight 实现夜间模式功能，有兴趣可以去看看<code>AppCompactActivity</code>、<code>AppCompactViewInflater</code>等类，有机会再讲吧。  </p><p>到此对于 LayoutInflater 的源码分析已经结束，在查看源码的过程中发现一枚彩蛋，下一篇分享。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="http://yifeiyuan.me/2016/07/12/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CoordinateLayout/">一步一步深入理解CoordinatorLayout</a><br><a href="http://yifeiyuan.me/2016/12/27/deep-into-viewstub/">ViewStub是如何实现懒加载的</a><br><a href="http://yifeiyuan.me/2016/12/29/analyze-space/">Space源码分析</a><br><a href="http://yifeiyuan.me/2017/01/02/analyze-layoutinflater1-inflate/">LayoutInflater 源码分析（一）之 inflate 深度分析</a><br><a href="http://yifeiyuan.me/2017/01/03/analyze-layoutinflater2-include-and-merge/">LayoutInflater源码分析（二）之include以及merge标签的处理</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTFSC </tag>
            
            <tag> LayoutInflater </tag>
            
            <tag> Fragment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LayoutInflater源码分析（二）include以及merge标签的处理</title>
      <link href="/blog/728b7f25.html"/>
      <url>/blog/728b7f25.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接上篇<a href="http://yifeiyuan.me/2017/01/02/analyze-layoutinflater1-inflate/">LayoutInflater 源码分析（一）之 inflate 深度分析</a>  </p><p>本篇继续对<code>LayoutInflater</code>进行源码分析,目标为分析<code>LayoutInflater</code>对<code>include</code>、<code>merge</code>、<code>fragment</code>等标签的处理原理以及<code>onFinishInflate</code>的调用时机。  </p><a id="more"></a><h2 id="merge-标签分析"><a href="#merge-标签分析" class="headerlink" title="merge 标签分析"></a>merge 标签分析</h2><p>上篇我们讲到<code>inflate</code>方法中出现 Merge 的踪迹，代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (TAG_MERGE.<span class="keyword">equals</span>(name)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || !attachToRoot) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;merge /&gt; can be used only with a valid "</span></span><br><span class="line">                + <span class="string">"ViewGroup root and attachToRoot=true"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 rInflate 注意最后的参数是 false</span></span><br><span class="line">    rInflate(parser, root, inflaterContext, attrs, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以需要看 <code>rInflate</code>方法才行。</p><h3 id="rInflate-深入解析"><a href="#rInflate-深入解析" class="headerlink" title="rInflate 深入解析"></a>rInflate 深入解析</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursive method used to descend down the xml hierarchy and instantiate</span></span><br><span class="line"><span class="comment"> * views, instantiate their children, and then call onFinishInflate().</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;strong&gt;Note:&lt;/strong&gt; Default visibility so the BridgeInflater can</span></span><br><span class="line"><span class="comment"> * override it.</span></span><br><span class="line"><span class="comment"> * 递归方法 实例化 View 以及它的子 View,并且调用 onFinishInflate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="literal">void</span> rInflate(XmlPullParser parser, View <span class="keyword">parent</span>, Context context,</span><br><span class="line">        AttributeSet attrs, <span class="built_in">boolean</span> finishInflate) throws XmlPullParserException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    final int depth = parser.getDepth();</span><br><span class="line">    int <span class="keyword">type</span>;</span><br><span class="line">    <span class="comment">// while 循环 parser.next  遍历整个 XML </span></span><br><span class="line">    <span class="keyword">while</span> (((<span class="keyword">type</span> = parser.next()) != XmlPullParser.END_TAG ||</span><br><span class="line">            parser.getDepth() &gt; depth) &amp;&amp; <span class="keyword">type</span> != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">type</span> != XmlPullParser.START_TAG) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取标签名</span></span><br><span class="line">        final <span class="built_in">String</span> name = parser.getName();</span><br><span class="line">        <span class="comment">//如果是 requestFocus</span></span><br><span class="line">        <span class="keyword">if</span> (TAG_REQUEST_FOCUS.<span class="keyword">equals</span>(name)) &#123;</span><br><span class="line">            parseRequestFocus(parser, <span class="keyword">parent</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_TAG.<span class="keyword">equals</span>(name)) &#123;</span><br><span class="line">        <span class="comment">// 处理 tag</span></span><br><span class="line">            parseViewTag(parser, <span class="keyword">parent</span>, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_INCLUDE.<span class="keyword">equals</span>(name)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parser.getDepth() == <span class="number">0</span>) &#123;</span><br><span class="line">                throw <span class="literal">new</span> InflateException(<span class="string">"&lt;include /&gt; cannot be the root element"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理 include</span></span><br><span class="line">            parseInclude(parser, context, <span class="keyword">parent</span>, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_MERGE.<span class="keyword">equals</span>(name)) &#123;</span><br><span class="line">        <span class="comment">// merge 里不能再有 merge 标签的</span></span><br><span class="line">            throw <span class="literal">new</span> InflateException(<span class="string">"&lt;merge /&gt; must be the root element"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不是特殊的标签那么走 createViewFromTag</span></span><br><span class="line">            final View view = createViewFromTag(<span class="keyword">parent</span>, name, context, attrs);</span><br><span class="line">            final ViewGroup viewGroup = (ViewGroup) <span class="keyword">parent</span>;</span><br><span class="line">            final ViewGroup.LayoutParams <span class="keyword">params</span> = viewGroup.generateLayoutParams(attrs);</span><br><span class="line">            rInflateChildren(parser, view, attrs, <span class="literal">true</span>);</span><br><span class="line">            viewGroup.addView(view, <span class="keyword">params</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意这里从传递inflate传递过来的是 false！！</span></span><br><span class="line">    <span class="comment">// 从 rInflateChildren 过来的是 true！！！</span></span><br><span class="line">    <span class="keyword">if</span> (finishInflate) &#123;</span><br><span class="line">        <span class="keyword">parent</span>.onFinishInflate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从注释来看<code>rInflate</code>方法，是个 <strong>递归方法</strong> 实例化 View 以及它的子 View,<strong>并且调用 <code>onFinishInflate</code></strong> </p><p>从源码来看，<code>rInflate</code>方法先判断特殊的标签名，优先处理：</p><ul><li>针对<code>requestFocus</code>标签,调用parseRequestFocus方法</li><li>针对<code>tag</code>标签，调用 parseViewTag 方法</li><li>针对<code>merge</code>标签则直接抛了异常，因为<code>merge</code>标签不能是子元素</li></ul><p>很奇怪，并没有看到 <code>fragment</code> 标签的处理逻辑!</p><p>处理完特殊标签之后走到最后一个else 块中，这块代码需要注意：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果不是特殊的标签那么走 createViewFromTag 获得 view</span></span><br><span class="line"><span class="comment">// createViewFromTag 方法的流程已经分析过了，不再多说。  </span></span><br><span class="line"><span class="keyword">final</span> View view = createViewFromTag(parent, name, context, attrs);</span><br><span class="line"><span class="comment">// 注意注意 这边的 parent 是之前inflate传入的 root</span></span><br><span class="line"><span class="keyword">final</span> ViewGroup viewGroup = (ViewGroup) parent;</span><br><span class="line"><span class="comment">// 生成 paramas</span></span><br><span class="line"><span class="keyword">final</span> ViewGroup.LayoutParams <span class="keyword">params</span> = viewGroup.generateLayoutParams(attrs);</span><br><span class="line"><span class="comment">// 调用 rInflateChildren 把 view传递过去 并传了一个 true 过去</span></span><br><span class="line">rInflateChildren(parser, view, attrs, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 注意</span></span><br><span class="line"><span class="comment">// 注意</span></span><br><span class="line"><span class="comment">// 注意</span></span><br><span class="line"><span class="comment">// 这里直接调用 viewGroup 的 addView 这也是 merge 能减少层级的根本原因</span></span><br><span class="line">viewGroup.addView(view, <span class="keyword">params</span>);</span><br></pre></td></tr></table></figure><p>这里涉及到一个方法<code>rInflateChildren</code>，其实它在上一篇中的<code>inflate</code>方法中出现过，不过我并没有去分析，所以这里讲一下。  </p><p>方法实现如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> rInflateChildren(XmlPullParser parser, View parent, AttributeSet attrs,</span><br><span class="line">        <span class="keyword">boolean</span> finishInflate) <span class="keyword">throws</span> XmlPullParserException, IOException &#123;</span><br><span class="line">    rInflate(parser, parent, parent.getContext(), attrs, finishInflate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rInflateChildren</code> 是个递归方法，被用来实例化不是 <code>root</code> 的子View，实际也是调用<code>rInflate</code>方法。(所以才是递归了嘛！)</p><p>这里需要注意的是<code>finishInflate</code>，按照之前所说的流程，<code>rInflate</code>方法传递过来的<code>finishInflate</code>参数为<code>false</code>,在上一篇中<code>inflate</code>传递的参数是<code>true</code>,这关系到<code>onFinishInflate</code>的回调。</p><p>了解完<code>rInflateChildren</code>方法后，继续分析。</p><p>可以看到，在处理<code>merge</code>标签的时候，是将<code>merge</code>标签里解析出来的 View 直接 add 到了传递进来的<code>root</code>中去了，而并不会多加一层 View，从而实现减少层级的效果，这就是<code>merge</code>标签的原理所在了。<br>最后，由于<code>inflate</code>传递进来的<code>finishInflate</code>为 false，所以不会去调用<code>parent.onFinishInflate();</code></p><p>到此也知晓了<code>LayoutInflater</code>是如何处理<code>merge</code>标签以及<code>merge</code>减少布局层次的原理了。  </p><h2 id="include-标签"><a href="#include-标签" class="headerlink" title="include 标签"></a>include 标签</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> parseInclude(XmlPullParser parser, Context context, View parent,</span><br><span class="line">        AttributeSet attrs) <span class="keyword">throws</span> XmlPullParserException, IOException &#123;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> ViewGroup) &#123;</span><br><span class="line">        <span class="comment">// Apply a theme wrapper, if requested. This is sort of a weird</span></span><br><span class="line">        <span class="comment">// edge case, since developers think the &lt;include&gt; overwrites</span></span><br><span class="line">        <span class="comment">// values in the AttributeSet of the included View. So, if the</span></span><br><span class="line">        <span class="comment">// included View has a theme attribute, we'll need to ignore it.</span></span><br><span class="line">        <span class="keyword">final</span> TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> themeResId = ta.getResourceId(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> hasThemeOverride = themeResId != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (hasThemeOverride) &#123;</span><br><span class="line">            context = <span class="keyword">new</span> ContextThemeWrapper(context, themeResId);</span><br><span class="line">        &#125;</span><br><span class="line">        ta.recycle();</span><br><span class="line">        <span class="comment">// If the layout is pointing to a theme attribute, we have to</span></span><br><span class="line">        <span class="comment">// massage the value to get a resource identifier out of it.</span></span><br><span class="line">        <span class="keyword">int</span> layout = attrs.getAttributeResourceValue(<span class="keyword">null</span>, ATTR_LAYOUT, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (layout == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有 layout 属性则抛异常</span></span><br><span class="line">            <span class="keyword">final</span> String value = attrs.getAttributeValue(<span class="keyword">null</span>, ATTR_LAYOUT);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span> || value.length() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"You must specify a layout in the"</span></span><br><span class="line">                        + <span class="string">" include tag: &lt;include layout=\"@layout/layoutID\" /&gt;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Attempt to resolve the "?attr/name" string to an identifier.</span></span><br><span class="line">            layout = context.getResources().getIdentifier(value.substring(<span class="number">1</span>), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The layout might be referencing a theme attribute.</span></span><br><span class="line">        <span class="keyword">if</span> (mTempValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTempValue = <span class="keyword">new</span> TypedValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (layout != <span class="number">0</span> &amp;&amp; context.getTheme().resolveAttribute(layout, mTempValue, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            layout = mTempValue.resourceId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 之前的代码都是处理 theme layout 属性 不多说。</span></span><br><span class="line">        <span class="keyword">if</span> (layout == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 必须指定有效的layout</span></span><br><span class="line">            <span class="keyword">final</span> String value = attrs.getAttributeValue(<span class="keyword">null</span>, ATTR_LAYOUT);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"You must specify a valid layout "</span></span><br><span class="line">                    + <span class="string">"reference. The layout ID "</span> + value + <span class="string">" is not valid."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> XmlResourceParser childParser = context.getResources().getLayout(layout);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> AttributeSet childAttrs = Xml.asAttributeSet(childParser);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> ((type = childParser.<span class="keyword">next</span>()) != XmlPullParser.START_TAG &amp;&amp;</span><br><span class="line">                        type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                    <span class="comment">// Empty.</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(childParser.getPositionDescription() +</span><br><span class="line">                            <span class="string">": No start tag found!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> String childName = childParser.getName();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (TAG_MERGE.equals(childName)) &#123;</span><br><span class="line">                    <span class="comment">// The &lt;merge&gt; tag doesn't support android:theme, so</span></span><br><span class="line">                    <span class="comment">// nothing special to do here.</span></span><br><span class="line">                    rInflate(childParser, parent, context, childAttrs, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 获取 被 inlcude 的 topview</span></span><br><span class="line">                    <span class="keyword">final</span> View view = createViewFromTag(parent, childName,</span><br><span class="line">                            context, childAttrs, hasThemeOverride);</span><br><span class="line">                    <span class="keyword">final</span> ViewGroup <span class="keyword">group</span> = (ViewGroup) parent;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> TypedArray a = context.obtainStyledAttributes(</span><br><span class="line">                            attrs, R.styleable.<span class="keyword">Include</span>);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> id = a.getResourceId(R.styleable.Include_id, View.NO_ID);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> visibility = a.getInt(R.styleable.Include_visibility, -<span class="number">1</span>);</span><br><span class="line">                    a.recycle();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// We try to load the layout params set in the &lt;include /&gt; tag.</span></span><br><span class="line">                    <span class="comment">// If the parent can't generate layout params (ex. missing width</span></span><br><span class="line">                    <span class="comment">// or height for the framework ViewGroups, though this is not</span></span><br><span class="line">                    <span class="comment">// necessarily true of all ViewGroups) then we expect it to throw</span></span><br><span class="line">                    <span class="comment">// a runtime exception.</span></span><br><span class="line">                    <span class="comment">// We catch this exception and set localParams accordingly: true</span></span><br><span class="line">                    <span class="comment">// means we successfully loaded layout params from the &lt;include&gt;</span></span><br><span class="line">                    <span class="comment">// tag, false means we need to rely on the included layout params.</span></span><br><span class="line">                    ViewGroup.LayoutParams params = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;<span class="comment">// 尝试对 include 标签生成 params</span></span><br><span class="line">                        params = <span class="keyword">group</span>.generateLayoutParams(attrs);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                        <span class="comment">// Ignore, just fail over to child attrs.</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果失败 则对被 include 的 topview 处理</span></span><br><span class="line">                    <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        params = <span class="keyword">group</span>.generateLayoutParams(childAttrs);</span><br><span class="line">                    &#125;</span><br><span class="line">                    view.setLayoutParams(params);</span><br><span class="line">                    <span class="comment">// Inflate all children.  前面已经提到过了</span></span><br><span class="line">                    rInflateChildren(childParser, view, childAttrs, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="comment">// 处理 id</span></span><br><span class="line">                    <span class="keyword">if</span> (id != View.NO_ID) &#123;</span><br><span class="line">                        view.setId(id);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 处理可见性</span></span><br><span class="line">                    <span class="keyword">switch</span> (visibility) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                            view.setVisibility(View.VISIBLE);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                            view.setVisibility(View.INVISIBLE);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                            view.setVisibility(View.GONE);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 把 view 添加到 group 中</span></span><br><span class="line">                    <span class="keyword">group</span>.addView(view);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                childParser.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;include /&gt; can only be used inside of a ViewGroup"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LayoutInflater.consumeChildElements(parser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断 parent 是不是个 ViewGroup,如果不是则直接抛异常。  </p><p>如果是则接下去处理 <code>theme</code> 属性以及 <code>layout</code> 属性，我们知道使用<code>include</code>标签，<code>layout</code> 属性是必须要有的。  </p><p>其原因就是在源码中如果发现没有指定 <code>layout</code> 属性的话，那么会直接抛出异常。  </p><p>再接下去的步骤可以看出其实跟上篇<code>inflate</code>方法类似：  </p><ol><li>通过调用<code>createViewFromTag</code>解析获取被<code>include</code>的 <code>topview</code></li><li>生成 <code>params</code>，这里要注意，<code>include</code>标签可能没有宽高，会导致生成失败，如果失败则接着又对被<code>include</code>的 topview 做操作。所以使用<code>include</code>的时候，<strong>不对它设置宽高是没有关系的</strong>。</li><li>调用<code>rInflateChildren</code>处理子View 之前已经分析过</li><li>把 <code>include</code> 标签的 <code>id</code> 以及 <code>visibility</code>属性 设置给 <code>topview</code>（如果有的话）</li><li><code>topView</code> 被直接 add 进 group，这样被 include 的 topView 就被加到布局里去了。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过阅读源码，其实 merge 以及 include 等标签处理其实并不难，而且它们的使用方法在源码中皆有体现。</p><p>稍微总结一下要点：</p><ol><li>使用 LayoutInflater 去 inflate merge 标签的时候，root 一定不能为 null，attachToRoot 也不能为 false  </li><li>merge标签在 XML 中<strong>必须是根元素</strong>  </li><li>与 merge 标签相反，include 绝对不能是根元素，必须需要在一个 ViewGroup 中使用  </li><li>使用 include 标签必须指定有效的 layout 属性  </li><li>使用 include 标签不写宽高是没有关系的（会去解析被 include 的 layout）  </li></ol><p>到这里<code>merge</code>以及<code>include</code>已经分析完毕。  </p><p>同时也看到了其他标签如<code>tag</code>、<code>requestFocus</code>的处理（很简单就不分析了），但是就是没看到<code>fragment</code>标签。</p><p>那究竟是在哪处理<code>fragment</code>标签的呢？  </p><p>下一篇为你揭晓答案。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="http://yifeiyuan.me/2016/07/12/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CoordinateLayout/">一步一步深入理解CoordinatorLayout</a><br><a href="http://yifeiyuan.me/2017/01/02/analyze-layoutinflater1-inflate/">LayoutInflater 源码分析（一）之 inflate 深度分析</a><br><a href="http://yifeiyuan.me/2017/01/03/analyze-layoutinflater2-include-and-merge/">LayoutInflater源码分析（二）之include以及merge标签的处理</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTFSC </tag>
            
            <tag> LayoutInflater </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LayoutInflater源码分析（一）inflate深度分析</title>
      <link href="/blog/84b877ff.html"/>
      <url>/blog/84b877ff.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><pre><code>public abstract class LayoutInflater</code></pre><p><code>LayoutInflater</code>,布局填充器，从名字就可以看出它用于加载布局。  </p><p>我们常用的方式大概如下：  </p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 方法定义：inflate(@LayoutRes int resource, @Nullable ViewGroup root, <span class="built_in">boolean</span> attachToRoot)</span><br><span class="line"><span class="keyword">View</span> <span class="keyword">view</span> = LayoutInflater.from(<span class="keyword">context</span>).inflate(R.layout.resource,root,flase);</span><br></pre></td></tr></table></figure><p>这样我们就可以把一个 XML 文件实例化成一个 View 来供我们使用。</p><p>PS：<code>LayoutInflater</code>的获取方式不止这一种，实际最终调用的都是 Context.getSystemService 方法，最终拿到的是<code>PhoneLayoutInflater</code>,有兴趣的同学可以去看看我的<a href="http://yifeiyuan.me/2017/01/01/analyze-context-getsystemservice/">Context.getSystemService分析</a>。  </p><a id="more"></a><p>上述代码我写过无数遍，但是心中一直有很多疑问：  </p><ul><li>上述方法中的<code>root</code>、<code>attachToRoot</code>究竟有什么作用？</li><li>它究竟是在哪里实例化View又是如何去实例化 View 的？</li><li>为什么系统的View我们在Xml里不需要写全路径，而自定义View却需要？</li><li>它又是如何处理<code>fragment</code>以及各种标签如<code>include</code>、<code>merge</code>的？</li><li><code>View</code>的<code>onFinishInflate</code>是否跟它有关呢？</li></ul><p>这一切都藏在源码里，所以深入源码一点点了解吧！  </p><h2 id="inflate深入解析"><a href="#inflate深入解析" class="headerlink" title="inflate深入解析"></a>inflate深入解析</h2><p>上面的例子中可以看到，我们调用的是<code>inflate(in resource, in root, in attachToRoot)</code>方法，所以首先分析一下该方法。  </p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">View <span class="title">inflate</span><span class="params">(@LayoutRes <span class="keyword">int</span> resource, @Nullable ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取rescources</span></span><br><span class="line">    <span class="keyword">final</span> Resources res = getContext().getResources();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"INFLATING from resource: \""</span> + res.getResourceName(resource) + <span class="string">"\" ("</span></span><br><span class="line">                + Integer.toHexString(resource) + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取parser　这里我不关心parse是怎么来的</span></span><br><span class="line">    <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用了另外一个inflate方法</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">inflate</span><span class="params">(parser, root, attachToRoot)</span></span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        parser.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码可以看到该方法主要是获取一个<code>XmlResourceParser</code>对象parser（这里不关心它是如何来的）。</p><p>不过需要提一下的这里解析XML采用的是 <strong>Pull</strong>方法(不知道的自行Google)。</p><p>然后调用了另外一个<code>inflate</code>方法，所以我们还需要继续跟踪<code>inflate(parser, root, attachToRoot)</code>才能进一步理解。 </p><p>上代码！  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> View inflate(XmlPullParser parser, @Nullable ViewGroup root, <span class="keyword">boolean</span> attachToRoot) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mConstructorArgs) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"inflate"</span>);</span><br><span class="line">        <span class="comment">// 一些赋值 后续会有用到</span></span><br><span class="line">        <span class="keyword">final</span> Context inflaterContext = mContext;</span><br><span class="line">        <span class="keyword">final</span> AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class="line">        Context lastContext = (Context) mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">        mConstructorArgs[<span class="number">0</span>] = inflaterContext;</span><br><span class="line">        <span class="comment">// 先把result赋值为我们传递的root</span></span><br><span class="line">        View result = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Look for the root node.</span></span><br><span class="line">            <span class="keyword">int</span> type;</span><br><span class="line">            <span class="keyword">while</span> ((type = parser.<span class="keyword">next</span>()) != XmlPullParser.START_TAG &amp;&amp;</span><br><span class="line">                    type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                <span class="comment">// Empty</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(parser.getPositionDescription()</span><br><span class="line">                        + <span class="string">": No start tag found!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取标签名字 比如FrameLayout</span></span><br><span class="line">            <span class="keyword">final</span> String name = parser.getName();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                System.out.<span class="keyword">println</span>(<span class="string">"**************************"</span>);</span><br><span class="line">                System.out.<span class="keyword">println</span>(<span class="string">"Creating root view: "</span></span><br><span class="line">                        + name);</span><br><span class="line">                System.out.<span class="keyword">println</span>(<span class="string">"**************************"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里的 TAG_MERGE 为 merge 看到了merge的身影</span></span><br><span class="line">            <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                <span class="comment">// 不知道merge怎么用？ 这个异常教你做人。</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;merge /&gt; can be used only with a valid "</span></span><br><span class="line">                            + <span class="string">"ViewGroup root and attachToRoot=true"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果为 merge 调用rInflate方法 后面再具体分析merge的情况</span></span><br><span class="line">                rInflate(parser, root, inflaterContext, attrs, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Temp is the root view that was found in the xml</span></span><br><span class="line">                <span class="comment">// 这里调用了一个createViewFromTag 从名字来看，就是用来创建View的！</span></span><br><span class="line">                <span class="comment">// 注意，这里的temp其实是我们xml里的top view,具体暂时先不管 先把整个流程看了</span></span><br><span class="line">                <span class="keyword">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line">                <span class="comment">//接下去处理LayoutParams</span></span><br><span class="line">                ViewGroup.LayoutParams params = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//如果我们传递进来的root不为null              </span></span><br><span class="line">                <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                        System.out.<span class="keyword">println</span>(<span class="string">"Creating params from root: "</span> +</span><br><span class="line">                                root);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Create layout params that match root, if supplied</span></span><br><span class="line">                    <span class="comment">// 那么调用 root的generateLayoutParams 来生成LayoutParamas</span></span><br><span class="line">                    params = root.generateLayoutParams(attrs);</span><br><span class="line">                    <span class="comment">//如果attachToRoot为false，那么就把刚生成的params赋值给View</span></span><br><span class="line">                    <span class="keyword">if</span> (!attachToRoot) &#123;</span><br><span class="line">                        <span class="comment">// Set the layout params for temp if we are not</span></span><br><span class="line">                        <span class="comment">// attaching. (If we are, we use addView, below)</span></span><br><span class="line">                        temp.setLayoutParams(params);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    System.out.<span class="keyword">println</span>(<span class="string">"-----&gt; start inflating children"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 源码的打印日志已经告诉我，这里是加载子View的~~ 后续再讲解</span></span><br><span class="line">                <span class="comment">// Inflate all children under temp against its context.</span></span><br><span class="line">                rInflateChildren(parser, temp, attrs, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    System.out.<span class="keyword">println</span>(<span class="string">"-----&gt; done inflating children"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// We are supposed to attach all the views we found (int temp)</span></span><br><span class="line">                <span class="comment">// to root. Do that now.</span></span><br><span class="line">                <span class="comment">// root不为null 并且 attachToRoot 则直接把temp添加到root里去</span></span><br><span class="line">                <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; attachToRoot) &#123;</span><br><span class="line">                    root.addView(temp, params);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Decide whether to return the root that was passed in or the</span></span><br><span class="line">                <span class="comment">// top view found in xml.</span></span><br><span class="line">                <span class="comment">// null或false 那么结果就是之前的top view了</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</span><br><span class="line">                    result = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">            InflateException ex = <span class="keyword">new</span> InflateException(e.getMessage());</span><br><span class="line">            ex.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            InflateException ex = <span class="keyword">new</span> InflateException(</span><br><span class="line">                    parser.getPositionDescription()</span><br><span class="line">                            + <span class="string">": "</span> + e.getMessage());</span><br><span class="line">            ex.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Don't retain static reference on context.</span></span><br><span class="line">            mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">            mConstructorArgs[<span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到该方法是重点了。  </p><p>这里出现了<code>merge</code>的踪迹，可以看到遇到<code>merge</code>标签，<strong>当root为null或者attachToRoot为false的时候，直接抛了异常！</strong><br>也可以看到如果是<code>merge</code>标签，走的是<code>rInflate</code>方法(不过这里暂时不分析<code>rInflate</code>方法)。</p><p>关键的是，我看到<code>inflate</code>方法处理了<code>root</code>与<code>attachToRoot</code>参数。</p><p>围绕<code>root</code>是否为<code>null</code>有两种处理分支：</p><p>第一种 当<code>root</code>不为<code>null</code>的时候：</p><ol><li>调用<code>root.generateLayoutParams</code>方法来生成<code>LayoutParamas</code>并赋值给<code>paramas</code></li><li>然后如果<code>attachToRoot</code>为<code>false</code>，则把<code>paramas</code>赋值给<code>createViewFromTag</code>解析出来的<code>temp</code>（XML里的根布局）</li><li>而如果<code>attachToRoot</code>为<code>true</code>的话，则会 调用<code>root.addView(temp, params);</code> <strong>直接把<code>temp</code>给加到<code>root</code>里去</strong>。如果我们自己再调用<code>addView</code>则会报错！</li></ol><p>这里再提一下<code>root</code> 对<code>topView</code>的<code>LayoutParamas</code>的影响：</p><p>需要先提一下 LayoutParamas 一般有3种来源：</p><ol><li>用户完全自定义 自己 <code>new</code> 出来</li><li>ViewGroup.generateLayoutParams 方法生成 上面已经提到</li><li>ViewGroup.generateDefaultLayoutParams 方法生成，在<code>addView</code>的时候 如果 <code>childView</code> 没有的话 LayoutParams 属性的话，会由这个方法生成。</li></ol><p>来看一下 addView 里对 paramas 的操作就明白了：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span>(<span class="params">View child</span>)</span> &#123;</span><br><span class="line">    addView(child, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span>(<span class="params">View child, <span class="keyword">int</span> index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot add a null child view to a ViewGroup"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LayoutParams <span class="keyword">params</span> = child.getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">params</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有 params 则调用 generateDefaultLayoutParams 去生成</span></span><br><span class="line">        <span class="keyword">params</span> = generateDefaultLayoutParams();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">params</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"generateDefaultLayoutParams() cannot return null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addView(child, index, <span class="keyword">params</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以当 root 不为 null 的时候，topview 的 paramas 是通过<code>generateLayoutParams</code>生成的。  </p><p>需要注意的是：<code>generateLayoutParams</code>与<code>generateDefaultLayoutParams</code>生成的 paramas 是不同的,会无视我们在 xml 里配置的属性，所以它会影响到布局效果。  </p><p>第二种 当<code>root</code>为<code>null</code>的时候：  </p><p>是<code>null</code>的时候会返回<code>temp</code> （XML里的根布局）</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// <span class="literal">null</span> 或是 <span class="literal">false</span> 那么<span class="attr">result=temp</span></span><br><span class="line"><span class="keyword">if</span> (<span class="attr">root</span> == <span class="literal">null</span> || !attachToRoot) &#123;</span><br><span class="line">    <span class="attr">result</span> = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以看到，<code>root==null</code>如果成立，那么<code>attachToRoot</code>也就没有用了。</p><p>所以<code>attachToRoot</code>只有在<code>root</code>不为 null 的时候才有效。  </p><p>大致总结成流程图如下所示：  </p><p><img src="http://ww4.sinaimg.cn/large/98900c07jw1f6ul65ibh3j20g40qeta0.jpg" alt="流程图"></p><p>搞清楚<code>root</code>以及<code>attachToRoot</code>参数的影响之后，来看View究竟是如何被创建的。  </p><p>进入<code>createViewFromTag</code>方法。</p><h2 id="createViewFromTag解析"><a href="#createViewFromTag解析" class="headerlink" title="createViewFromTag解析"></a>createViewFromTag解析</h2><p>上面提到的<code>createViewFromTag</code>方法如下：</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 提到了<span class="keyword">include</span>，除了<span class="keyword">include</span>，都会被使用</span><br><span class="line"> * <span class="type">Convenience</span> <span class="keyword">method</span> <span class="keyword">for</span> calling through to the five-arg createViewFromTag</span><br><span class="line"> * <span class="keyword">method</span>. <span class="type">This</span> <span class="keyword">method</span> passes &#123;@code <span class="literal">false</span>&#125; <span class="keyword">for</span> the &#123;@code ignoreThemeAttr&#125;</span><br><span class="line"> * argument <span class="keyword">and</span> should be used <span class="keyword">for</span> everything <span class="keyword">except</span> &#123;@code &amp;gt;<span class="keyword">include</span>&gt;&#125;</span><br><span class="line"> * tag parsing.</span><br><span class="line"> */</span><br><span class="line">private <span class="type">View</span> createViewFromTag(<span class="type">View</span> parent, <span class="type">String</span> name, <span class="type">Context</span> context, <span class="type">AttributeSet</span> attrs) &#123;</span><br><span class="line">    <span class="keyword">return</span> createViewFromTag(parent, name, context, attrs, <span class="literal">false</span>);//这里传了<span class="literal">false</span>进去</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，它又调用了另外一个重载函数，并从注释中我们可以看到了<code>include</code>的信息。</p><p>该方法把<code>ignoreThemeAttr</code>属性赋值为了<code>false</code>，继续跟下去。 </p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a view from a tag name using the supplied attribute set.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ignoreThemeAttr &#123;<span class="doctag">@code</span> true&#125; to ignore the &#123;<span class="doctag">@code</span> android:theme&#125;</span></span><br><span class="line"><span class="comment"> *                        attribute (if set) for the view being inflated,</span></span><br><span class="line"><span class="comment"> *                        &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">View createViewFromTag(View <span class="keyword">parent</span>, String name, Context context, AttributeSet attrs,</span><br><span class="line">        <span class="keyword">boolean</span> ignoreThemeAttr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.equals(<span class="string">"view"</span>)) &#123;</span><br><span class="line">        name = attrs.getAttributeValue(<span class="keyword">null</span>, <span class="string">"class"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply a theme wrapper, if allowed and one is specified.</span></span><br><span class="line">    <span class="comment">// 之前传递过来的为false</span></span><br><span class="line">    <span class="keyword">if</span> (!ignoreThemeAttr) &#123;</span><br><span class="line">        <span class="keyword">final</span> TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> themeResId = ta.getResourceId(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//如果设置了theme 那么context会被重新实例化为 ContextThemeWrapper</span></span><br><span class="line">        <span class="keyword">if</span> (themeResId != <span class="number">0</span>) &#123;</span><br><span class="line">            context = <span class="keyword">new</span> ContextThemeWrapper(context, themeResId);</span><br><span class="line">        &#125;</span><br><span class="line">        ta.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 彩蛋后续 分析</span></span><br><span class="line">    <span class="keyword">if</span> (name.equals(TAG_1995)) &#123;</span><br><span class="line">        <span class="comment">// Let's party like it's 1995!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlinkLayout(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里开始去创建View了</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        View view;</span><br><span class="line">        <span class="comment">//如果mFactory2不为null 那么mFactory2先解析</span></span><br><span class="line">        <span class="keyword">if</span> (mFactory2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            view = mFactory2.onCreateView(<span class="keyword">parent</span>, name, context, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 接着是 mFactory</span></span><br><span class="line">            view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            view = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 mFactory2 mFactory都返回null了 那么如果mPrivateFactory不为null，则交给它</span></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span> &amp;&amp; mPrivateFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            view = mPrivateFactory.onCreateView(<span class="keyword">parent</span>, name, context, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 那几个factory都返回null 即view还是null 那么继续</span></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Object lastContext = mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">            mConstructorArgs[<span class="number">0</span>] = context;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 有. 代表不是系统自带的View,比如TextView、me.yifeiyuan.XXXLayout</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">-1</span> == name.indexOf(<span class="string">'.'</span>)) &#123;</span><br><span class="line">                    view = onCreateView(<span class="keyword">parent</span>, name, attrs);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 系统自带的View</span></span><br><span class="line">                    view = createView(name, <span class="keyword">null</span>, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InflateException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">final</span> InflateException ie = <span class="keyword">new</span> InflateException(attrs.getPositionDescription()</span><br><span class="line">                + <span class="string">": Error inflating class "</span> + name);</span><br><span class="line">        ie.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ie;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> e) &#123;</span><br><span class="line">        <span class="keyword">final</span> InflateException ie = <span class="keyword">new</span> InflateException(attrs.getPositionDescription()</span><br><span class="line">                + <span class="string">": Error inflating class "</span> + name);</span><br><span class="line">        ie.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ie;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该<code>createViewFromTag</code>方法 先处理了主题属性，再走入创建View的流程。 </p><p>这里还涉及到了几个Factory，这其实是系统留给我们的Hook入口，我们可以人为的干涉系统创建View，可以添加更多功能，比如夜间模式。</p><p><code>Factory</code>相关的知识后续再讲。</p><p>另外，我们可以看到该方法依然没有涉及到创建View的具体实现，而是又会去调用<code>onCreateView</code>以及<code>createView</code>方法，这俩方法总应该是View创建的具体地方了吧？！！</p><h2 id="onCreateView-与-createView"><a href="#onCreateView-与-createView" class="headerlink" title="onCreateView 与 createView"></a>onCreateView 与 createView</h2><p>初步来看<code>onCreateView</code>方法负责创建自定义View，而<code>createView</code>方法负责创建系统自带的View。<br>但是感觉比较奇怪，因为不管是什么View，创建的套路应该是一样才对啊~<br>感觉有诈！</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> View onCreateView(String name, AttributeSet attrs)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">createView</span><span class="params">(name, <span class="string">"android.view."</span>, attrs)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咦！~ <code>onCreateView</code>调用了<code>createView</code>，到最后，其实都是调用<code>createView</code>方法啦！  </p><p>另外还传入了<code>android.view.</code>的一个参数，咦？这不是系统自带的View的包路径吗？  </p><p>继续深入<code>createView</code>。  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> final View createView(<span class="built_in">String</span> name, <span class="built_in">String</span> prefix, AttributeSet attrs)</span><br><span class="line">        throws ClassNotFoundException, InflateException &#123;</span><br><span class="line">    <span class="comment">// 构造方法缓存</span></span><br><span class="line">    Constructor&lt;? <span class="keyword">extends</span> View&gt; <span class="keyword">constructor</span> = sConstructorMap.get(<span class="params">name</span>);</span><br><span class="line">    Class&lt;? extends View&gt; clazz = null;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        <span class="comment">// Trace</span></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);</span><br><span class="line">        <span class="comment">//没有缓存 则去获取constructor 并存入缓存 注意这个缓存是静态的</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">constructor</span> == null) &#123;</span><br><span class="line">            <span class="comment">// Class not found in the cache, see if it's real, and try to add it</span></span><br><span class="line">            <span class="comment">// 注意 注意 注意 在这里把 View的全称拼全，并loadClass 难怪要传递android.View.进来啊~</span></span><br><span class="line">            clazz = mContext.getClassLoader().loadClass(</span><br><span class="line">                    prefix != <span class="literal">null</span> ? (prefix + name) : name).asSubclass(View.class);</span><br><span class="line">            <span class="comment">// 让 Filter 处理这个clazz能否被加载</span></span><br><span class="line">            <span class="keyword">if</span> (mFilter != <span class="literal">null</span> &amp;&amp; clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">boolean</span> allowed = mFilter.onLoadClass(clazz);</span><br><span class="line">                <span class="keyword">if</span> (!allowed) &#123;</span><br><span class="line">                    <span class="comment">// 如果不允许加载 则failNotAllowed会抛出异常！</span></span><br><span class="line">                    failNotAllowed(name, prefix, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 反射获取构造方法 并存入缓存</span></span><br><span class="line">            <span class="keyword">constructor</span> = clazz.getConstructor(<span class="params">mConstructorSignature</span>);</span><br><span class="line">            <span class="keyword">constructor</span>.setAccessible(<span class="params"><span class="literal">true</span></span>);</span><br><span class="line">            sConstructorMap.put(<span class="params">name, constructor</span>);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 如果有缓存 就走filter流程，并把结果存入缓存（非静态）</span><br><span class="line">            // If we have a filter, apply it to cached <span class="keyword">constructor</span></span><br><span class="line">            if (<span class="params">mFilter != <span class="literal">null</span></span>) &#123;</span><br><span class="line">                // Have we seen this name before?</span><br><span class="line">                Boolean allowedState = mFilterMap.get(<span class="params">name</span>);</span><br><span class="line">                if (<span class="params">allowedState == <span class="literal">null</span></span>) &#123;</span><br><span class="line">                    <span class="comment">// New class -- remember whether it is allowed</span></span><br><span class="line">                    clazz = mContext.getClassLoader().loadClass(</span><br><span class="line">                            prefix != <span class="literal">null</span> ? (prefix + name) : name).asSubclass(View.class);</span><br><span class="line">                    <span class="comment">// 获取allowed 并存入 缓存</span></span><br><span class="line">                    <span class="built_in">boolean</span> allowed = clazz != <span class="literal">null</span> &amp;&amp; mFilter.onLoadClass(clazz);</span><br><span class="line">                    mFilterMap.put(name, allowed);</span><br><span class="line">                    <span class="keyword">if</span> (!allowed) &#123;</span><br><span class="line">                        failNotAllowed(name, prefix, attrs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (allowedState.equals(<span class="built_in">Boolean</span>.FALSE)) &#123;</span><br><span class="line">                    failNotAllowed(name, prefix, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// mConstructorArgs存放了context 跟 args</span></span><br><span class="line">        <span class="built_in">Object</span>[] args = mConstructorArgs;</span><br><span class="line">        args[<span class="number">1</span>] = attrs;</span><br><span class="line">        <span class="comment">// 终于看到view实例化的地方了！！</span></span><br><span class="line">        final View view = <span class="keyword">constructor</span>.newInstance(<span class="params">args</span>);</span><br><span class="line">        // 如果是ViewStub 则设置LayoutInflater给它用 </span><br><span class="line">        if (<span class="params">view <span class="keyword">instanceof</span> ViewStub</span>) &#123;</span><br><span class="line">            <span class="comment">// Use the same context when inflating ViewStub later.</span></span><br><span class="line">            final ViewStub viewStub = (ViewStub) view;</span><br><span class="line">            viewStub.setLayoutInflater(cloneInContext((Context) args[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        InflateException ie = <span class="keyword">new</span> InflateException(attrs.getPositionDescription()</span><br><span class="line">                + <span class="string">": Error inflating class "</span></span><br><span class="line">                + (prefix != <span class="literal">null</span> ? (prefix + name) : name));</span><br><span class="line">        ie.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ie;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">        <span class="comment">// If loaded class is not a View subclass</span></span><br><span class="line">        InflateException ie = <span class="keyword">new</span> InflateException(attrs.getPositionDescription()</span><br><span class="line">                + <span class="string">": Class is not a View "</span></span><br><span class="line">                + (prefix != <span class="literal">null</span> ? (prefix + name) : name));</span><br><span class="line">        ie.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ie;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// If loadClass fails, we should propagate the exception.</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        InflateException ie = <span class="keyword">new</span> InflateException(attrs.getPositionDescription()</span><br><span class="line">                + <span class="string">": Error inflating class "</span></span><br><span class="line">                + (clazz == <span class="literal">null</span> ? <span class="string">"&lt;unknown&gt;"</span> : clazz.getName()));</span><br><span class="line">        ie.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ie;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调来调去，终于到真正实例化View的地方了。  </p><p>看到这方法的 <code>clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class)</code> 步骤会把系统自带的<code>View</code>的路径拼起来，把类加载进来；</p><p>然后<code>clazz.getConstructor(mConstructorSignature);</code>获取<code>View</code>的构造方法，最终通过反射<code>constructor.newInstance(args);</code>实例化View。  </p><p>如果你足够机智，你会发现这里出来一个问题，WebView 怎么办？</p><p>它的路径可是<code>android.webkit</code>啊~<br>其实这里涉及到 LayoutInflater 的一个子类<code>com.android.internal.policy.PhoneLayoutInflater</code>，它处理了<code>android.widget.</code>、<code>android.webkit.</code>、<code>android.app.</code>这些路径。  </p><p><strong>事实上，我们最开始使用<code>LayoutInflater.from(cxt)</code>获取的就是<code>PhoneLayoutInflater</code>的实例。</strong>  </p><p>另外这里又涉及到一个Hook入口，即<code>Filter</code>，但是我不知道它的使用场景。</p><p><code>createView</code>方法里解答了我 <em>View是哪里实例化的</em>以及<em>XML中系统View为什么不需要写全路径</em> 这两个疑问。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这一篇中分析了如下方法(省去了参数)：</p><ul><li><code>inflate</code>：LayoutInflater对外开放的入口，这里分析了 root与attachToRoot 参数的作用。</li><li><code>createViewFromTag</code>：处理主题属性与Factory的Hook</li><li><code>onCreateView</code>： 处理系统自带View的路径，<code>android.view.</code>，实际调用的还是<code>createView</code>方法</li><li><code>createView</code>：  真正实例化View的地方，通过View的路径去加载类并获取构造方法，通过反射获取View的实例。</li></ul><p>本篇解决了一些疑问：</p><ul><li>上述方法中的<code>root</code>、<code>attachToRoot</code>究竟有什么作用？<ul><li>影响了<code>merge</code>标签，</li><li>View是否直接被 add 到 root</li><li>View 的 LayoutParams 从何而来</li><li>inflate 方法的返回值</li></ul></li><li>为什么系统的View我们在Xml里不需要写全路径，而自定义View却需要？<ul><li>针对系统 View，会帮忙拼全路径,所以不需要写全</li></ul></li><li>它究竟是在哪里实例化View又是如何实例化 View 的？<ul><li>在  createView 方法中，默认利用反射实例化 View</li><li>也可通过 Factory hook 的方式实例化</li></ul></li></ul><p>但是还有好多疑问没有解决，也还有部分重要的方法没有解析，所以需要继续探索。  </p><p>篇幅太长了，所以先小结一下，换一篇继续。</p><p>下一篇着重分析<code>merge</code>、<code>include</code>等标签是如何处理的。</p><p>已经写好啦：<a href="http://yifeiyuan.me/2017/01/03/analyze-layoutinflater2-include-and-merge/">LayoutInflater源码分析（二）之include以及merge标签的处理</a></p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="http://yifeiyuan.me/2016/07/12/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CoordinateLayout/">一步一步深入理解CoordinatorLayout</a><br><a href="http://yifeiyuan.me/2016/12/27/deep-into-viewstub/">ViewStub是如何实现懒加载的</a><br><a href="http://yifeiyuan.me/2016/12/29/analyze-space/">Space源码分析</a><br><a href="http://yifeiyuan.me/2017/01/03/analyze-layoutinflater2-include-and-merge/">LayoutInflater源码分析（二）之include以及merge标签的处理</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTFSC </tag>
            
            <tag> LayoutInflater </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Context.getSystemService分析</title>
      <link href="/blog/6bfbac5c.html"/>
      <url>/blog/6bfbac5c.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Context.getSystemService(String) 方法是我们用来获取各种系统服务的手段，比如：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflater LayoutInflater = (LayoutInflater) <span class="built_in">context</span>.getSystemService(<span class="built_in">Context</span>.LAYOUT_INFLATER_SERVICE)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">ActivityManager am = (ActivityManager) cxt.getSystemService(<span class="built_in">Context</span>.ACTIVITY_SERVICE)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>BONUS：像这样传入不同的参数(或 String 或 int)，返回不同的对象，通常称为『工厂方法』。</p><p>那么问题来了：<strong>这些服务是从哪里来的呢？</strong></p><p>在<a href="where-is-app&#39;s-entrance.md">Android应用的程序入口是哪里？</a>一文中我们知道了，我们App的 Context 的实例实际是 ContextImpl的实例，所以需要去它那边研究。 </p><p>接下去分析。</p><a id="more"></a><h2 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h2><p>看看 ContextImpl 的 getSystemService：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> SystemServiceRegistry.<span class="title">getSystemService</span><span class="params">(<span class="keyword">this</span>, name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现调用了 SystemServiceRegistry.getSystemService：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SystemServiceRegistry</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">Object</span> getSystemService(ContextImpl ctx, <span class="keyword">String</span> name) &#123;</span><br><span class="line">    ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.<span class="built_in">get</span>(name);</span><br><span class="line">    <span class="keyword">return</span> fetcher != <span class="keyword">null</span> ? fetcher.getService(ctx) : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SystemServiceRegistry 是什么？ServiceFetcher又是什么？ </p><p>当切换到一个新的不熟悉的类的时候，先不要着急，先看看这个类的介绍、结构与方法等，先大致了解一下，再继续深入研究。</p><h3 id="SystemServiceRegistry"><a href="#SystemServiceRegistry" class="headerlink" title="SystemServiceRegistry"></a>SystemServiceRegistry</h3><p>来看看 SystemServiceRegistry 的定义以及我画的类图:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Manages all of the system services that can be returned by &#123;<span class="doctag">@link</span> Context#getSystemService&#125;.</span></span><br><span class="line"><span class="comment"> * Used by &#123;<span class="doctag">@link</span> ContextImpl&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemServiceRegistry</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ww4.sinaimg.cn/large/98900c07gw1fbdqowwyyuj20ty0l8mz9.jpg" width="539" height="382"></p><p>可以清楚的看到，SystemServiceRegistry 是『用来管理所有 ContextImpl.getSystemService 所返回的系统服务』的； ServiceFetcher 则是一个泛型接口。</p><p>那么是如何管理的呢？</p><h4 id="系统服务的注册"><a href="#系统服务的注册" class="headerlink" title="系统服务的注册"></a>系统服务的注册</h4><p>在 SystemServiceRegistry 中有一个<code>static</code>块，代码是这样的：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</span><br><span class="line">        <span class="keyword">new</span> CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">LayoutInflater <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PhoneLayoutInflater(ctx.getOuterContext());</span><br><span class="line">    &#125;&#125;);</span><br><span class="line"></span><br><span class="line">    registerService(Context.ALARM_SERVICE, AlarmManager.class,</span><br><span class="line">            <span class="keyword">new</span> CachedServiceFetcher&lt;AlarmManager&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">AlarmManager <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">        IBinder b = ServiceManager.getService(Context.ALARM_SERVICE);</span><br><span class="line">        IAlarmManager service = IAlarmManager.Stub.asInterface(b);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AlarmManager(service, ctx);</span><br><span class="line">    &#125;&#125;);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我挑了两个例子展示，省略了其他的系统服务注册代码，因为实际上，生成系统服务，就这两种方式：</p><ol><li>一种是 直接实例化对象，如<code>PhoneLayoutInflater</code>是直接<code>new</code>出来的。  </li><li>另外一种是从<code>ServiceManager.getService(String)</code>获取的。</li></ol><p>PS：ServiceManager 涉及到了 ServiceManagerNative、Binder、Binder 驱动等相关知识，非常复杂，这里不展开去研究，以后会有机会讲。</p><p><strong>原来是在 static 代码块里注册了所有的系统服务</strong>。</p><h4 id="系统服务的缓存实现"><a href="#系统服务的缓存实现" class="headerlink" title="系统服务的缓存实现"></a>系统服务的缓存实现</h4><p>像这种系统服务一般都是大对象，单例，不可能每次获取都是去新建。</p><p>所以当然会有缓存啦。</p><p>这个缓存在 ContextImpl 中</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">Object</span>[] mServiceCache = SystemServiceRegistry.createServiceCache();</span><br></pre></td></tr></table></figure><p>至于存入缓存的时机，需要看一个 ServiceFetcher 的实现（其他几个原理类似）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SystemServiceRegistry</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedServiceFetcher</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ServiceFetcher</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mCacheIndex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CachedServiceFetcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mCacheIndex = sServiceCacheSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">getService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取缓存</span></span><br><span class="line">        <span class="keyword">final</span> Object[] cache = ctx.mServiceCache;</span><br><span class="line">        <span class="keyword">synchronized</span> (cache) &#123;</span><br><span class="line">            <span class="comment">// Fetch or create the service.</span></span><br><span class="line">            Object service = cache[mCacheIndex];</span><br><span class="line">            <span class="comment">// 如果缓存里没有 则调用 createService 去生成。</span></span><br><span class="line">            <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">                service = createService(ctx);</span><br><span class="line">                cache[mCacheIndex] = service;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (T)service;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">createService</span><span class="params">(ContextImpl ctx)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceFetcher.getService 被调用的时候会去判断是否有缓存，如果没有再调用 createService 去创建，再放入缓存，很简单的逻辑。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们 <code>Context.getSystemService</code> 获取到的系统服务其实从 SystemServiceRegistry 来，它负责注册以及管理系统服务。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="http://yifeiyuan.me/2016/07/12/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CoordinateLayout/">一步一步深入理解CoordinatorLayout</a><br><a href="http://yifeiyuan.me/2016/12/27/deep-into-viewstub/">ViewStub是如何实现懒加载的</a><br><a href="http://yifeiyuan.me/2017/01/02/analyze-layoutinflater1-inflate/">LayoutInflater源码分析（一）之inflate深度分析</a><br><a href="http://yifeiyuan.me/2017/01/03/analyze-layoutinflater2-include-and-merge/">LayoutInflater源码分析（二）之include以及merge标签的处理</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTFSC </tag>
            
            <tag> Context </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Space源码分析</title>
      <link href="/blog/ab725a54.html"/>
      <url>/blog/ab725a54.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><pre><code>public final class Space extends View</code></pre><p>Space是一个轻量的View，可以在布局中被用来创建间隙,常用于布局优化。</p><p>介于可能很多人根本不知道Space的存在！所以稍微提一下它的使用场景，比如以下场景的右侧小三角，就可以使用Space：  </p><p><img src="http://ww2.sinaimg.cn/large/98900c07jw1f6pifwudkgj201k0110mp.jpg" alt="Space使用场景"></p><p>在两个三角之间放置一个<code>Space</code>，两三角分别位于它的上下，控制它的高度就能控制三角之间的间隔。</p><a id="more"></a><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignParentRight</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginRight</span>=<span class="string">"2dp"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/iv_price_up"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_above</span>=<span class="string">"@+id/divider"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"@drawable/price_up"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">"1dp"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Space</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"1dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/divider"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerInParent</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/iv_price_down"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">"1dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">"@+id/divider"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"@drawable/price_down"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="构造方法分析"><a href="#构造方法分析" class="headerlink" title="构造方法分析"></a>构造方法分析</h2><p>看第一个构造方法即可。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最终都会调用这个构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Space</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">    <span class="comment">// 如果是VISIBLE 则改为 INVISIBLE</span></span><br><span class="line">    <span class="keyword">if</span> (getVisibility() == VISIBLE) &#123;</span><br><span class="line">        setVisibility(INVISIBLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Space</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, defStyleAttr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Space</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Space</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//noinspection NullableProblems</span></span><br><span class="line">    <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟ViewStub类似，Space在构造方法里做了一些操作：<strong>当可见性为VISIBLE的时候，把它改为INVISIBLE了</strong>。</p><p>由于Space方法非常少，接下去直接都分析了。  </p><h2 id="其余方法分析"><a href="#其余方法分析" class="headerlink" title="其余方法分析"></a>其余方法分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Draw nothing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> canvas an unused parameter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line"><span class="comment">//空方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Compare to: &#123;<span class="doctag">@link</span> View#getDefaultSize(int, int)&#125;</span></span><br><span class="line"><span class="comment"> * If mode is AT_MOST, return the child size instead of the parent size</span></span><br><span class="line"><span class="comment"> * (unless it is too big).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize2</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = size;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">            result = size;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST: <span class="comment">//wrap_content 返回更小的值</span></span><br><span class="line">            result = Math.min(size, specSize);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            result = specSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line"><span class="comment">// getSuggestedMinimumWidth() 根据minWidth以及背景的宽度来返回</span></span><br><span class="line">    setMeasuredDimension(</span><br><span class="line">            getDefaultSize2(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize2(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Space跟ViewStub一个套路，<code>draw()</code>都为空方法，然后重写<code>onMeasure</code>，相比ViewStub，Space代码更加比较简单。</p><p>另外一般我们使用Space都是会指定宽高，大部分走的是 EXACTLY的流程。  </p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol start="0"><li>Space 用来做间隙非常有用</li><li>Space 默认为不可见（invisible），但是有宽高，会占据空间。</li><li>布局文件中设置 VISIBLE 无效。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>ViewStub跟Space作为Android布局优化的常用手段，有着一些同样的思路值得我们去学习：</p><ul><li>不绘制(减少overDraw)  </li><li>优化或者不参与测量与布局（提高整体布局的渲染速度） </li></ul><p>总结来讲，Space 是一个不绘制任何东西，默认为<code>INVISIBLE</code>的 View，可以用来在布局中占空间，作布局优化。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="http://yifeiyuan.me/2016/07/12/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CoordinateLayout/">一步一步深入理解CoordinatorLayout</a><br><a href="http://yifeiyuan.me/2016/12/27/deep-into-viewstub/">ViewStub是如何实现懒加载的</a><br><a href="http://yifeiyuan.me/2016/12/29/analyze-space/">Space源码分析</a><br><a href="http://yifeiyuan.me/2017/01/02/analyze-layoutinflater1-inflate/">LayoutInflater源码分析（一）之inflate深度分析</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTFSC </tag>
            
            <tag> Space </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ViewStub是如何实现懒加载的</title>
      <link href="/blog/301ae671.html"/>
      <url>/blog/301ae671.html</url>
      
        <content type="html"><![CDATA[<h2 id="ViewStub简介"><a href="#ViewStub简介" class="headerlink" title="ViewStub简介"></a>ViewStub简介</h2><pre><code>public final class ViewStub extends View </code></pre><p>  ViewStub 是一个宽高都为0，不可见的(GONE)，不参与measure与layout(绝大部分情况)，不绘制任何东西，可以用来做<strong>懒加载的View</strong>,常用于布局优化；  </p><p>PS: 为什么说绝大部分情况不参与测量与布局呢？因为大部分ViewGroup对于GONE的View，都不会让它参与测量与布局流程（自定义的就不一定了，另外可以看一下FrameLayout的源码）。</p><p>首先需要说的是，本文涉及到两个角色，一个是 ViewStub本身，另外一个是被用来做懒加载的View，是ViewStub的作用对象，称之为『StubbedView』（本文用此称呼来替代）。  </p><p>那么 ViewStub 是怎么实现懒加载的呢？</p><p>本文通过ViewStub源码来分析。</p><a id="more"></a><h2 id="ViewStub的简单使用教程"><a href="#ViewStub的简单使用教程" class="headerlink" title="ViewStub的简单使用教程"></a>ViewStub的简单使用教程</h2><p><code>ViewStub</code> 的使用非常非常简单，只需要两步~  </p><p>Step 1. 在XML里配置使用：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ViewStub</span><br><span class="line">android:id=<span class="string">"@+id/stub"</span>  <span class="comment">// 这个id是ViewStub的id</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">    android:<span class="keyword">layout</span>=<span class="string">"@layout/mySubTree"</span> <span class="comment">//StubbedView的资源id（跟include一样）</span></span><br><span class="line">    android:visibility=<span class="string">"gone"</span></span><br><span class="line">    android:inflatedId=<span class="string">"@+id/subTree"</span> <span class="comment">// StubbedView的id</span></span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure><p>Step 2. 调用ViewStub的<code>inflate</code></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ViewStub stub = (ViewStub)findViewById(R.id.stub);</span><br><span class="line">View stubbedView = stub.inflate();<span class="comment">//后面分析</span></span><br><span class="line"><span class="comment">//...初始化StubbedView</span></span><br></pre></td></tr></table></figure><p>非常简单的两步，就能做到View的懒加载，非常方便，其原因是什么呢？  </p><p>接下去深入源码分析一下。  </p><h2 id="构造方法分析"><a href="#构造方法分析" class="headerlink" title="构造方法分析"></a>构造方法分析</h2><p>首先分析一下构造方法，了解一下它是如何创建的。  </p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewStub</span><span class="params">(Context context, @LayoutRes <span class="keyword">int</span> layoutResource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// StubbedView的资源id</span></span><br><span class="line">    mLayoutResource = layoutResource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewStub</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewStub</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, defStyleAttr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewStub</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> TypedArray a = context.obtainStyledAttributes(attrs,</span><br><span class="line">            R.styleable.ViewStub, defStyleAttr, defStyleRes);</span><br><span class="line">    <span class="comment">// mInflatedId 存储StubbedView的id</span></span><br><span class="line">    mInflatedId = a.getResourceId(R.styleable.ViewStub_inflatedId, NO_ID);</span><br><span class="line">    <span class="comment">// mLayoutResource 为StubbedView的resourceId</span></span><br><span class="line">    mLayoutResource = a.getResourceId(R.styleable.ViewStub_layout, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// viewStub 自己的id</span></span><br><span class="line">    mID = a.getResourceId(R.styleable.ViewStub_id, NO_ID);</span><br><span class="line">    a.recycle();</span><br><span class="line">    <span class="comment">// 设置为不可见 </span></span><br><span class="line">    setVisibility(GONE);</span><br><span class="line">    <span class="comment">// 不绘制本身</span></span><br><span class="line">    setWillNotDraw(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ViewStub</code>在构造方法里不仅仅获取赋值属性，比较关键的是，还 默认将ViewStub自己设置为不可见（跳过onMeasure与onLayout），不绘制。</p><p>这里有一个要点：<strong>在XML里配置ViewStub的可见性是没有用的</strong>。    </p><h2 id="测量-与-绘制"><a href="#测量-与-绘制" class="headerlink" title="测量 与 绘制"></a>测量 与 绘制</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Override</span></span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line"><span class="comment">// 写死的宽高为0</span></span><br><span class="line">    <span class="selector-tag">setMeasuredDimension</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">Override</span></span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">draw</span>(Canvas canvas) &#123;</span><br><span class="line"><span class="comment">//空方法，不draw任何东西</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Override</span></span><br><span class="line">protected void dispatchDraw(Canvas canvas) &#123;</span><br><span class="line"><span class="comment">//空方法，不draw任何东西</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="inflate-方法分析"><a href="#inflate-方法分析" class="headerlink" title="inflate()方法分析"></a>inflate()方法分析</h2><p>之前在简单教程里有提到 <code>inflate</code>方法，它是<code>ViewStub</code>实现懒加载的最为关键的方法，接下去去分析一下。  </p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 StubbedView</span></span><br><span class="line"><span class="keyword">public</span> View inflate() &#123;</span><br><span class="line"><span class="comment">// 尝试去获取 viewParent 第一次调用的时候不为null，而后则为null</span></span><br><span class="line">    <span class="keyword">final</span> ViewParent viewParent = getParent();</span><br><span class="line">    <span class="comment">// 当 viewParent 不为null的时候</span></span><br><span class="line">    <span class="keyword">if</span> (viewParent != <span class="keyword">null</span> &amp;&amp; viewParent <span class="keyword">instanceof</span> ViewGroup) &#123;</span><br><span class="line">    <span class="comment">// 我们在xml里配置的layout的资源id 如果id无效，则会报错</span></span><br><span class="line">        <span class="keyword">if</span> (mLayoutResource != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ViewGroup <span class="keyword">parent</span> = (ViewGroup) viewParent;</span><br><span class="line">            <span class="comment">// 实例化 LayoutInflater</span></span><br><span class="line">            <span class="keyword">final</span> LayoutInflater factory;</span><br><span class="line">            <span class="keyword">if</span> (mInflater != <span class="keyword">null</span>) &#123;</span><br><span class="line">                factory = mInflater;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                factory = LayoutInflater.from(mContext);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// inflate，StubbedView在这里被实例化</span></span><br><span class="line">            <span class="keyword">final</span> View view = factory.inflate(mLayoutResource, <span class="keyword">parent</span>,</span><br><span class="line">                    <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 可以看到，这里如果我们在XML里写了inflateId，则会设置给StubbedView</span></span><br><span class="line">            <span class="keyword">if</span> (mInflatedId != NO_ID) &#123;</span><br><span class="line">                view.setId(mInflatedId);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意：这两步步 ViewSutb 找到自己的位置，并从父View中移除了自己</span></span><br><span class="line">            <span class="comment">// 这会导致 以后调用inflate的时候 再也获取不到 viewParent了</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = <span class="keyword">parent</span>.indexOfChild(this);</span><br><span class="line">            <span class="keyword">parent</span>.removeViewInLayout(this);</span><br><span class="line">            <span class="comment">// 拿出ViewStub的LayoutParamas，不为null 则会赋值给 StubbedView</span></span><br><span class="line">            <span class="keyword">final</span> ViewGroup.LayoutParams layoutParams = getLayoutParams();</span><br><span class="line">            <span class="comment">// 把 StubbedView 添加到ViewStub的父View里</span></span><br><span class="line">            <span class="keyword">if</span> (layoutParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">parent</span>.addView(view, index, layoutParams);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">parent</span>.addView(view, index);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//使用一个弱引用来保存StubbedView</span></span><br><span class="line">            mInflatedViewRef = <span class="keyword">new</span> WeakReference&lt;View&gt;(view);</span><br><span class="line">            <span class="comment">//回调listener</span></span><br><span class="line">            <span class="keyword">if</span> (mInflateListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mInflateListener.onInflate(this, view);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回 StubbedView</span></span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// id无效，则throw一个 IllegalArgumentException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"ViewStub must have a valid layoutResource"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// inflate被调用一次后 就没有了ViewParent，就会报这个错</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"ViewStub must have a non-null ViewGroup viewParent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在每行代码上都加上了详细的注释，主要的操作就是把StubbedView给Inflate出来，然后把它放到自己的位置，代码非常清晰，非常简单。  </p><p>总结来说，其实<code>inflate</code>方法是做了一个『偷梁换柱』的操作，把 <code>StubbedView</code>动态的添加到自己原来的位置上，也因此实现了懒加载功能。  </p><p>这里还需要注意的是 <strong>ViewStub 必须要有一个 Parent，即必须要有父视图！</strong>（谢谢 JangGwa 的提醒）</p><p>另外值得一提的是：ViewStub还重写了View的<code>setVisibility</code>方法，让我们来分析一下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setVisibility</span><span class="params">(<span class="keyword">int</span> visibility)</span> </span>&#123;</span><br><span class="line"><span class="comment">// mInflatedViewRef 保存了 StubbedView还记得吗？ inflate过后它就不是null了 </span></span><br><span class="line">    <span class="keyword">if</span> (mInflatedViewRef != <span class="keyword">null</span>) &#123;</span><br><span class="line">        View view = mInflatedViewRef.get();</span><br><span class="line">        <span class="comment">// 操作 StubbedView</span></span><br><span class="line">        <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">            view.setVisibility(visibility);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"setVisibility called on un-referenced view"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 操作ViewStub自己，构造方法里的GONE记得么？</span></span><br><span class="line">        <span class="keyword">super</span>.setVisibility(visibility);</span><br><span class="line">        <span class="comment">// 如果是 VISIBLE INVISIBLE 则会去调用 inflate方法！！！！</span></span><br><span class="line">        <span class="keyword">if</span> (visibility == VISIBLE || visibility == INVISIBLE) &#123;</span><br><span class="line">            inflate();<span class="comment">//注意这一行代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>setVisibility</code>方法中也可能会调用<code>inflate()</code>方法，所以当我们想让StubbedView被加载进来，而我们不需要StubbedView的实例的时候，可以用<code>setVisibility（View.VISIBLE）</code>。</p><p>不过需要注意的是 不要再接着调用<code>inflate</code>方法，因为此时的 ViewStub 已经被移除了！  </p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol start="0"><li>使用ViewStub，必须指定layoutResourceId(必须是布局文件)</li><li>在XML里配置ViewStub的可见性是没有用的  </li><li>ViewStub 主要原理藏在<code>inflate()</code>方法中，是它把真正要加载的View给加载了进来  </li><li><code>inflate()</code>方法只能调用一次</li><li>ViewStub调用<code>inflate()</code>后就不要再用它了（让它功成身退！）</li><li>要小心<code>setVisibility</code>方法，因为它可能会调用<code>inflate()</code></li><li>在XML里给ViewStub设置的LayoutParamas(宽高margin等)会传递给StubbedView,所以我们如果要控制StubbedView的LayoutParamas，则需要写在ViewStub里而不是StubbedView！  </li><li>期待补充！  </li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>源码分析完毕，可以看到，ViewStub的源码还是非常简单的。</p><p>总结来说，它为需要被懒加载的View在布局中占了一个坑，当需要加载时把自己占的坑让给了被加载的 View ，从而实现了懒加载。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="http://yifeiyuan.me/2016/07/12/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CoordinateLayout/">一步一步深入理解CoordinatorLayout</a><br><a href="http://yifeiyuan.me/2017/01/02/analyze-layoutinflater1-inflate/">LayoutInflater源码分析（一）之inflate深度分析</a><br><a href="http://yifeiyuan.me/2017/01/03/analyze-layoutinflater2-include-and-merge/">LayoutInflater源码分析（二）之include以及merge标签的处理</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTFSC </tag>
            
            <tag> ViewStub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Retrofit是如何工作的？</title>
      <link href="/blog/9664f024.html"/>
      <url>/blog/9664f024.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：本文基于 Retrofit2.0版本，并配合 RxJava 来分析。<br>com.squareup.retrofit2:retrofit:2.0.0<br>com.squareup.retrofit2:converter-gson:2.0.0<br>com.squareup.retrofit2:adapter-rxjava:2.0.0</p></blockquote><p>​    </p><p>​    <a href="https://square.github.io/retrofit/" target="_blank" rel="noopener">Retrofit</a> adapts a Java interface to HTTP calls by using annotations on the declared     methods to how requests are made.</p><p>本文主要通过分析 <strong>Retrofit 与 RxJava 的合作流程</strong> 来深入理解 Retrofit的工作原理，并且解答自己心中的疑惑。</p><a id="more"></a><h4 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h4><ol><li>我们调用接口的方法后是怎么发送请求的？这背后发生了什么？</li><li>Retrofit 与 OkHttp 是怎么合作的？</li><li>Retrofit 中的数据究竟是怎么处理的？它是怎么返回  RxJava.Observable 的？</li></ol><h2 id="Retrofit-的基本使用"><a href="#Retrofit-的基本使用" class="headerlink" title="Retrofit 的基本使用"></a>Retrofit 的基本使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApiService</span></span>&#123;</span><br><span class="line">  <span class="meta">@GET</span>(<span class="string">"data/Android/"</span>+ GankConfig.PAGE_COUNT+<span class="string">"/&#123;page&#125;"</span>)</span><br><span class="line">    <span class="function">Observable&lt;GankResponse&gt; <span class="title">getAndroid</span><span class="params">(@Path(<span class="string">"page"</span>)</span> <span class="keyword">int</span> page)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Builder 模式来构建 retrofit</span></span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                .baseUrl(baseUrl)</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create(<span class="keyword">new</span> GsonBuilder().create()))</span><br><span class="line">                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</span><br><span class="line">                .client(okHttpClient)</span><br><span class="line">                .build();</span><br><span class="line"><span class="comment">// 通过 retrofit.create 方法来生成 service(非四大组件中的 Service)</span></span><br><span class="line">ApiService service = retrofit.create(ApiService.class);</span><br><span class="line"><span class="comment">// 发起请求 获取数据</span></span><br><span class="line">Observable&lt;GankResponse&gt; observable= service.getAndroid(<span class="number">1</span>);</span><br><span class="line">observable....</span><br></pre></td></tr></table></figure><p>Retrofit 就这样经过简单的配置后就可以向服务器请求数据了，超级简单。</p><h2 id="Retrofit-create-方法分析"><a href="#Retrofit-create-方法分析" class="headerlink" title="Retrofit.create 方法分析"></a>Retrofit.create 方法分析</h2><p>Retrofit的<code>create</code>方法作为 Retrofit 的入口，当然得第一个分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//验证接口是否合理</span></span><br><span class="line">  Utils.validateServiceInterface(service);</span><br><span class="line">  <span class="comment">//默认 false</span></span><br><span class="line">  <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">    eagerlyValidateMethods(service);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 动态代理</span></span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">      <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="comment">// 平台的抽象,指定默认的 CallbackExecutor CallAdapterFactory用，这里 Android 平台是 Android (Java8 iOS 咱不管)</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">  <span class="comment">//ApiService 中的方法调用都会走到这里</span></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">          <span class="comment">// 注释已经说明 Object 的方法不管</span></span><br><span class="line">          <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// java8 的默认方法，Android暂不支持默认方法，所以暂时也不需要管</span></span><br><span class="line">          <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 重点了 后面分析</span></span><br><span class="line">          <span class="comment">// 为 Method 生成一个 ServiceMethod</span></span><br><span class="line">          ServiceMethod serviceMethod = loadServiceMethod(method);</span><br><span class="line">          <span class="comment">// 再包装成 OkHttpCall</span></span><br><span class="line">          OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);      <span class="comment">// 请求</span></span><br><span class="line">          <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中可以看到，Retrofit 的主要原理是利用了 Java 的<strong>动态代理技术</strong>，把 ApiService 的方法调用集中到了<code>InvocationHandler.invoke</code>,再构建了ServiceMethod ,OKHttpCall，返回 <code>callAdapter.adapt</code> 的结果。</p><p>要弄清楚，还需要分析那最后三行代码。</p><p>一步一步来。</p><h2 id="ServiceMethod的职责以及-loadServiceMethod分析"><a href="#ServiceMethod的职责以及-loadServiceMethod分析" class="headerlink" title="ServiceMethod的职责以及 loadServiceMethod分析"></a>ServiceMethod的职责以及 loadServiceMethod分析</h2><p>我认为 ServiceMethod 是接口<strong>具体方法的抽象</strong>，它主要负责解析它对应的 <code>method</code> 的各种参数（它有各种如 <code>parseHeaders</code> 的方法），比如注解（@Get），入参，另外还负责获取 callAdapter,responseConverter等Retrofit配置，好为后面的<code>okhttp3.Request</code>做好参数准备，它的<code>toRequest</code>为 OkHttp 提供 Request，可以说它承载了后续 Http 请求所需的一切参数。</p><p>再分析<code>loadServiceMethod</code>，比较简单。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serviceMethodCache 的定义</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ServiceMethod&gt; serviceMethodCache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"> <span class="comment">// 获取method对应的 ServiceMethod</span></span><br><span class="line"> <span class="function">ServiceMethod <span class="title">loadServiceMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    ServiceMethod result;</span><br><span class="line">    <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">      <span class="comment">// 先从缓存去获取</span></span><br><span class="line">      result = serviceMethodCache.get(method);</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//缓存中没有 则新建，并存入缓存</span></span><br><span class="line">        result = <span class="keyword">new</span> ServiceMethod.Builder(<span class="keyword">this</span>, method).build();</span><br><span class="line">        serviceMethodCache.put(method, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>loadServiceMethod</code>方法，负责 为 <code>method</code> 生成一个 ServiceMethod ，并且给 ServiceMethod 做了缓存。</p><p>动态代理是有一定的性能损耗的，并且ServiceMethod 的创建伴随着各种注解参数解析，这也是耗时间的，在加上一个 App 调用接口是非常频繁的，如果每次接口请求都需要重新生成那么有浪费资源损害性能的可能，所以这里做了一份缓存来提高效率。</p><h2 id="OkHttpCall"><a href="#OkHttpCall" class="headerlink" title="OkHttpCall"></a>OkHttpCall</h2><p>再接下去往后看<code>OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</code>，是再为 ServiceMethod 以及 args(参数)生成了一个 <code>OkHttpCall</code>。</p><p>从 <code>OkHttpCall</code> 这个名字来看就能猜到，它是对 <code>OkHttp3.Call</code> 的组合包装,事实上，它也确实是。(<code>OkHttpCall</code>中有一个成员<code>okhttp3.Call rawCall</code>)。</p><h2 id="callAdapter-adapt流程分析"><a href="#callAdapter-adapt流程分析" class="headerlink" title="callAdapter.adapt流程分析"></a>callAdapter.adapt流程分析</h2><p>最后<code>return serviceMethod.callAdapter.adapt(okHttpCall)</code> 似乎是走到了最后一步。</p><p>如果说前面的都是准备的话，那么到这里就是真的要行动了。</p><p>来分析一下，这里涉及到的 <code>callAdapter</code>,是由我们配置 Retrofit 的 <code>addCallAdapterFactory</code>方法中传入的<code>RxJavaCallAdapterFactory.create()</code>生成，实例为<code>RxJavaCallAdapterFactory</code>。</p><p>实例的生成大致流程为：  </p><p>ServiceMethod.Bulider.Build()</p><p> -&gt;ServiceMethod.createCallAdapter()</p><p>  -&gt;retrofit.callAdapter()</p><p>   -&gt;adapterFactories遍历</p><p>​     -&gt;最终到RxJavaCallAdapterFactory.get()#getCallAdapter()</p><p>​       -&gt;return <code>return new SimpleCallAdapter(observableType, scheduler);</code></p><p>由于使用了 RxJava ，我们最终得到的 <code>callAdapter</code> 为 <code>SimpleCallAdapter</code>，所以接下去分析<code>SimpleCallAdapter</code>的 <code>adapt</code> 方法：</p><p>这里涉及到的 <code>CallOnSubscriber</code> 后面有给出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的 call 是 OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args) 生成的 okHttpCall</span></span><br><span class="line">    Observable&lt;R&gt; observable = Observable.create(<span class="keyword">new</span> CallOnSubscribe&lt;&gt;(call)) <span class="comment">//</span></span><br><span class="line">        .flatMap(<span class="keyword">new</span> Func1&lt;Response&lt;R&gt;, Observable&lt;R&gt;&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">(Response&lt;R&gt; response)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (response.isSuccessful()) &#123;</span><br><span class="line">              <span class="keyword">return</span> Observable.just(response.body());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> HttpException(response));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">if</span> (scheduler != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> observable.subscribeOn(scheduler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> observable;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallOnSubscribe</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Observable</span>.<span class="title">OnSubscribe</span>&lt;<span class="title">Response</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Call&lt;T&gt; originalCall;</span><br><span class="line"></span><br><span class="line">  CallOnSubscribe(Call&lt;T&gt; originalCall) &#123;</span><br><span class="line">    <span class="keyword">this</span>.originalCall = originalCall;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> Response&lt;T&gt;&gt; subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Since Call is a one-shot type, clone it for each new subscriber.</span></span><br><span class="line">    <span class="keyword">final</span> Call&lt;T&gt; call = originalCall.clone();</span><br><span class="line">    <span class="comment">// Attempt to cancel the call if it is still in-flight on unsubscription.</span></span><br><span class="line">    <span class="comment">// 当我们取消订阅的时候 会取消请求 棒棒哒</span></span><br><span class="line">    subscriber.add(Subscriptions.create(<span class="keyword">new</span> Action0() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        call.cancel();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// call 是 OkHttpCall 的实例</span></span><br><span class="line">      Response&lt;T&gt; response = call.execute();</span><br><span class="line">      <span class="keyword">if</span> (!subscriber.isUnsubscribed()) &#123;</span><br><span class="line">        subscriber.onNext(response);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      Exceptions.throwIfFatal(t);</span><br><span class="line">      <span class="keyword">if</span> (!subscriber.isUnsubscribed()) &#123;</span><br><span class="line">        subscriber.onError(t);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!subscriber.isUnsubscribed()) &#123;</span><br><span class="line">      subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SimpleCallAdapter.adapt 很简单，创建一个 Observable获取CallOnSubscribe中的Response<t> 通过 flatMap转成Observable<r>后返回。这里去发送请求获取数据的任务在CallOnSubscribe.call 方法之中。并且最后走到了 okHttpCall.execute 中去了。</r></t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// OkHttpCall.execute </span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    okhttp3.Call call;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">//同一个请求 不能执行两次</span></span><br><span class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed."</span>);</span><br><span class="line">      executed = <span class="keyword">true</span>;</span><br><span class="line"> <span class="comment">// ...省略 Execption 处理</span></span><br><span class="line">     </span><br><span class="line">      call = rawCall;</span><br><span class="line">      <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 创建 okhttp3.call </span></span><br><span class="line">          call = rawCall = createRawCall();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | RuntimeException e) &#123;</span><br><span class="line">          creationFailure = e;</span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">      call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 请求并解析response 这个 call 是 okhttp3.call 是真交给 OkHttp 去发送请求了 </span></span><br><span class="line">    <span class="keyword">return</span> parseResponse(call.execute());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 response</span></span><br><span class="line">  <span class="function">Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//... 省略一些处理 只显示关键代码</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      T body = serviceMethod.toResponse(catchingBody);</span><br><span class="line">      <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">      catchingBody.throwIfCaught();</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// serviceMethod.toResponse</span></span><br><span class="line">  <span class="function">T <span class="title">toResponse</span><span class="params">(ResponseBody body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 还记得吗？这就是我们配置Retrofit时候的 converter</span></span><br><span class="line">    <span class="keyword">return</span> responseConverter.convert(body);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>经过一连串的处理，最终在 OkHttpCall.execute() 的方法中生成 okhttp3.call 交给 OkHttpClient 去发送请求，再由我们配置的 Converter(本文为GsonConverterFactory) 处理 Response,返回给SimpleCallAdapter处理，返回我们最终所需要的Observable。</p><h2 id="流程分析流程图总结"><a href="#流程分析流程图总结" class="headerlink" title="流程分析流程图总结"></a>流程分析流程图总结</h2><p>总体的流程图整理如下：</p><p><img src="http://ww4.sinaimg.cn/large/98900c07gw1fb479l1ubxj20c80irmxp.jpg"></p><h2 id="解答疑问"><a href="#解答疑问" class="headerlink" title="解答疑问"></a>解答疑问</h2><p>对于之前的疑问可以作答了。</p><h4 id="第一个疑问-我们调用接口的方法后是怎么发送请求的？这背后发生了什么？"><a href="#第一个疑问-我们调用接口的方法后是怎么发送请求的？这背后发生了什么？" class="headerlink" title="第一个疑问: 我们调用接口的方法后是怎么发送请求的？这背后发生了什么？"></a>第一个疑问: 我们调用接口的方法后是怎么发送请求的？这背后发生了什么？</h4><p>Retrofit 使用了动态代理给我们定义的接口设置了代理，当我们调用接口的方法时，Retrofit 会拦截下来，然后经过一系列处理，比如解析方法的注解等，生成了 Call Request 等OKHttp所需的资源，最后交给 OkHttp 去发送请求， 此间经过 callAdapter,convertr 的处理，最后拿到我们所需要的数据。</p><h4 id="第二个疑问-Retrofit-与-OkHttp-是怎么合作的？"><a href="#第二个疑问-Retrofit-与-OkHttp-是怎么合作的？" class="headerlink" title="第二个疑问: Retrofit 与 OkHttp 是怎么合作的？"></a>第二个疑问: Retrofit 与 OkHttp 是怎么合作的？</h4><p>在Retrofit 中，ServiceMethod 承载了一个 Http 请求的所有参数，OkHttpCall 为 okhttp3.call 的组合包装，由它们俩合作，生成用于 OkHttp所需的 Request以及okhttp3.Call，交给 OkHttp 去发送请求。(在本文环境下具体用的是 <code>call.execute()</code>)</p><p>可以说 Retrofit 为 OkHttp 再封装了一层，并增添了不少功能以及扩展，减少了开发使用成本。</p><h4 id="第三个疑问-Retrofit-中的数据究竟是怎么处理的？它是怎么返回-RxJava-Observable-的？"><a href="#第三个疑问-Retrofit-中的数据究竟是怎么处理的？它是怎么返回-RxJava-Observable-的？" class="headerlink" title="第三个疑问: Retrofit 中的数据究竟是怎么处理的？它是怎么返回  RxJava.Observable 的？"></a>第三个疑问: Retrofit 中的数据究竟是怎么处理的？它是怎么返回  RxJava.Observable 的？</h4><p>Retrofit 中的数据其实是交给了 callAdapter 以及 converter 去处理，callAdapter 负责把 okHttpCall 转成我们所需的 Observable类型(本文环境),converter负责把服务器返回的数据转成具体的实体类。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Retrofit 的源码其实非常好跟也非常好理解，不像看 framework 的代码，跟着跟着就不见了。</p><p>另外 Retrofit的代码确实非常漂亮，将设计模式运用的可以说是炉火纯青，非常值得学习。</p><h2 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h2><p><a href="http://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="noopener">Retrofit分析-漂亮的解耦套路</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTFSC </tag>
            
            <tag> Retrofit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>strings文件中修改部分字体颜色</title>
      <link href="/blog/1518ee08.html"/>
      <url>/blog/1518ee08.html</url>
      
        <content type="html"><![CDATA[<p>在 Android 开发中，通常会吧文本放在 strings.xml 文件中，然后再引用。</p><p>有时候，有些需求需要修改文本中的部分字的字体颜色，可以用以下方式修改：</p><p>修改原本的<code>strings.xml</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"hh_no_order"</span>&gt;</span>&lt;![CDATA[sorry，没有任何订单，&lt;font color="#fc2a56"&gt;前往买买买&lt;/font&gt;]]&gt;<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码中的使用需要配合<code>Html.fromHtml()</code>，如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mTvTip</span><span class="selector-class">.setText</span>(<span class="selector-tag">Html</span><span class="selector-class">.fromHtml</span>(<span class="selector-tag">mTips</span>))</span><br></pre></td></tr></table></figure><p>最终效果图为：</p><p><img src="http://upload-images.jianshu.io/upload_images/531570-620338208705b405.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RTFSC</title>
      <link href="/blog/caca1c8c.html"/>
      <url>/blog/caca1c8c.html</url>
      
        <content type="html"><![CDATA[<p>#　RTFSC</p><blockquote><p>Read The Fucking Source Code<br><a href="https://github.com/RTFSC-Android/RTFSC" target="_blank" rel="noopener">RTFSC</a></p></blockquote><h2 id="初衷-amp-为什么要阅读源码"><a href="#初衷-amp-为什么要阅读源码" class="headerlink" title="初衷&amp;为什么要阅读源码"></a>初衷&amp;为什么要阅读源码</h2><p>随着做Android开发时间越来越久，看别人的文章博客对自己的收益越来越少，以前看10篇文章，可能9篇对自己有用，后来慢慢减少，8 7 6..1 。</p><p>再加上现在国内的风气不好，标题党特别多，质量好的文章太少，在茫茫文章中获取有用信息变得越来越困难。</p><p>投入与回报不成比例，所以需要换一种方式去学习。</p><p>现在我更推荐看书以及阅读源码。</p><p>相对于看文章，看书有利于系统的学习，看源码的好处更是多多。</p><p>书也是有好有坏，关于书籍，我有一个记录读书笔记的项目<a href="https://github.com/AlanCheen/ReadingNotes" target="_blank" rel="noopener">ReadingNotes</a>,记录读书笔记，也有些扩展，对书籍也有一个相对比较客观的评价,或许可以帮到你，这里就不多说了。</p><a id="more"></a><h2 id="阅读源码的好处"><a href="#阅读源码的好处" class="headerlink" title="阅读源码的好处"></a>阅读源码的好处</h2><p>『所有的知识其实都来自源码』是我最深的感悟。  </p><p>通过阅读源码，对知识点的掌握不再流于表面，而能够做到知其然以及所以然，极大地提升判断力，不再人云亦云。</p><p>阅读源码还能极大的扩大知识面，通常在阅读源码的时候你会发现很多你根本不知道，或者看文章博客根本不会获取得到的知识，经常会遇到各种『彩蛋』。</p><p>Android 源码是学习设计模式的最佳途径之一，Android 团队遇到的坑，比我写过的代码还多，Android 源码中到处可见设计模式的影子，阅读它，可以加深对设计模式的理解。  </p><p>好处绝不止我所说的，自己去体会。  </p><h2 id="哪里可以看Android源码"><a href="#哪里可以看Android源码" class="headerlink" title="哪里可以看Android源码"></a>哪里可以看Android源码</h2><p>Android 源码的查看一般有以下几种方式：</p><ul><li>在在线网站上查看,如：<a href="http://grepcode.com/" target="_blank" rel="noopener">grepcode</a>,<a href="http://androidxref.com/" target="_blank" rel="noopener">androidxref</a>  </li><li>获取Android Framework源码查看，clone <a href="https://github.com/android/platform_frameworks_base" target="_blank" rel="noopener">frameworks_base</a> ，在 Mac 端可以使用 Sublime 配合 CTAG 查看。  </li><li>使用 AndroidStudio 看</li></ul><p>取合适自己的。</p><h2 id="阅读源码的姿势"><a href="#阅读源码的姿势" class="headerlink" title="阅读源码的姿势"></a>阅读源码的姿势</h2><p>源码数量庞大，如果漫无目的地去阅读很容易迷失自己，所以阅读源码要有一定的技巧。</p><ul><li>要有目标</li><li>由浅入深</li></ul><p>比如针对某一个问题去查看源码，eg. invalidate 和 postInvalidate 的关系与区别是什么？<br>这样有目标性的去寻找答案，才不容易迷失。</p><p>另外阅读源码不是容易的事情，可以从简单的类开始阅读，培养阅读习惯以及技巧，增加信心，再一层一层深入，不宜在刚开始就非常深入，这样容易打击自信，甚至开始『怀疑猿生』。</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>另外这些资料可能对你有帮助：</p><ul><li><a href="https://www.zhihu.com/question/19759722" target="_blank" rel="noopener">大牛们是怎么阅读 Android 系统源码的？</a>  </li><li><a href="http://kaedea.com/2016/02/09/android-about-source-code-how-to-read/" target="_blank" rel="noopener">阅读 ANDROID 源码的一些姿势</a>  </li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTFSC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访问者模式</title>
      <link href="/blog/64b51ed9.html"/>
      <url>/blog/64b51ed9.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式专题系列: <a href="http://yifeiyuan.me/2016/07/20/design-patterns/">设计模式</a></p></blockquote><h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><p>当你想要为一个对象的组合(组合模式)增加新的能力,且封装并不重要时,就使用访问者模式。</p><p>用途:  </p><ol><li>当采用访问者模式的时候,就会打破组合类的封装。  </li></ol><p>优点:  </p><ol><li>允许你对组合结构加入新的操作,而无需改变结构本身。  </li><li>想要加入新的操作,相对容易。  </li><li>访问者所进行的操作,其代码是集中在一起的。  </li></ol><a id="more"></a><p>缺点:  </p><ol><li>因为游走的功能牵涉其中,所以对组合结构的改变就更加困难。  </li></ol><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>才两页纸，没有代码很难理解啊。  </p><h2 id="See-also"><a href="#See-also" class="headerlink" title="See also"></a>See also</h2><p><a href="https://en.wikipedia.org/wiki/Visitor_pattern" target="_blank" rel="noopener">Visitor_pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="/blog/91ad9ce3.html"/>
      <url>/blog/91ad9ce3.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式专题系列: <a href="http://yifeiyuan.me/2016/07/20/design-patterns/">设计模式</a></p></blockquote><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>当创建给定类的实例的过程很昂贵或很复杂时，就使用原型模式（Prototype Pattern）。</p><p><img src="http://ww4.sinaimg.cn/large/98900c07jw1f6glqr208bj20xc0daq4b.jpg" alt="UML"></p><p>原型模式允许你通过复制现有的实例来创建新的实例（在Java中，这通常意味着使用<code>clone（）</code>方法，或者反序列化）。</p><p>原型模式的重点在于，客户端的代码在不知道要实例化何种特定类的情况下，可以制造出新的实例。（？不太理解）  </p><a id="more"></a><p>用途：</p><ol><li>在一个复杂的类层次中，当系统必须从其中的许多类型创建新的对象时，可以考虑原型。  </li></ol><p>优点：</p><ol><li>向客户隐藏制造新实例的复杂性。</li><li>提供客户能够产生位置类型对象的选项。</li><li>在某些环境下，复制对象比创建对象更有效。</li></ol><p>缺点：</p><ol><li>对象的复制有时相当复杂。</li></ol><p>##　See also<br><a href="https://en.wikipedia.org/wiki/Prototype_pattern" target="_blank" rel="noopener">Prototype_pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>备忘录模式</title>
      <link href="/blog/c3176455.html"/>
      <url>/blog/c3176455.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式专题系列: <a href="http://yifeiyuan.me/2016/07/20/design-patterns/">设计模式</a></p></blockquote><h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><p>当你需要让对象返回之前的状态时（例如，你的用户请求“撤销”），就使用备忘录模式。</p><p>备忘录的目标：</p><ul><li>储存系统关键对象的重要状态。</li><li>维护关键对象的封装。  </li></ul><p>咦，那Activity、Fragment、View的 <code>onSaveInstanceState</code> 不就是备忘录模式吗？ </p><a id="more"></a><p>用途：</p><ol><li>备忘录用于存储状态。</li></ol><p>优点：</p><ol><li>将被储存的状态放在外面，不要和关键对象混在一起，这可以帮助维护内聚。</li><li>保持关键对象的数据封装。</li><li>提供了容易实现的恢复能力。  </li></ol><p>缺点：</p><ol><li>储存和回复状态的过程可能相当耗时。</li><li>在Java系统中，其实可以考虑使用序列化机制储存系统的状态。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中介者模式</title>
      <link href="/blog/d036071c.html"/>
      <url>/blog/d036071c.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式专题系列: <a href="http://yifeiyuan.me/2016/07/20/design-patterns/">设计模式</a></p></blockquote><h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><p>使用中介者模式来集中相关对象之间复杂的沟通和控制方式。</p><ol><li>每个对象都会在自己的状态改变时,告诉中介者</li><li>每个对象都会对中介者锁发出的请求作出回应</li></ol><p>没有中介者的情况之下,所有的对象都需要认识其他对象,也即对象之间是紧耦合的.<br>当有了中介者后,对象之间不需要认识,只需要跟中介者打交道,这样一来对象之间就被解耦了.</p><p>中介者包含了整个系统的控制逻辑.  </p><a id="more"></a><p>用途:</p><ol><li>中介者常常被用来协调相关的GUI组件</li></ol><p>这让我想到了Android中的Activity,在Activity中包含了各种View以及Adapter等对象,Activity也包含了整个系统的控制逻辑,那么我想,Activity就是一个中介者吧!</p><p>优点:</p><ol><li>通过将对象彼此解耦,可以增加对象的复用性</li><li>通过将控制逻辑集中,可以简化系统维护</li><li>可以让对象之间所传递的消息变得简单而且大幅减少</li></ol><p>缺点:</p><p>如果设计不当,中介者本身会变得过于复杂  </p><p>想想Activity,如果职责一多,两三千行代码,就非常复杂了,缺点也显而易见了  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解释器模式</title>
      <link href="/blog/30cf0cd2.html"/>
      <url>/blog/30cf0cd2.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式专题系列: <a href="http://yifeiyuan.me/2016/07/20/design-patterns/">设计模式</a></p></blockquote><h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><p>使用解释器模式为语言创建解释器.  </p><p><img src="http://ww3.sinaimg.cn/large/98900c07gw1f6em1ns9a8j20fm07j0t0.jpg" alt="">  </p><p>用途: </p><ol><li>当你需要实现一个简单的语言时,使用解释器.   </li><li>当你有一个简单的语法,而且简单比效率更重要时,使用解释器.    </li><li>可以处理脚本语言和编程语言.  </li><li>可以处理脚本语言和编程语言.  </li></ol><a id="more"></a><p>优点:   </p><ol><li>将每一个语法规则表示成一个类,方便于实现语言.   </li><li>因为语法由许多类表示,所以你可以轻易地改变或扩展此语言.  </li><li>通过在类结构中加入新的方法,可以在解释的同时增加新的行为,例如打印格式的美化或者进行复杂的程序验证.  </li></ol><p>缺点:  </p><ol><li>当语法规则的数目太大时,这个模式可能会变得非常繁杂.在这种情况下,使用解析器/编译器的产生器可能更合适.</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我觉着吧,跟自己定义一个语法规则类似,对应的不一定要类,可以是行为.<br>比如  隐式跳转什么的  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蝇量模式</title>
      <link href="/blog/7de003dc.html"/>
      <url>/blog/7de003dc.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式专题系列: <a href="http://yifeiyuan.me/2016/07/20/design-patterns/">设计模式</a></p></blockquote><h1 id="蝇量模式"><a href="#蝇量模式" class="headerlink" title="蝇量模式"></a>蝇量模式</h1><p>如果想让某个类的实例能用来提供许多”虚拟实例”,就使用蝇量模式。  </p><p>用途: </p><ol><li>当一个类有许多的实例,而这些实例能被同一个方法控制的时候,我们就可以使用蝇量模式.</li></ol><p>优点:</p><ol><li>减少运行时对象实例的个数,节省内存.  </li><li>将许多”虚拟”对象的状态集中管理.  </li></ol><p>缺点:</p><ol><li>蝇量模式的缺点在于,一旦你实现了它,那么单个的逻辑实例无法拥有独立而不同的行为.  </li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>责任链模式</title>
      <link href="/blog/6208627e.html"/>
      <url>/blog/6208627e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式专题系列: <a href="http://yifeiyuan.me/2016/07/20/design-patterns/">设计模式</a></p></blockquote><h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><p>当你想要让一个以上的对象有机会能够处理某个请求的时候,就使用责任链模式.  </p><p>通过责任链模式,可以为某个请求创建一个对象链.每个对象依序检查此请求,并对其进行处理,或者将它传给链中的下一个对象.</p><p>拿Android来说,View的 <code>onTouch</code> 等方法都是使用了责任链模式.  </p><a id="more"></a><p>用途:</p><p>经常被使用在窗口系统中,处理鼠标和键盘之类的事件(在Android的触摸事件分发)</p><p>优点:  </p><ol><li>将请求的发送者和接受者解耦</li><li>可以简化你的对象,因为它不需要知道链的结构</li><li>通过改变链内的成员或调动它们的次序,允许你动态地新增或者删除责任</li></ol><p>缺点:  </p><ol><li>并不保证请求一定会被执行,如果没有任何对象处理它的话,它可能会落到链尾端之外(这可以是优点也可以是缺点)</li><li>可能不容易观察运行时的特征,有碍于排除错误</li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成器模式</title>
      <link href="/blog/ffd38062.html"/>
      <url>/blog/ffd38062.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式专题系列: <a href="http://yifeiyuan.me/2016/07/20/design-patterns/">设计模式</a></p></blockquote><h1 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h1><p>使用生成器模式封装一个产品的构造过程，并允许按步骤构造。</p><p>在Android中比较常见了,比如 Dialog,,另外在EffectiveJava的笔记中也有提到,就不多说了.  </p><a id="more"></a><p>用途:  </p><ol><li>经常被用来创建组合结构.</li></ol><p>优点:  </p><ol><li>将一个复杂对象的创建过程封装起来.</li><li>允许对象通过多个步骤来创建,并且可以改变过程(这和只有一个步骤的工厂模式不同)</li><li>向客户隐藏产品内部的表现</li><li>产品的实现可以被替换,因为客户只看到一个抽象的接口.</li></ol><p>缺点:</p><ol start="2"><li>与工厂模式相比,采用生成器模式创建对象的客户,需要具备更多的领域知识.  </li></ol><h2 id="See-also"><a href="#See-also" class="headerlink" title="See also"></a>See also</h2><p><a href="https://en.wikipedia.org/wiki/Builder_pattern" target="_blank" rel="noopener">Builder_Pattern</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桥接模式</title>
      <link href="/blog/563268dc.html"/>
      <url>/blog/563268dc.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式专题系列: <a href="http://yifeiyuan.me/2016/07/20/design-patterns/">设计模式</a></p></blockquote><h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p>桥接模式通过 <strong>将实现和抽象放在两个不同的类层次中而使它们可以独立改变</strong>。  </p><p>使用桥接模式不只改变你的实现，也改变你的抽象。</p><p><img src="http://ww4.sinaimg.cn/large/98900c07jw1f6ef0jrt68j20rs0dwq4l.jpg" alt=""></p><a id="more"></a><p>上code：  </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** "Implementor" */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">DrawingAPI</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span>(<span class="params"><span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> radius</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** "ConcreteImplementor"  1/2 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">DrawingAPI1</span> <span class="title">implements</span> <span class="title">DrawingAPI</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span>(<span class="params"><span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> radius</span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.printf(<span class="string">"API1.circle at %f:%f radius %f\n"</span>, x, y, radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** "ConcreteImplementor" 2/2 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">DrawingAPI2</span> <span class="title">implements</span> <span class="title">DrawingAPI</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span>(<span class="params"><span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> radius</span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.printf(<span class="string">"API2.circle at %f:%f radius %f\n"</span>, x, y, radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** "Abstraction" */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> DrawingAPI drawingAPI;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Shape</span>(<span class="params">DrawingAPI drawingAPI</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drawingAPI = drawingAPI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span>(<span class="params"></span>)</span>;                             <span class="comment">// low-level</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">resizeByPercentage</span>(<span class="params"><span class="keyword">double</span> pct</span>)</span>;     <span class="comment">// high-level</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** "Refined Abstraction" */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">CircleShape</span> <span class="title">extends</span> <span class="title">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x, y, radius;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleShape</span>(<span class="params"><span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> radius, DrawingAPI drawingAPI</span>)</span> &#123;</span><br><span class="line">        super(drawingAPI);</span><br><span class="line">        <span class="keyword">this</span>.x = x;  <span class="keyword">this</span>.y = y;  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// low-level i.e. Implementation specific</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        drawingAPI.drawCircle(x, y, radius);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// high-level i.e. Abstraction specific</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resizeByPercentage</span>(<span class="params"><span class="keyword">double</span> pct</span>)</span> &#123;</span><br><span class="line">        radius *= (<span class="number">1.0</span> + pct/<span class="number">100.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** "Client" */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">BridgePattern</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        Shape[] shapes = <span class="keyword">new</span> Shape[] &#123;</span><br><span class="line">            <span class="keyword">new</span> CircleShape(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="keyword">new</span> DrawingAPI1()),</span><br><span class="line">            <span class="keyword">new</span> CircleShape(<span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="keyword">new</span> DrawingAPI2())</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Shape shape : shapes) &#123;</span><br><span class="line">            shape.resizeByPercentage(<span class="number">2.5</span>);</span><br><span class="line">            shape.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：<br>具体实现为 <code>Implemetor</code>,抽象为 <code>Shape</code>,放在不同的层次，抽象拥有实现的引用，具体实现的修改不需要修改抽象</p><p>用途:  </p><ol><li>适合使用在需要跨越多个平台的图形和窗口系统上。</li><li>当需要用不同的方式改变接口和实现时，你会发现桥接模式很好用。</li></ol><p>优点：</p><ol><li>将实现予以解耦，让它和界面之间不再永久绑定。</li><li>抽象和实现可以独立扩展，不会影响到对方。</li><li>对于『具体的抽象类』所做的改变，不会影响到客户。</li></ol><p>缺点： </p><ol><li>桥接模式的缺点是增加了复杂度。</li></ol><h2 id="See-also"><a href="#See-also" class="headerlink" title="See also"></a>See also</h2><p><a href="https://en.wikipedia.org/wiki/Bridge_pattern" target="_blank" rel="noopener">Bridge</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板方法模式</title>
      <link href="/blog/ecc6414b.html"/>
      <url>/blog/ecc6414b.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式专题系列: <a href="http://yifeiyuan.me/2016/07/20/design-patterns/">设计模式</a></p></blockquote><h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><p>模板方法模式： <strong>在一个方法中定义一个算法的估价，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变方法结构的情况下，重新定义算法的某些步骤。</strong>  </p><p><img src="http://ww4.sinaimg.cn/large/98900c07jw1f61gfmlicej20s40p2ae6.jpg" alt="类图"></p><p>具体来说：</p><p>创建一个算法的模板，这个模板其实就是第一个方法(需要定义为<code>final</code>)。而这个方法将算法定义成一组步骤，其中的任何步骤都可以是抽象的，由子类负责实现。这样可以确保算法结构保持不变，同时由子类提供部分实现。  </p><a id="more"></a><p>模板方法模式用来封装算法。</p><h2 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2><p>BONUS TIME！  </p><p><code>hook()</code>(钩子)指那些 『默认不做事的方法』，子类可以视情况决定要不要覆盖它们。  </p><p><strong>钩子</strong> 是 『一种被声明在抽象类中的方法，但只有空的或者默认的实现』。</p><p>钩子的存在，可以让子类有能力对算法的不同点就行挂钩。要不要挂钩，由子类自行决定。  </p><p>其实Hook并不高端，在实际中有很多运用，比如在<code>BaseActivity</code>里配置一些东西的时候，留几个有默认返回值的方法做为某个功能的开关，比如：是否能侧滑返回等。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span>（canSwipeBack()）&#123;</span><br><span class="line">  setupSwipeBack();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">canSwipeBack</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hook-的用法-amp-目的"><a href="#Hook-的用法-amp-目的" class="headerlink" title="Hook 的用法&amp;目的"></a>Hook 的用法&amp;目的</h3><ol><li>Hook可以让子类实现算法中的『可选』部分。  </li><li>让子类有机会对模板方法中某些即将发生的(或刚刚发生的)步骤做出反应。    </li><li>钩子也可以让子类有能力为其抽象类做一些决定。  </li></ol><p>Java中数组的 <code>Arrays.sort([])</code> 方法就是模板方法。  </p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>模板方法定义了算法的步骤，把这些步骤的实现延迟到了子类。  </li><li>模板方法为我们提供了一种代码复用的重要技巧。  </li><li>模板方法的抽象类可以定义具体方法、抽象方法和钩子。  </li><li>抽象方法由子类实现。  </li><li>钩子是一种方法，它在抽象类中不做事，或者只做默认的事情，子类可以选择要不要去覆盖它。</li><li>为了防止子类改变模板方法中的算法，可以将模板方法声明为<code>final</code></li><li>好莱坞原则告诉我们，将决策权放在高层模块中，以便决定如何以及何时调用低层模块。  </li><li>你将在真实世界代码中看到模板方法模式的许多变体，不要期待它们全都是一眼就可以被你认出的。</li><li>策略模式和模板模式都封装算法，一个用组合，一个用继承。  </li><li>工厂方法是模板方法的一个特殊版本。  </li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>模板方法更侧重在『模板』二字，它需要做的是定义一个算法的『大纲』，它的子类去实现的是这个『大纲』里的几个步骤，算法的结构维持不变。  </p><p>模板方法对算法的控制权更大一些，但是由于模板方法使用的是 继承，并且父类中有实现，所以子类会依赖父类中的实现，缺乏了点弹性。  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态模式</title>
      <link href="/blog/8acb1976.html"/>
      <url>/blog/8acb1976.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式专题系列: <a href="http://yifeiyuan.me/2016/07/20/design-patterns/">设计模式</a></p></blockquote><h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p>状态模式： <strong>允许对象在内部状态改变时改变它的行为，对象看起来好像修改它的类。</strong>  </p><p>状态模式把每个状态都独立成类，并将动作委托到代表当前状态的对象。  </p><p><img src="http://ww2.sinaimg.cn/large/98900c07jw1f62rdcmaarj20m8081wfc.jpg" alt="类图"></p><p>Context需要持有 <strong>所有状态的一个实例</strong>（弹性的代价），通过不同状态来切换状态对象，把行为委托给当前状态的对象，客户端不知道Context内部的状态，跟策略模式不同，策略模式需要客户端去指定策略，而且一般来讲策略模式就只有一个最佳策略，不会存在多个。<br><a id="more"></a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>状态模式允许一个对象基于内部状态而拥有不同的行为。  </li><li>和程序状态机（PSM）不同，状态模式用类代表状态。  </li><li>Context会将行为委托给当前状态对象。</li><li>通过将每个状态封装进一个类，我们把以后需要做的任何状态局部化了。</li><li>状态模式和策略模式有相同的类图，但是它们的意图不同。</li><li>策略模式通常会用行为或算法来配置Context类。  </li><li>状态模式允许Context随着状态的改变而改变行为。</li><li>状态转换可以由State类或Context类控制。  </li><li>使用状态模式通常会导致设计中类的数目大量增加。  </li><li>状态类可以被多个Context实例共享。  </li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/blog/7b510e10.html"/>
      <url>/blog/7b510e10.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式专题系列: <a href="http://yifeiyuan.me/2016/07/20/design-patterns/">设计模式</a></p></blockquote><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><blockquote><p>这一章节的内容较多，笔记比较乱，还是看书好些。</p></blockquote><p>代理模式： <strong>为另一个对象提供一个替身或占位符以控制对这个对象的访问。</strong>  </p><p>所谓代理（proxy），就是代表某个真实的对象。  </p><p>代理要做的就是：<strong>控制和管理访问(控制对象访问)</strong>  </p><p>why? 是因为Client不知道如何和远程对象沟通。从某方面来看，远程代理控制访问，可以帮忙处理一些细节（比如网络，IPC）。</p><p><img src="http://ww1.sinaimg.cn/large/98900c07jw1f62sqklu5rj20m80cegm9.jpg" alt="类图"><br>（Subject可以是接口）  </p><a id="more"></a><p>代理最主要的方法：</p><p><strong>远程代理</strong>（remote proxy），好比『远程对象的本地代表』;远程代理是 <strong>一种对象，活在不同的Java虚拟机(JVM)堆中</strong>（更一般的说法为，在不同 <strong>地址空间运行的远程对象</strong>）  </p><p>PS：在Android中的代理，如 Binder，处理不同进程间IPC，就是在不同的地址。  </p><p>变体代理方法：  </p><ol><li>远程代理 控制访问远程对象。</li><li>虚拟代理控制访问创建开销大的资源（在必要的时候才创建对象，对象创建完了才委托给对象）</li><li>保护代理基于权限控制对资源的访问。  </li></ol><p>本地代表，是一种可以由本地方法调用的对象，其行为会转发到远程对象中。  </p><p>工作原理示意图：  </p><p><img src="http://ww3.sinaimg.cn/large/98900c07jw1f62uet9p85j20gt07l3zc.jpg" alt=""></p><p>书中提到了 <code>RMI</code> 技术，它将 客户辅助对象称为<code>stub</code>（桩）,服务器辅助对象称为<code>skeleton</code>（g骨架）。</p><p>BONUS：    </p><ul><li>原语类型（primitive-原来常说的基本类型），传输过程允许的对象类型要注意，自己定义的类的对象需要实现Serializable（Java）  </li><li>当不需要传输的时候，用<code>transient</code>来修饰变量。   </li></ul><p>例子让我想起来Android中的 <code>AIDL</code>和<code>Binder</code>，忽然间懂了好多。  </p><h2 id="保护代理"><a href="#保护代理" class="headerlink" title="保护代理"></a>保护代理</h2><p>可以在运行时动态地创建一个代理类，实现一个或多个接口，并将方法的调用转发到你所指定的类。因为实际的代理类是在运行时创建的，我们称这个Java技术为：<strong>动态代理</strong>。大名鼎鼎的  <code>retrofit</code> 用的就是动态代理。</p><p>动态代理的UML：</p><p><img src="http://ww3.sinaimg.cn/large/98900c07jw1f65z5ys3pwj20gz09adgm.jpg" alt="">  </p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>代理模式为另一个对象提供代表，以便控制客户对对象的访问，管理访问的方式有许多种。</li><li>远程代理管理客户和远程对象之间的交互。</li><li>虚拟代理控制访问实例化对对象方法的访问。</li><li>代理模式有许多变体，例如：缓存代理、同步代理、防火墙代理和写入时复制代理。</li><li>代理在结构上类似装饰者，但是目的不同。</li><li>装饰者模式为对象加上行为，而代理则是控制访问。</li><li>Java内置的代理支持，可以根据需要建立动态代理，并将所有调用分配到所选的处理器。</li><li>就和其他的包装者（wrapper)一样，代理会造成你的设计中类的数目增加。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/blog/9a246216.html"/>
      <url>/blog/9a246216.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式专题系列: <a href="http://yifeiyuan.me/2016/07/20/design-patterns/">设计模式</a></p></blockquote><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>观察者模式：<br><strong>定义了对象之间的一对多依赖，这样依赖，当一个对象改变状态时，它的所有依赖者都会受到通知，并自动更新。</strong>  </p><p><img src="http://ww3.sinaimg.cn/large/98900c07jw1f5zaullrcij2099060t8v.jpg" alt=""></p><p>出版者（Subject） + 订阅者（Observer） = 观察者模式  </p><p>观察者依赖于主题。<br><a id="more"></a></p><p><img src="http://ww4.sinaimg.cn/large/98900c07gw1f5uino6cvoj20rs0bh0ub.jpg" alt="UML">  </p><p><strong>观察者模式提供了一种对象设计，让主题和观察者之间松耦合。</strong>  </p><ol><li>观察者与主题之间依赖于接口，主题不需要知道观察者的具体实现</li><li>可以动态添加删除观察者，对主题没有任何影响  </li><li>新增新类型的观察者对主题没有影响，主题的代码不需要修改，而且旧的观察者也不受影响  </li><li>观察者与主题都可以独立复用，因为是松耦合  </li><li>只要约定的接口不改变，修改主题或观察者任何一方，都不会影响另一方  </li></ol><p>比如 EventBus 就是观察者模式。<br>注意： <strong>观察者模式会造成内存泄漏，一定要记得取消订阅</strong>  </p><h2 id="See-also"><a href="#See-also" class="headerlink" title="See also"></a>See also</h2><p><a href="https://en.wikipedia.org/wiki/Observer_pattern" target="_blank" rel="noopener">Observer pattern</a><br><a href="http://javadesign-patterns.blogspot.com/p/page22.html" target="_blank" rel="noopener">Observer Design Pattern Example</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器模式</title>
      <link href="/blog/9055d217.html"/>
      <url>/blog/9055d217.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式专题系列: <a href="http://yifeiyuan.me/2016/07/20/design-patterns/">设计模式</a></p></blockquote><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><p>迭代器模式(Iterator)： <strong>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示</strong>。  </p><p>迭代器模式服务『集合』，为了更好地管理集合。</p><p>所谓集合(Collection)就是是，<strong>一群对象</strong>，可以放在数组、堆栈、列表、散列表等。<br>集合有时候也被称为『聚合』(aggregate)。  </p><a id="more"></a><h2 id="迭代器的意义与优势"><a href="#迭代器的意义与优势" class="headerlink" title="迭代器的意义与优势"></a>迭代器的意义与优势</h2><ol><li>我们不需要知道一个集合到底是数组还是列表还是什么其他的结构。</li><li>把游走的任务放在迭代器上，而不是聚合上。这样简化了聚合的接口和实现，也让责任各得其所。  </li></ol><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>迭代器允许访问聚合的元素，而不需要暴露它的内部结构。</li><li>迭代器将遍历聚合的工作封装进一个对象中。</li><li>当使用迭代器的时候，我们依赖聚合提供遍历。</li><li>迭代器提供了一个通用的接口，让我们遍历聚合的项，当我们编码使用聚合的项时，就可以使用多台机制。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Java中已经存在有 <code>Iterator</code> 了，大部分情况下，我们不需要自己在写。<br>如果要加新的功能，当然还是可以扩展的，比如 <code>ListIterator</code>新增了<code>previous</code>等方法。  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/blog/54788f73.html"/>
      <url>/blog/54788f73.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式专题系列: <a href="http://yifeiyuan.me/2016/07/20/design-patterns/">设计模式</a></p></blockquote><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式分两种模式：  </p><ol><li>工厂方法</li><li>抽象工厂</li></ol><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><p>使用<code>new Xxx()</code>创建对象非常脆弱，缺乏弹性，耦合度高。</p><p><img src="http://ww1.sinaimg.cn/large/98900c07jw1f5zcr70c9ij206u04d3yi.jpg" alt="">  </p><p>当具体类需要新增或删除的时候，就必须修改这段代码，非常容易出错，难以维护和更新。  </p><p>所以需要把创建对象的方法封装起来，用“工厂”来负责创建对象。  </p><p>定义Factory：<br><img src="http://ww3.sinaimg.cn/large/98900c07jw1f5zd1wwkihj208r062dg5.jpg" alt=""></p><p>使用：  </p><p><img src="http://ww4.sinaimg.cn/large/98900c07jw1f5zd2n94izj208o072dgd.jpg" alt=""></p><p>看起来可能只是把代码挪到了另外一个地方，但是其实有不少好处。  </p><a id="more"></a><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ol><li>避免代码重复，可复用，也可服务多个对象</li><li>降低耦合度，增加弹性</li><li>便于维护</li></ol><p>NOTE：它跟静态方法的差别是，静态方法不需要实例化，并且它不能通过继承来改变创建方法的行为。  </p><p>oh，另外，其实简单工厂并不是设计模式。  </p><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>工厂方法模式(FactoryMethod)定义了<strong>一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</strong>    </p><p>工厂方法通过<strong>让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的</strong>，所以工厂方法是 <strong>继承，覆盖方法来实现</strong>  </p><p>通常工厂方法模板是这样的：  </p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回对象和入参根据实际情况定  </span></span><br><span class="line"><span class="keyword">abstract</span> Product factoryMethod（<span class="keyword">String</span> <span class="keyword">type</span>）;</span><br></pre></td></tr></table></figure><p><img src="http://ww3.sinaimg.cn/large/98900c07jw1f5zcaul6vcj20ah076gm3.jpg" alt=""></p><p><code>createPizza</code>应该是受保护权限</p><p>在父类<code>PizzaStore</code>中定义<code>createPizza</code>抽象方法，让子类去实现。  </p><p>NOTE：也可以不是抽象方法，提供默认的实现。</p><h3 id="好处-1"><a href="#好处-1" class="headerlink" title="好处"></a>好处</h3><ol><li>将‘实例化’从‘使用’中解耦</li><li>易扩展 易维护</li><li>更具弹性</li></ol><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>抽象工厂模式：<strong>提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</strong>  </p><p>抽象工厂允许<strong>客户使用抽象的接口来创建一组相关的产品，而不需要知道（或关心）实际产出的具体产品是什么</strong>。这样一来客户就从具体的产品中被解耦。</p><p>抽象工厂跟工厂方法非常相似，但抽象工厂强调的是<strong>一组产品</strong>，是对组的抽象，需要一个大的接口；工厂方法使用的是类与继承而抽象工厂使用的是<strong>组合</strong>；</p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>所有的工厂都是用来封装对象的创建。  </li><li>工厂方法使用继承：把对象的创建委托给子类，将实例化延迟到子类。  </li><li>抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中。  </li><li>所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合。  </li><li>抽象工厂创建相关的对象家族，而不需要依赖它们的具体类。  </li></ol><h2 id="See-also"><a href="#See-also" class="headerlink" title="See also"></a>See also</h2><p><a href="https://en.wikipedia.org/wiki/Factory_method_pattern" target="_blank" rel="noopener">Factory method pattern</a></p><p><a href="http://javadesign-patterns.blogspot.com/p/factory-desig.html" target="_blank" rel="noopener">Factory Design Pattern Example</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外观模式</title>
      <link href="/blog/f7de8aa8.html"/>
      <url>/blog/f7de8aa8.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式专题系列: <a href="http://yifeiyuan.me/2016/07/20/design-patterns/">设计模式</a></p></blockquote><h1 id="外观模式-Facade"><a href="#外观模式-Facade" class="headerlink" title="外观模式(Facade)"></a>外观模式(Facade)</h1><p>外观模式： <strong>提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用</strong>。  </p><p>或者说：将一个类或数个类的复杂的一切都隐藏在背后，只显露出一个感觉美好的外观。  </p><p>外观模式创建一个接口简化而统一的类，用来包装子系统中的一个或者多个复杂的类，而暴露给客户端的是非常简单的接口，让 <strong>客户端和子系统解耦</strong>。  </p><a id="more"></a><p><img src="http://ww1.sinaimg.cn/large/98900c07jw1f61clnut0gj20g10aodha.jpg" alt="类图"></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol start="0"><li>让接口更简单</li><li>外观提供简化的接口，但依然可以直接使用子系统的类。  </li><li>外观可以附加更『聪明的』功能，让子系统更方便。  </li><li>外观不只是简化了接口，也 <strong>将客户从组件的子系统中解耦</strong>。    </li><li>外观和适配器可以包装许多类，但是外观的意图是 <strong>简化接口</strong>，而适配器的意图是 <strong>将接口转换成不同的接口</strong>。  </li></ol><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观。  </li><li>外观将客户从一个复杂的子系统中解耦。  </li><li>实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行。</li><li>你可以为一个子系统实现一个以上的外观。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰者模式</title>
      <link href="/blog/a708a60d.html"/>
      <url>/blog/a708a60d.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式专题系列: <a href="http://yifeiyuan.me/2016/07/20/design-patterns/">设计模式</a></p></blockquote><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>装饰者模式：  </p><p><strong>动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</strong>  </p><p>装饰者模式可以给类 <strong>动态地添加功能，而不需要修改已经存在的类</strong>，类似一个<code>Wrapper</code>。  </p><p>装饰者有弹性，非常符合 <code>开闭原则</code></p><a id="more"></a><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>装饰者和被装饰者对象<strong>拥有相同的超类型</strong>  </li><li>你可以用一个或多个装饰者包装一个对象  </li><li>既然装饰者和被装饰者对象拥有相同的超类型，所以在任何需要原始对象（被包装的）的场合，可以用装饰过的对象替代它  </li><li><strong>装饰者可以在所委托被装饰者的行为之前或之后加上自己的行为，以达到特定的目的</strong>  </li><li>对象可以在任何时候被装饰，所以可以在运行时动态地不限量地用你喜欢的装饰者来装饰对象  </li></ol><h2 id="装饰者模式的缺点"><a href="#装饰者模式的缺点" class="headerlink" title="装饰者模式的缺点"></a>装饰者模式的缺点</h2><p><strong>可能会引入大量的类</strong>，导致理解起来并不容易，也可能会使使用者懵逼。   </p><p>可能会出现以下情况：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D a = <span class="keyword">new</span> <span class="type">A</span>(<span class="keyword">new</span> <span class="type">B</span>(<span class="keyword">new</span> <span class="type">C</span>(<span class="keyword">new</span> <span class="type">D</span>)));</span><br></pre></td></tr></table></figure></p><p>比较复杂，难以理解。  </p><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><p>Java源码中的<code>I/O</code>就是装饰者模式，各种 <code>XXXStream</code>、<code>Reader</code> 和 <code>Writer</code>。  </p><p>比如：  </p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader reader = <span class="keyword">new</span> <span class="type">BufferedReader</span>(<span class="keyword">new</span> <span class="type">FileReader</span>(<span class="keyword">new</span> <span class="type">File</span>(<span class="string">"C:\\testing.txt"</span>)));</span><br></pre></td></tr></table></figure><h2 id="See-also"><a href="#See-also" class="headerlink" title="See also"></a>See also</h2><p><a href="http://javadesign-patterns.blogspot.com/p/decorator.html" target="_blank" rel="noopener">Decorator Design Pattern Example</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复合模式</title>
      <link href="/blog/f2a712ca.html"/>
      <url>/blog/f2a712ca.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式专题系列: <a href="http://yifeiyuan.me/2016/07/20/design-patterns/">设计模式</a></p></blockquote><h1 id="复合模式"><a href="#复合模式" class="headerlink" title="复合模式"></a>复合模式</h1><p>复合模式结合两个或以上的模式，组成一个解决方案，解决一再发生的一般性问题。</p><p>复合模式在一个解决方案中结合两个或多个模式，已解决一般或重复发生的问题。  </p><p>MVC就是一个复合模式。（书中把MVC夸得不行不行的-0-~，称它为 复合模式之王！）</p><p>多的不说，截一张示意图：  </p><p><img src="http://ww4.sinaimg.cn/large/98900c07jw1f669px7n0uj20jg0ew3zy.jpg" alt="MVC"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合模式</title>
      <link href="/blog/df879792.html"/>
      <url>/blog/df879792.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式专题系列: <a href="http://yifeiyuan.me/2016/07/20/design-patterns/">设计模式</a></p></blockquote><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>组合(Composite)模式：<strong>允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。</strong>  </p><p>组合模式比较复杂一些，跟迭代器模式配合威力强大。</p><p><img src="http://ww1.sinaimg.cn/large/98900c07jw1f62hwemqvcj20xc0ljdhf.jpg" alt="类图"></p><a id="more"></a><p>树形结构：  </p><p><img src="http://ww4.sinaimg.cn/large/98900c07jw1f62nmm1sfrj209d08oq33.jpg" alt=""></p><p>带子元素的元素称为 『节点』(node)  </p><p>没有子元素的元素称为 『叶节点』(leaf)  </p><p>包含其他组件的组件为『组合对象』，没有包含其他组件的组件为『叶节点对象』</p><p><strong>任何一个『节点』和『叶节点』都是一种『组合』。</strong>    </p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>组合模式让我们能用树型方式创建对象的结构，树里面包含了组合以及个别的对象。<br>使用组合结构，我们能把相同的操作应用在组合和个别对象上。换句话说，在大多数情况下，我们可以忽略对象组合和个别对象之间的差别。  </p><p>使用组合模式的时候，Component需要包含<code>Leaf</code>和<code>Composite</code>，以致于它们都会包含一些自己不需要的方法，所以可能在不需要的方法里<code>throw  UnsupportedOperationExecption</code> 或者 返回<code>null</code>or<code>false</code>。   </p><p>并且这么做，其实是不符合单一职责原则的，但是这么做能换来『透明性』(transparency): <strong>通过让组件的接口同时包含一些管理子节点和页节点的操作，客户就可以将组合和叶节点一视同仁</strong>。也就是说，一个元素究竟是组合还是叶节点，对客户是透明的。  </p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>组合模式提供一个结构，可同时包含个别对象和组合对象。</li><li>组合模式允许客户对个别对象以及组合对象一视同仁。</li><li>组合结构内的任意对象成为组件，组件可以是组合，也可以是叶节点。</li><li>实现组合模式时，有许多设计上的折中。你要根据需要平衡透明性和安全性。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>组合最大的优势是：<strong>让客户端更加简单，客户端不需要再操心面对的是组合对象还是叶节点对象，所以不需要写一大堆if语句来保证他们对正确的对象调用了正确的方法。通常，他们只需要对整个结构调用一个方法并执行操作就可以了。</strong>  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/blog/f5c535ea.html"/>
      <url>/blog/f5c535ea.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式专题系列: <a href="http://yifeiyuan.me/2016/07/20/design-patterns/">设计模式</a>    </p></blockquote><h1 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式(Adapter)"></a>适配器模式(Adapter)</h1><p>适配器模式：<strong>将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</strong>  </p><p>适配器非常形象的图：  </p><p><img src="http://ww3.sinaimg.cn/large/98900c07jw1f60ibhzrx4j20aj057t8u.jpg" alt="形象图"></p><p>非常形象的模式，就像生活中的手机充电器，电脑的电源适配器一样。</p><a id="more"></a><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>当想使用一个已经存在的类，但是不匹配需求接口的时候，可以考虑使用适配器模式来适配，如果有需要还可以做 <strong>双向适配</strong>，来完成适配。  </p><p><img src="http://ww4.sinaimg.cn/large/98900c07jw1f60l15wrt4j20u20m8416.jpg" alt="类图"></p><p>适配器实现Client所需的目标的接口，并包裹一个被适配者的对象，收到方法调用的时候，委托给被适配者，来达到适配的目标。  </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol><li>使用对象组合的方式，用修改的接口来包装适配者</li><li>被适配者的任何子类也可以搭配适配器使用  </li><li>个人觉得使用适配器最大的好处是 <strong>不需要修改客户端以及被适配者的代码。</strong>  </li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>需要实现所有的方法去完成适配，如果目标非常大，那么工作量也比较大。  </li></ol><p>NOTE：之前提到的都是 <strong>对象适配器</strong>，另外还有一种叫做 <strong>类适配器</strong>，不过类适配器需要多重继承去实现(Adapter需要继承Target和Adaptee)，而不是组合的方式去实现。  </p><h3 id="适配器-装饰者-外观模式的不同："><a href="#适配器-装饰者-外观模式的不同：" class="headerlink" title="适配器 装饰者 外观模式的不同："></a>适配器 装饰者 外观模式的不同：</h3><p>适配器是：<strong>将一个接口转成另一个接口</strong><br>装饰者是：<strong>不改变接口，但加入新的责任</strong><br>外观模式是：<strong>让接口更简单</strong>  </p><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ol><li>当需要使用一个现有的类而其接口并不符合你的需要时，就使用适配器。  </li><li>适配器改变接口以符合客户的期望。  </li><li>实现一个适配器可能需要一番功夫，也可能不费功夫，视目标接口的大小与复杂度而定。  </li><li>适配器模式有两种形式：对象适配器和类适配器。类适配器需要用到多重继承。  </li><li>适配器将一个对象包装起来以改变其接口；装饰者将一个对象包装起来以增加新的行为和责任；而外观将一群对象『包装』起来以简化其接口。  </li></ol><h2 id="See-also"><a href="#See-also" class="headerlink" title="See also"></a>See also</h2><p><a href="https://en.wikipedia.org/wiki/Adapter_pattern" target="_blank" rel="noopener">Adapter pattern</a><br><a href="http://javadesign-patterns.blogspot.com/p/adapter-pattern-example.html" target="_blank" rel="noopener">Adapter Design Pattern Example</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令模式</title>
      <link href="/blog/78134e07.html"/>
      <url>/blog/78134e07.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式专题系列: <a href="http://yifeiyuan.me/2016/07/20/design-patterns/">设计模式</a></p></blockquote><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>命令模式: <strong>将请求封装成对象，这可以让你使用不同的请求、队列，或者日志请求来参数化其他对象。命令模式也可以支持撤销操作。</strong>    </p><ol><li>将请求封装成对象，比如 <code>Runnable</code>  </li><li>将 <strong>发出请求的对象</strong> 和 <strong>接受与执行这些请求的对象</strong> 分隔开来。  </li></ol><p><img src="http://ww3.sinaimg.cn/large/98900c07jw1f60h04snyqj21540pqwke.jpg" alt="类图"></p><p>一些应用：日程安排、线程池、工作队列等。  </p><a id="more"></a><p>感觉Android中的 <code>Handler</code> 相关也可以算是：把命令(Runnable对象) <code>post(r)</code> 到 MessageQueue 里，Looper再取出来处理~，<br>不需要管Runnable里做的到底什么操作，只要调用它的 <code>run()</code> 方法就行了。</p><p>Java代码示例：  </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The Command interface */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Command</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">execute</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** The Invoker class */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Switch</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Command&gt; history = <span class="keyword">new</span> ArrayList&lt;Command&gt;();</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">storeAndExecute</span>(<span class="params">Command cmd</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.history.<span class="keyword">add</span>(cmd); <span class="comment">// optional</span></span><br><span class="line">      cmd.execute();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** The Receiver class */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Light</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOn</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">"The light is on"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOff</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">"The light is off"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** The Command for turning on the light - ConcreteCommand #1 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlipUpCommand</span> <span class="title">implements</span> <span class="title">Command</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Light theLight;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">FlipUpCommand</span>(<span class="params">Light light</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.theLight = light;</span><br><span class="line">   &#125;</span><br><span class="line">   @Override    <span class="comment">// Command</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      theLight.turnOn();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** The Command for turning off the light - ConcreteCommand #2 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlipDownCommand</span> <span class="title">implements</span> <span class="title">Command</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Light theLight;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">FlipDownCommand</span>(<span class="params">Light light</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.theLight = light;</span><br><span class="line">   &#125;</span><br><span class="line">   @Override    <span class="comment">// Command</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      theLight.turnOff();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* The test class or client */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PressSwitch</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</span><br><span class="line">      <span class="comment">// Check number of arguments</span></span><br><span class="line">      <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">         System.err.println(<span class="string">"Argument \"ON\" or \"OFF\" is required."</span>);</span><br><span class="line">         System.exit(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Light lamp = <span class="keyword">new</span> Light();</span><br><span class="line">      Command switchUp = <span class="keyword">new</span> FlipUpCommand(lamp);</span><br><span class="line">      Command switchDown = <span class="keyword">new</span> FlipDownCommand(lamp);</span><br><span class="line">      Switch mySwitch = <span class="keyword">new</span> Switch();</span><br><span class="line">      <span class="keyword">switch</span>(args[<span class="number">0</span>]) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">"ON"</span>:</span><br><span class="line">            mySwitch.storeAndExecute(switchUp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">"OFF"</span>:</span><br><span class="line">            mySwitch.storeAndExecute(switchDown);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            System.err.println(<span class="string">"Argument \"ON\" or \"OFF\" is required."</span>);</span><br><span class="line">            System.exit(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宏命令，可以存储一系列命令，一起执行，达到一个『按钮』实现多个功能的目的。  </p><p>可以用个List来保存历史命令，来实现撤销功能。  </p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>命令模式将发出请求的对象和执行请求的对象解耦</li><li>在被解耦的两者之间是通过命令对象进行沟通的。命令对象封装了接受者和一个或一组动作。</li><li>调用者通过命令对象的 <code>execute()</code> 发出请求，这会使得接受者的动作被调用。</li><li>调用者可以接受命令当做参数，甚至在运行时动态地进行。  </li><li>命令可以支持撤销，做法是实现一个 <code>undo()</code>方法来回到 <code>execute()</code>被执行前的状态。</li><li>宏命令是命令的一种简单的延伸，允许调用多个命令。红方法也可以支持撤销。</li><li>实际操作时，很常见使用『聪明』命令对象，也就是直接实现了请求，而不是将工作委托给接受者。</li><li>命令也可以用来实现日志和事务系统。</li></ol><h2 id="See-also"><a href="#See-also" class="headerlink" title="See also"></a>See also</h2><p><a href="https://en.wikipedia.org/wiki/Command_pattern" target="_blank" rel="noopener">Command pattern</a><br><a href="http://javadesign-patterns.blogspot.com/p/co.html" target="_blank" rel="noopener">Command Design Pattern Example</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计原则</title>
      <link href="/blog/a151c9f2.html"/>
      <url>/blog/a151c9f2.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式专题系列: <a href="http://yifeiyuan.me/2016/07/20/design-patterns/">设计模式</a></p></blockquote><p>持续更新中</p><h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p>设计模式中的设计原则</p><h2 id="封装变化"><a href="#封装变化" class="headerlink" title="封装变化"></a>封装变化</h2><p><strong>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</strong>  </p><p>或者说是：<strong>把变化的部分取出来并封装起来，以便以后可以轻易地改动或扩充此部分，而不影响不需要变化的其他部分。</strong>    </p><p>优势：  </p><p><strong>代码变化引起的不经意后果变少，系统变得更有弹性</strong>  </p><a id="more"></a><h2 id="针对接口编程"><a href="#针对接口编程" class="headerlink" title="针对接口编程"></a>针对接口编程</h2><p><strong>针对接口编程，而不是针对实现编程</strong>    </p><p>将行为放在不同的类中，此类专门提供某行为接口的实现。  </p><p><strong>针对接口编程</strong>的真正意思是：<strong>针对超类型编程</strong>  </p><p>利用多态，程序可以针对超类型编程，执行时会根据实际状况执行到真正的行为，不会被绑死在超类型的行为上。  </p><p>针对接口编程具体的做法：变量的声明类型应该是超类型，然后在运行时才确定。</p><p>比如：  </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Animal animal</span> = new Dog();</span><br></pre></td></tr></table></figure><p>另外有个概念叫 <strong>依赖于实现</strong>：  </p><p>行为来自超类的具体实现，或是继承某个接口并由子类自行实现而来。<br>依赖于实现的 <strong>缺点</strong>：被实现绑的死死的，难于修改行为。  </p><p>所以不推荐依赖于实现编程。  </p><h2 id="多用组合，少用继承"><a href="#多用组合，少用继承" class="headerlink" title="多用组合，少用继承"></a>多用组合，少用继承</h2><p>优势：  </p><ol><li>弹性大</li><li>可以在运行时动态改变行为  </li></ol><h2 id="松耦合"><a href="#松耦合" class="headerlink" title="松耦合"></a>松耦合</h2><p>解耦（decouple）</p><p>优势：  </p><p>当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。  </p><p>松耦合的设计之所以能让我们建立 <strong>有弹性的OO系统</strong>，能够应对变化，是因为 <strong>对象之间的相互依赖降到了最低</strong>。  </p><p>为了交互对象之间的松耦合设计而努力！！</p><h2 id="开放关闭原则"><a href="#开放关闭原则" class="headerlink" title="开放关闭原则"></a>开放关闭原则</h2><p>类应该 <strong>对扩展开放，对修改关闭。</strong>  </p><p>目标：  </p><p>允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为。</p><p>好处:  </p><p>具有弹性可以应对改变，可以接受新的功能来应对改变的需求。  </p><h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p><strong>要依赖抽象，不要依赖具体类</strong>。  </p><p>高层以及低层模块都要依赖于抽象。</p><p>（A使用B，A就是高层 B就是低层）  </p><p>指导方针：  </p><ol><li>变量不可以持有具体类的引用。（使用new就会持有，用工厂避开）</li><li>不要让类派生自具体类。（如果不这么做，那就依赖具体类了）</li><li>不要覆盖基类中已实现的方法。（说明不是个好基类）</li></ol><p>依赖原则教导我们 <strong>尽量避免使用具体类</strong>，更加注重如何在设计中避免依赖。    </p><h2 id="最少知识原则-Least-Knowledge"><a href="#最少知识原则-Least-Knowledge" class="headerlink" title="最少知识原则(Least Knowledge)"></a>最少知识原则(Least Knowledge)</h2><p><strong>只和你的密友谈话</strong></p><p>当设计一个系统，不管任何对象，都需要注意它所交互的类有哪些，并注意它和这些类是如何交互的。<br>该原则需要我们在设计中，不要让太多的类耦合在一起，免得修改系统中一部分，会影响到气他部分。  如果许多类之间相互依赖，那么这个系统会变成一个易碎的系统，它需要花许多成本维护，也会因为太复杂而不容易被其他人了解。  </p><p>指导方针：<em>就任何对象而言，在该对象的方法内，我们只应该调用属于以下范围的方法：</em>   </p><ol><li>该对象本身</li><li>被当做方法的参数而传递进来的对象</li><li>此方法所创建或实例化的任何对象</li><li>对象的任何组件(成员变量)</li></ol><p><img src="http://ww4.sinaimg.cn/large/98900c07jw1f61d5rsy1kj20ht0dmjsu.jpg" alt="方针示意图"></p><p>NOTE：另外有个原则叫 <code>Law of Demeter</code> 跟该原则意思相同，但是该原则的称呼更为恰当。  </p><p>最少知识原则的缺点：会出现更多的『包装』，可能会导致 <strong>复杂度和开发时间的增加，并降低运行时的性能。</strong>  </p><h2 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h2><p><strong>别调用(打电话给)我们，我们会调用(打电话给)你。</strong>  </p><p>好莱坞原则 可以给我们一种防止『依赖腐败』的方法。</p><p>当高层组件依赖地层组件，而地层组件又依赖高层组件，而高层组件又依赖边侧组件，而边侧组件又依然低层组件时，依赖腐败就发生了。（好恐怖- -）  </p><p>NOTE：要尽量做到避免环状依赖。  </p><p>在该原则的指导下，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎么样使用这些低层组件。(换句话说就是，高层对待低层组件的方式是『别调用我们，我们会调用你』)  </p><p>NOTE：当然，并不是绝对的不能调用。  </p><p>实际应用于：<br>工厂方法，观察者，模板方法等模式  </p><h2 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h2><p><strong>一个类应该只有一个引起变化的原因</strong>  </p><p>告诉我们：尽量让每个类保持单一责任。  </p><p>内聚(<code>cohesion</code>)，用来度量一个类或模块紧密地达到单一目的或责任。  </p><p>当一个模块或一个类被设计成只支持一组相关的功能时，我们说它具有高内聚；反之，当被设计成支持一组不相关的功能时，我们说它具有低内聚。  </p><p>遵守这个原则容易具有高的凝聚力，更容易维护。  </p><p>难点：区分责任。  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/blog/72e3b671.html"/>
      <url>/blog/72e3b671.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式专题系列: <a href="http://yifeiyuan.me/2016/07/20/design-patterns/">设计模式</a></p></blockquote><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p><strong>定义了算法族，分别封装起来，让它们之间可以相互转换，此模式让算法的变化独立于使用算法的客户。</strong>  </p><p>其实就是利用多态的特性，使用面向接口的编程方式来做。  </p><a id="more"></a><p>特点：  </p><ol><li>定义算法族</li><li>分别封装</li><li>算法可以相互替代</li><li>可以动态切换算法</li></ol><p>策略模式通常通过定义 一个<code>Interface</code>，再写不同的实现类去实现的。  </p><p>体现的设计原则： 开闭原则，针对接口编程  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出设计模式</title>
      <link href="/blog/807ad539.html"/>
      <url>/blog/807ad539.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>于 2016.8.3 更新</p></blockquote><p>今年的目标里有整理设计模式知识点,一直没有整理,最近效率还可以,希望能整理完.  </p><p>有部分内容(面向对象基础,设计原则)是一年多以前写的,那时候还非常稚嫩,还需慢慢加深理解。  </p><p>NOTE:<strong>主要目的是给自己看,如果你想学设计模式,推荐看书,后面资料有给出.</strong>  </p><p>笔记目录: </p><ul><li><a href="http://yifeiyuan.me/2015/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%89%8D%E4%BC%A0%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/">面向对象基础-2015</a></li><li><a href="http://yifeiyuan.me/2015/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BC%80%E7%AF%87%E4%B9%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">设计原则(旧-2015版)</a></li><li><a href="http://yifeiyuan.me/2016/07/21/Design-Principles/">设计原则(新-2016版)</a></li><li><a href="http://yifeiyuan.me/2016/07/20/learn-uml/">UML 类图知识</a></li><li><a href="http://yifeiyuan.me/2016/07/21/Strategy/">策略模式</a></li><li><a href="http://yifeiyuan.me/2016/07/26/Observer/">观察这模式</a></li><li><a href="http://yifeiyuan.me/2016/07/25/Decorator/">装饰者模式</a></li><li><a href="http://yifeiyuan.me/2016/07/25/Factory/">工厂模式</a></li><li><a href="http://yifeiyuan.me/2015/09/10/%E5%90%AC%E8%AF%B4%E6%AF%8F%E4%B8%AA%E4%BA%BA%E9%83%BD%E4%BC%9A%E5%86%99%E5%8D%95%E4%BE%8B/">单例模式</a></li><li><a href="http://yifeiyuan.me/2016/07/21/Command/">命令模式</a></li><li><a href="http://yifeiyuan.me/2016/07/21/Adapter/">适配器模式</a></li><li><a href="http://yifeiyuan.me/2016/07/25/Facade/">外观模式</a></li><li><a href="http://yifeiyuan.me/2016/07/26/Template-Method/">模板方法模式</a></li><li><a href="http://yifeiyuan.me/2016/07/26/Iterator/">迭代器模式</a></li><li><a href="http://yifeiyuan.me/2016/07/21/Composite/">组合模式</a></li><li><a href="http://yifeiyuan.me/2016/07/26/State/">状态模式</a></li><li><a href="http://yifeiyuan.me/2016/07/26/Proxy/">代理模式</a></li><li><a href="http://yifeiyuan.me/2016/07/25/Compound/">复合模式</a></li><li><a href="http://yifeiyuan.me/2016/08/01/Bridge/">桥接模式</a>  </li><li><a href="http://yifeiyuan.me/2016/08/01/Builder/">生成器模式</a>  </li><li><a href="http://yifeiyuan.me/2016/08/01/Chain-of-Responsibility/">责任链模式</a>  </li><li><a href="http://yifeiyuan.me/2016/08/01/Flyweight/">蝇量模式</a>  </li><li><a href="http://yifeiyuan.me/2016/08/01/Interpreter/">解释器模式</a>  </li><li><a href="http://yifeiyuan.me/2016/08/02/Mediator/">中介者模式</a>  </li><li><a href="http://yifeiyuan.me/2016/08/03/Memento/">备忘录模式</a>  </li><li><a href="http://yifeiyuan.me/2016/08/03/Prototype/">原型模式</a>  </li><li><a href="http://yifeiyuan.me/2016/08/03/Visitor/">访问者模式</a>  </li></ul><p>需要注意的是，从桥接模式开始,&lt;&lt;深入浅出设计模式&gt;&gt;一书对它们的讲解就非常少了（大概每个设计模式就只有两页的篇幅）,需要自己再买其他书看,学习.</p><p>另外这些读书笔记我在Github放了一份,跟其他书籍的读书笔记一起做成了一份Gitbook,阅读体验更好一些!—&gt;<a href="https://github.com/AlanCheen/ReadingNotes" target="_blank" rel="noopener">ReadingNotes</a></p><p><img src="http://ww2.sinaimg.cn/large/98900c07jw1f66bcqb59jj20q10ct0vf.jpg" alt="设计模式整理"></p><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><ol><li>不需要严格遵照设计模式，可以适当调整以符合需求(模式是死的，人是活的)</li><li>保持简单（KISS原则）</li><li>设计、重构的时候考虑设计模式</li><li>现在不需要，就别做 </li><li>可能一直都不需要设计模式（helloworld就不要扯什么设计模式了）</li><li>过度使用设计模式可能导致代码被过度工程化。应该总是用最简单的解决方案完成工作，并在真正需要模式的地方才使用它。 </li></ol><p>实际上在开发过程中，自己已经不知不觉使用了不少设计模式，设计模式从实践中来，也特别需要在实践中去体会，不遇到困难，就不能真切深入的理解它。</p><p>有句话说的好，『没写过一万行代码，就别提什么设计模式』  </p><p>设计模式只停止于阅读是远远不够的，还需努力！  </p><h2 id="设计模式推荐资料"><a href="#设计模式推荐资料" class="headerlink" title="设计模式推荐资料"></a>设计模式推荐资料</h2><p><a href="https://www.amazon.cn/Head-First%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%97%E9%87%8C%E6%9B%BC/dp/B0011FBU34/ref=sr_1_1?ie=UTF8&amp;qid=1469026679&amp;sr=8-1&amp;keywords=%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">HeadFirst设计模式</a><br><a href="https://www.amazon.cn/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%9B%E4%B9%A6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80-Erich-Gamma/dp/B001130JN8/ref=sr_1_1?ie=UTF8&amp;qid=1469026646&amp;sr=8-1&amp;keywords=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F+%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">设计模式：可复用面向对象软件的基础</a><br><a href="https://en.wikipedia.org/wiki/Design_Patterns" target="_blank" rel="noopener">wiki:Design Patterns</a><br><a href="https://www.amazon.cn/Android%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98-%E4%BD%95%E7%BA%A2%E8%BE%89/dp/B0176QDPUW/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1469026788&amp;sr=1-1&amp;keywords=android+%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98" target="_blank" rel="noopener">Android源码设计模式解析与实战</a><br><a href="https://www.amazon.cn/Sun-%E5%85%AC%E5%8F%B8%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6-Effective-Java%E4%B8%AD%E6%96%87%E7%89%88-Joshua-Bloch/dp/B001PTGR52/ref=pd_sim_14_3?ie=UTF8&amp;dpID=51bFt0sSAKL&amp;dpSrc=sims&amp;preST=_AC_UL160_SR121%2C160_&amp;psc=1&amp;refRID=2ZABEPEFGX2M1YM5HVZN" target="_blank" rel="noopener">EffectiveJava</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML类图知识整理</title>
      <link href="/blog/7c1aa82f.html"/>
      <url>/blog/7c1aa82f.html</url>
      
        <content type="html"><![CDATA[<h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><p>UML，进阶必备专业技能，看不懂UML就会看不懂那些优秀的资料。   </p><p>这里简单整理  </p><h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><h3 id="泛化关系-generalization"><a href="#泛化关系-generalization" class="headerlink" title="泛化关系(generalization)"></a>泛化关系(generalization)</h3><ol><li>泛化（generalize）: 一条<strong>带空心箭头</strong>的线表示  </li><li>实现（realize） : 一条<strong>带空心箭头的虚线</strong>表示</li></ol><a id="more"></a><p><strong>泛化</strong>在Java中表现为<strong>继承（extends）</strong> ，<code>is-a</code>的关系  </p><p><strong>实现</strong>在Android中表现为<code>implements</code> 接口，或者<code>extends</code>抽象类   </p><h3 id="依赖关系-dependency"><a href="#依赖关系-dependency" class="headerlink" title="依赖关系(dependency)"></a>依赖关系(dependency)</h3><p>用一条<strong>带箭头的虚线</strong>表示；箭头的指向为调用关系    </p><p>简单来说，<strong>类A用到了类B，就可以说A依赖于B</strong>   </p><p>依赖关系是一种临时性的偶然性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化  </p><p>代码中的表现：比如方法的入参，构造方法的参数</p><h3 id="关联关系-association"><a href="#关联关系-association" class="headerlink" title="关联关系(association)"></a>关联关系(association)</h3><p>用<strong>一条直线表示</strong>  </p><p>它描述不同类的对象之间的结构关系；体现的是两个类、或者类与接口之间语义级别的一种<strong>强依赖关系</strong>  </p><p>代码中的表现：关联对象通常是以<strong>成员变量的形式</strong>实现的  </p><h3 id="聚合关系（aggregation）"><a href="#聚合关系（aggregation）" class="headerlink" title="聚合关系（aggregation）"></a>聚合关系（aggregation）</h3><p><strong>一条带空心菱形箭头的直线表示</strong>  </p><p>聚合关系是关联关系的特例，它用于表示实体对象之间的关系，表示<strong>整体由部分构成的语义</strong>；是<code>has-a</code>的关系；</p><p>例如一个部门由多个员工组成；</p><p>与组合关系不同的是，<strong>整体和部分不是强依赖的</strong>，<strong>整体与部分之间是可分离的</strong>，即使整体不存在了，部分仍然存在；</p><p>例如， 部门撤销了，人员不会消失，他们依然存在  </p><h3 id="组合关系-composition"><a href="#组合关系-composition" class="headerlink" title="组合关系(composition)"></a>组合关系(composition)</h3><p>用一条<strong>带实心菱形箭头直线</strong>表示   </p><p>组合关系是一种<strong>强依赖的特殊聚合关系</strong>，是<code>contains-a</code>的关系，比聚合更强，也称为<strong>强聚合</strong>，如果<strong>整体不存在了，则部分也不存在</strong></p><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ol><li>聚合跟组合其实都属于关联</li><li>关系强度：组合&gt;聚合&gt;关联&gt;依赖</li></ol><h2 id="类的方法与属性"><a href="#类的方法与属性" class="headerlink" title="类的方法与属性"></a>类的方法与属性</h2><p>类可以拥有多个方法和属性 </p><p>属性的表达方式：<strong>可见性  名称:类型 [ = 缺省值 ]</strong><br>方法的表达方式：<strong>可见性  名称(参数列表) [ : 返回类型]</strong>  </p><p>可见性：  </p><ul><li><code>+</code> public  </li><li><code>-</code> private  </li><li><code>#</code> protected  </li><li><code>~</code> package  </li></ul><p><img src="http://ww2.sinaimg.cn/large/98900c07jw1f5z65eylbij20cx068wev.jpg" alt="示例"></p><p>另外：<strong>UML图中的斜体表示抽象</strong></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="http://ww2.sinaimg.cn/large/98900c07jw1f5z1qwizmuj20j3095q4f.jpg" alt=""></p><p>释义：<br><code>ViewGroup</code>是一个<code>View</code>，也是一个<code>ViewParent</code>，依赖于<code>MotionEvent</code>（在<code>onTouch（MotionEvent）</code>等方法）</p><p><img src="http://ww1.sinaimg.cn/large/98900c07jw1f5z1rdtd4wj20dt07edgk.jpg" alt="">  </p><p>释义：  </p><p>员工与工号相关联，员工聚合成部门，部门组成公司。</p><p>部门解散了员工依然存在（所以是聚合），而公司倒闭，部门也就不存在了（所以是组成）。  </p><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html#id1" target="_blank" rel="noopener">看懂UML类图和时序图</a><br><a href="http://www.cnblogs.com/olvo/archive/2012/05/03/2481014.html" target="_blank" rel="noopener">UML类图关系</a><br><a href="http://blog.csdn.net/lovelion/article/details/7838679" target="_blank" rel="noopener"> 深入浅出UML类图</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android程序猿学Css(中)</title>
      <link href="/blog/aec60f5b.html"/>
      <url>/blog/aec60f5b.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇<a href="http://yifeiyuan.me/2016/07/06/learn-css/">Android程序猿学Css(上)</a><br><a id="more"></a></p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一步一步深入理解CoordinatorLayout</title>
      <link href="/blog/8378fb7a.html"/>
      <url>/blog/8378fb7a.html</url>
      
        <content type="html"><![CDATA[<h1 id="一步一步深入理解CoordinatorLayout"><a href="#一步一步深入理解CoordinatorLayout" class="headerlink" title="一步一步深入理解CoordinatorLayout"></a>一步一步深入理解<a href="https://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.html" target="_blank" rel="noopener">CoordinatorLayout</a></h1><p>Google推出Design库已经一年了，国内也出过一些文章关于CoordinatorLayout，但是都是教你怎么使用用，或者简单的自定义一些Behavior,并没有一篇文章深入去了解它的原理。  </p><p>刚好这两天为了实现一个UI效果，看了<code>CoordinatorLayout</code>（后面<em>简称Col</em>）的官方文档以及源码，搞懂了它的原理，于是想着拿出来分享，特在此记录分享如何一步一步深入理解Col，希望可以填补这个空缺。    </p><p>补充说明：</p><ol><li>Col等源码基于<code>23.2.1</code>版本   </li><li>本文侧重在于Col与Behavior之间的交互，侧重于原理，并选择要点进行讲解，所以可能会有一些点被我忽略，不过看完后我相信你对Col会有更深一层的了解。      </li></ol><h2 id="初步了解"><a href="#初步了解" class="headerlink" title="初步了解"></a>初步了解</h2><p>学习最好的习惯就是看官方文档，来看看Col的定义以及官网的介绍：  </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoordinatorLayout</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">ViewGroup</span> <span class="keyword">implements</span> <span class="title">NestedScrollingParent</span></span></span><br></pre></td></tr></table></figure><p>官网介绍:    </p><blockquote><p>CoordinatorLayout is a super-powered FrameLayout.<br>CoordinatorLayout is intended for two primary use cases:</p><ol><li>As a top-level application decor or chrome layout</li><li>As a container for a specific interaction with one or more child views</li></ol></blockquote><p>从定义可以看到Col继承自<code>ViewGroup</code>，并且它被设计成一个<code>top-level</code>的根布局，它本身只是一个ViewGroup，实现了<code>NestedScrollingParent</code>接口，看似非常普通，<br>但是说<code>CoordinatorLayout</code>是Design库<strong>最为重要的控件</strong>也不为过。</p><p>这里额外需要注意的是:   </p><ol><li><strong>由于Col只实现了<code>NestedScrollingParent</code>，所以当Col嵌套（作为一个子View）的时候会得不到你想要的效果，需要自己写一个Col去实现<code>NestedScrollingChild</code>接口！</strong>    </li><li>没有实现<code>NestedScrollingChild</code>接口的子View如：<code>ListView</code>，<code>ScrollView</code>在5.0以下版本跟Col是配合不了的需要使用<code>RecyclerView</code>，<code>NestedScrollView</code>才行  </li></ol><p><strong>why？</strong>它<code>super-powered</code>在哪里呢？    </p><p>Col最为重要的作用是：<strong>提供给子View实现各种交互的极大便利</strong><br>直观的表现是我们可以使用Col非常方便地实现很多交互效果,具体效果可以看<a href="https://github.com/chrisbanes/cheesesquare" target="_blank" rel="noopener">cheesesquare</a>这个项目。  </p><p>要知道，在没有Col的日子要实现简单的交互也不是件容易的事，需要通过各种回调/Event，相互回调，相互通知，甚至相互持有引用，复杂而且难以复用，但是现在有了Col，一切都变得方便了~  </p><p> <strong>How？它是怎么做到的呢？</strong><br>说到这里，不得不提到Col的静态内部类—&gt;Behavior<br>接下去来了解一下它,老司机要开车了，快上车~  </p><h2 id="拦截一切的Behavior"><a href="#拦截一切的Behavior" class="headerlink" title="拦截一切的Behavior"></a>拦截一切的<a href="https://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html" target="_blank" rel="noopener">Behavior</a></h2><p>Behavior是什么，有什么作用？</p><pre><code>Interaction behavior plugin for child views of CoordinatorLayout.A Behavior implements one or more interactions that a user can take on a child view. These interactions may include drags, swipes, flings, or any other gestures.</code></pre><p>简单说，Behavior可以负责所有的交互甚至测量以及布局。</p><p>其实官网资料说得挺含蓄的，官方在Medium有一篇文章，叫:<a href="https://medium.com/google-developers/intercepting-everything-with-coordinatorlayout-behaviors-8c6adc140c26#.p1v2t3rxo" target="_blank" rel="noopener">Intercepting everything with CoordinatorLayout Behaviors</a>，私以为用这个标题来形容Behavior，再合适不过，<strong>intercepting-everything！</strong>（这篇文章讲得很好也很全面，<strong>极力推荐阅读</strong>）  </p><p>拦截一切！！迫不及待进一步了解！！  </p><h3 id="深入了解"><a href="#深入了解" class="headerlink" title="深入了解"></a>深入了解</h3><h4 id="如何实例化指定Behavior"><a href="#如何实例化指定Behavior" class="headerlink" title="如何实例化指定Behavior"></a>如何实例化指定Behavior</h4><ol><li>通过构造方法实例,并在代码中设置到LayoutParams里</li><li>Xml里指定，比如<code>app:app:layout_behavior=&quot;me.yifeiyuan.demo.HeaderBehavior&quot;</code></li><li>通过<code>DefaultBehavior</code>注解指定，比如<a href="mailto:`@CoordinatorLayout.DefaultBehavior" target="_blank" rel="noopener">`@CoordinatorLayout.DefaultBehavior</a>(AppBarLayout.Behavior.class)`</li></ol><p>第一种方式很简单，不多说，这里针对其他两种方式讲解一下，有一些注意点我们需要知道：    </p><h6 id="Xml方式"><a href="#Xml方式" class="headerlink" title="Xml方式"></a>Xml方式</h6><p>先撇一下<code>Behavior</code>的定义以及其构造方法如下：    </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义 V 为泛型，可指定针对哪种类型的View</span></span><br><span class="line">public static <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Behavior&lt;V</span> <span class="keyword">extends</span> <span class="title">View&gt;</span></span></span><br><span class="line"><span class="class"><span class="title">//默认的构造方法</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">Behavior</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// xml里使用</span></span><br><span class="line">public <span class="type">Behavior</span>(<span class="type">Context</span> context, <span class="type">AttributeSet</span> attrs) &#123;&#125;</span><br></pre></td></tr></table></figure><p>当我们在Xml里指定的时候，在<code>LayoutParams</code>的构造方法里会去调用<code>parseBehavior</code>这个方法，<code>parseBehavior</code>关键代码如下(不贴代码不行了，已尽量精简):  </p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Behavior parseBehavior(Context context, AttributeSet attrs, <span class="keyword">String</span> name) &#123;</span><br><span class="line">    <span class="comment">//...省略了很多代码，只留下关键的部分</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//获取构造方法</span></span><br><span class="line">        Map&lt;<span class="keyword">String</span>, Constructor&lt;Behavior&gt;&gt; constructors = sConstructors.<span class="keyword">get</span>();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 注意这一行，这里传递了attrs，所以我们必须要有第二个构造方法！！！</span></span><br><span class="line">        <span class="keyword">return</span> c.<span class="keyword">new</span><span class="type">Instance</span>(context, attrs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//否则会报错 crash</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"Could not inflate Behavior subclass "</span> + fullName, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们需要注意的是: <strong>如果要在xml里使用Behavior 那么第二个构造方法必不可少，所以我们自定义Behavior的时候需要注意;另外你在xml定义的属性会传递到第二个构造方法里去，可以获取你在xml里配置的属性，非常方便，可以说考虑还是非常周到的</strong>  </p><h6 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h6><p>第三种通过注解的方式，又是在什么时候，怎么去实例化的呢？  </p><p>在Col中的<code>onMeasure</code>中会去调用<code>prepareChildren</code>方法，而<code>prepareChildren</code>方法又调用了一个叫<code>getResolvedLayoutParams</code>的方法如下:  </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LayoutParams <span class="title">getResolvedLayoutParams</span>(<span class="params">View child</span>)</span> &#123;</span><br><span class="line">    final LayoutParams result = (LayoutParams) child.getLayoutParams();</span><br><span class="line">    <span class="comment">//如果没有解析过 则去解析</span></span><br><span class="line">    <span class="keyword">if</span> (!result.mBehaviorResolved) &#123;</span><br><span class="line">        Class&lt;?&gt; childClass = child.getClass();</span><br><span class="line">        DefaultBehavior defaultBehavior = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (childClass != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (defaultBehavior = childClass.getAnnotation(DefaultBehavior.class)) == <span class="literal">null</span>) &#123;<span class="comment">//如果 有DefaultBehavior这个注解</span></span><br><span class="line">            childClass = childClass.getSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (defaultBehavior != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//实例化Behavior并把这个Behavior赋值给result</span></span><br><span class="line">                result.setBehavior(defaultBehavior.<span class="keyword">value</span>().newInstance());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"Default behavior class "</span> + defaultBehavior.<span class="keyword">value</span>().getName() +</span><br><span class="line">                        <span class="string">" could not be instantiated. Did you forget a default constructor?"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.mBehaviorResolved = <span class="literal">true</span>;<span class="comment">//标记已经解析过  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以注解方式是在<code>onMeasure</code>中通过<code>getResolvedLayoutParams</code>去实例化的。  </p><p>另外还需要知道的是，<code>Behavior</code>是Col.LayoutParams的成员变量，那么也就是说只有当你的<code>Behavior</code>设置给Col的 <strong>直接子View</strong> 才会有效果，这点要记住，不然徒劳无功。(Col的子View的子View就不要给它设置Behavior啦，没效果的)    </p><p>以上需要牢记，不过仅仅知道这些显然是不够的！至少我不会到这里就停~    </p><p>接下去继续深入阅读Behavior的源码一探究竟（一言不合就看源码）  </p><p>在我阅读了<code>Behavior</code>的源码后，我觉得非常有必要先搞清楚几个非常重要的概念。  </p><h4 id="child与dependency"><a href="#child与dependency" class="headerlink" title="child与dependency"></a>child与dependency</h4><ol><li><strong>child</strong>，<em>the child view associated with this Behavior</em><br>它是一个View，<strong>是该Behavior的关联对象，也即Behavior所要操作的对象</strong>    </li><li><strong>dependency</strong>，也是个View，是 <strong>child的依赖对象，同时也是Behavior对child进行操作的根据</strong>  </li></ol><p>弄清楚这些个概念后看源码会比较简单了，<code>Behavior</code>除了构造方法外，有23个方法，限于篇幅与精力，我挑选几个最重要的方法来讲解，当然我不会死板的一个一个毫无逻辑地解释过去。  </p><h4 id="那些不能不懂的方法"><a href="#那些不能不懂的方法" class="headerlink" title="那些不能不懂的方法"></a>那些不能不懂的方法</h4><h5 id="layoutDependsOn"><a href="#layoutDependsOn" class="headerlink" title="layoutDependsOn"></a>layoutDependsOn</h5><p>之前提到了child与dependency有着依赖关系，那么问题来了： <strong>这个依赖关系是如何建立的？</strong>  </p><p>在Behavior类中有个方法：  </p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> layoutDependsOn(CoordinatorLayout  <span class="keyword">parent</span>, V child, View dependency)</span><br></pre></td></tr></table></figure><p>它会被<code>Behavior</code>的<code>LayoutParams</code>的<code>dependsOn</code>方法调用：  </p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">boolean</span> dependsOn(CoordinatorLayout <span class="keyword">parent</span>, View child, View dependency) &#123;</span><br><span class="line">    <span class="keyword">return</span> dependency == mAnchorDirectChild</span><br><span class="line">            || (mBehavior != <span class="built_in">null</span> &amp;&amp; mBehavior.layoutDependsOn(<span class="keyword">parent</span>, child, dependency));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而LayoutParams的<code>dependsOn</code>方法会被Col调用，<code>dependsOn</code>方法就是用来确定依赖关系的。  </p><p>所以，最简单的确定依赖关系的方法是重写<code>layoutDependsOn</code>方法，并在一定条件下返回<code>true</code>即可确立依赖关系。  </p><p>那为什么说一定条件呢？  </p><p>比如FAB依赖于<code>SnackBar</code>，是因为它在<code>SnackBar</code>出现以及消失的时候需要改变自身的位置，所以FAB的<code>layoutDependsOn</code>方法中对<code>Snackbar.SnackbarLayout</code>返回了true，而没有依赖其他的控件：    </p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">layoutDependsOn</span><span class="params">(CoordinatorLayout parent,FloatingActionButton child, View dependency)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We're dependent on all SnackbarLayouts (if enabled)</span></span><br><span class="line">    <span class="keyword">return</span> SNACKBAR_BEHAVIOR_ENABLED &amp;&amp; dependency <span class="keyword">instanceof</span> Snackbar.SnackbarLayout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外需要注意的是：<strong>当确定依赖关系后，当dependency被布局（或测量）后child会紧接着被布局（或测量）</strong>，Col会无视子view的顺序(原因是Col内有个Comparator<code>mLayoutDependencyComparator</code>会按照依赖关系对所有的子View进行排序),这会影响它们的测量以及布局顺序   </p><p>可以说<code>layoutDependsOn</code>方法是自定义<code>Behavior</code>最为重要的方法  </p><h5 id="onDependentViewChanged"><a href="#onDependentViewChanged" class="headerlink" title="onDependentViewChanged"></a>onDependentViewChanged</h5><p>建立起依赖关系之后呢？  </p><p>想要做交互，似乎还缺点什么，我想在dependency发生变化的时候改变一下child，我该如何知道这个改变的时机呢？  </p><p>其实不需要我们去主动获取去判断，Col跟Behavior已经帮我们做好了这一切，<code>onDependentViewChanged</code>登场。  </p><p><code>onDependentViewChanged</code>方法的定义：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Respond <span class="keyword">to</span> a change <span class="keyword">in</span> a child's dependent view</span><br><span class="line"> * This method <span class="keyword">is</span> called whenever a dependent view changes <span class="keyword">in</span> size <span class="keyword">or</span> position outside</span><br><span class="line"> * <span class="keyword">of</span> <span class="keyword">the</span> standard layout flow. A Behavior may use this method <span class="keyword">to</span> appropriately update</span><br><span class="line"> * <span class="keyword">the</span> child view <span class="keyword">in</span> response.</span><br><span class="line"> */</span><br><span class="line">public <span class="built_in">boolean</span> onDependentViewChanged(CoordinatorLayout parent, V child, View dependency) &#123;</span><br><span class="line"><span class="built_in">    return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说就是，当我们的<code>dependency</code>发生改变的时候，这个方法会调用，而我们在<code>onDependentViewChanged</code>方法里做出相应的改变，就能做出我们想要的交互效果了！  </p><p>可能你也注意到了<code>onDependentViewChanged</code>方法是有返回值的  </p><p>当我们改变了child的<code>size</code>或者<code>position</code>的时候我们需要返回true，差不多可以理解为 当我们的<code>dependency</code>发生了改变，同样的，child也需要发生改变，这个时候我们需要返回<code>true</code></p><p>提一下：<code>onDependentViewChanged</code>方法是在Col的<code>dispatchOnDependentViewChanged</code>里调用的</p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>除了以上两个特别重要的方法外，Nested系列方法也非常重要,如<code>onStartNestedScroll</code>和<code>onStopNestedScroll</code>来监听嵌套滚动的开始和结束，不过限于篇幅，想再另外开篇去写，这里就不写了    </p><p>另外还有<code>onMeasureChild</code>，<code>onLayoutChild</code>这个后面会讲。</p><h2 id="为什么Behavior可以拦截一切？"><a href="#为什么Behavior可以拦截一切？" class="headerlink" title="为什么Behavior可以拦截一切？"></a>为什么Behavior可以拦截一切？</h2><p>我们知道，ViewGroup的测量，布局，事件分发都是需要自己处理的，那么Col究竟给了<code>Behavior</code>什么特权，让它能够让它拦截一切？  </p><p>让我们挨个一点一点看下去  </p><h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h3><p>直接备注在源码里了，不多说啦！~  </p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> onMeasure(<span class="built_in">int</span> widthMeasureSpec, <span class="built_in">int</span> heightMeasureSpec) &#123;</span><br><span class="line">    <span class="comment">//之前已经提到过了 解析Behavior，并按依赖顺序重排子View顺序</span></span><br><span class="line">    prepareChildren();</span><br><span class="line">    <span class="comment">//用于addPreDrawListener，OnPreDrawListener里会调用 dispatchOnDependentViewChanged(false)</span></span><br><span class="line">    ensurePreDrawListener();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 计算 padding width height 处理 fitSystemWindow等</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">int</span> childCount = mDependencySortedChildren.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = mDependencySortedChildren.<span class="built_in">get</span>(i);</span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">        <span class="built_in">int</span> keylineWidthUsed = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//...处理keyline childWidthMeasureSpec等</span></span><br><span class="line">        <span class="keyword">final</span> Behavior b = lp.getBehavior();</span><br><span class="line">        <span class="comment">//当behavior的onMeasureChild方法返回true的时候，我们就可以拦截Col默认的measure</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span> || !b.onMeasureChild(<span class="keyword">this</span>, child, childWidthMeasureSpec, keylineWidthUsed,</span><br><span class="line">                childHeightMeasureSpec, <span class="number">0</span>)) &#123;</span><br><span class="line">            onMeasureChild(child, childWidthMeasureSpec, keylineWidthUsed,</span><br><span class="line">                    childHeightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">int</span> <span class="built_in">width</span> = ViewCompat.resolveSizeAndState(widthUsed, widthMeasureSpec,</span><br><span class="line">            childState &amp; ViewCompat.MEASURED_STATE_MASK);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">int</span> <span class="built_in">height</span> = ViewCompat.resolveSizeAndState(heightUsed, heightMeasureSpec,</span><br><span class="line">            childState &lt;&lt; ViewCompat.MEASURED_HEIGHT_STATE_SHIFT);</span><br><span class="line">    setMeasuredDimension(<span class="built_in">width</span>, <span class="built_in">height</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = ViewCompat.getLayoutDirection(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//mDependencySortedChildren 在 onMeasure里已经排过序了</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = mDependencySortedChildren.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = mDependencySortedChildren.get(i);</span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">        <span class="keyword">final</span> Behavior behavior = lp.getBehavior();</span><br><span class="line">        <span class="comment">//可以看到，当behavior.onLayoutChild()返回true的时候，就可以拦截掉Col的默认Layout操作！    </span></span><br><span class="line">        <span class="keyword">if</span> (behavior == <span class="keyword">null</span> || !behavior.onLayoutChild(<span class="keyword">this</span>, child, layoutDirection)) &#123;</span><br><span class="line">            onLayoutChild(child, layoutDirection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理其实跟<code>onMeasure</code>方法一样的。  </p><h3 id="onInterceptTouchEvent-amp-onTouchEvent"><a href="#onInterceptTouchEvent-amp-onTouchEvent" class="headerlink" title="onInterceptTouchEvent &amp; onTouchEvent"></a>onInterceptTouchEvent &amp; onTouchEvent</h3><p>在处理touch事件中，Col重写了<code>onInterceptTouchEvent</code>和<code>onTouchEvent</code>，另外，它们都调用了Col里定义的一个处理拦截的方法，<code>performIntercept</code>（关键代码都在这方法之中），就看一下它们的实现吧：  </p><p><code>onInterceptTouchEvent</code>的实现：  </p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    MotionEvent cancelEvent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</span><br><span class="line">    <span class="comment">// Make sure we reset in case we had missed a previous important event.</span></span><br><span class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="comment">//down的时候，跟大部分ViewGroup一样，需要重置一些状态以及变量，比如 mBehaviorTouchView</span></span><br><span class="line">        resetTouchBehaviors();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里看performIntercept TYPE_ON_INTERCEPT标记是 onInterceptTouchEvent</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted = performIntercept(ev, TYPE_ON_INTERCEPT);</span><br><span class="line">    <span class="keyword">if</span> (cancelEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cancelEvent.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当事件为UP和Cancel的时候去重置（同down）</span></span><br><span class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        resetTouchBehaviors();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intercepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onTouchEvent</code>的实现：  </p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> cancelSuper = <span class="keyword">false</span>;</span><br><span class="line">    MotionEvent cancelEvent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</span><br><span class="line">    <span class="comment">// mBehaviorTouchView不为null（代表之前有behavior处理了down事件） 或者 performIntercept返回true 那么事件就交给mBehaviorTouchView</span></span><br><span class="line">    <span class="keyword">if</span> (mBehaviorTouchView != <span class="keyword">null</span> || (cancelSuper = performIntercept(ev, TYPE_ON_TOUCH))) &#123;</span><br><span class="line">        <span class="comment">// Safe since performIntercept guarantees that</span></span><br><span class="line">        <span class="comment">// mBehaviorTouchView != null if it returns true</span></span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = (LayoutParams) mBehaviorTouchView.getLayoutParams();</span><br><span class="line">        <span class="keyword">final</span> Behavior b = lp.getBehavior();</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 交给 behavior去处理事件  </span></span><br><span class="line">            handled = b.onTouchEvent(<span class="keyword">this</span>, mBehaviorTouchView, ev);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Keep the super implementation correct</span></span><br><span class="line">    <span class="comment">// 省略调用默认实现 up&amp;cancel的时候重置状态</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，其实这两个方法做的事情并不多，其实都交给<code>performIntercept</code>方法去做处理了！  </p><p><code>performIntercept</code>的实现如下：  </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type 标记是intercept还是touch</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> performIntercept(MotionEvent ev, <span class="keyword">final</span> <span class="keyword">int</span> type) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> intercepted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> newBlock = <span class="literal">false</span>;</span><br><span class="line">    MotionEvent cancelEvent = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</span><br><span class="line">    <span class="keyword">final</span> List&lt;View&gt; topmostChildList = mTempList1;</span><br><span class="line">    <span class="comment">//按Z轴排序 原因很简单 让最上面的View先处理事件  </span></span><br><span class="line">    getTopSortedChildren(topmostChildList);</span><br><span class="line">    <span class="comment">// Let topmost child views inspect first</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = topmostChildList.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = topmostChildList.get(i);</span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">        <span class="keyword">final</span> Behavior b = lp.getBehavior();</span><br><span class="line">        <span class="comment">//当前事件已经被某个behavior拦截了（or newBlock），并且事件不为down，那么就发送一个 取消事件 给所有在拦截的behavior之后的behavior</span></span><br><span class="line">        <span class="keyword">if</span> ((intercepted || newBlock) &amp;&amp; action != MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">// Cancel all behaviors beneath the one that intercepted.</span></span><br><span class="line">            <span class="comment">// If the event is "down" then we don't have anything to cancel yet.</span></span><br><span class="line">            <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cancelEvent == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                    cancelEvent = MotionEvent.obtain(now, now,</span><br><span class="line">                            MotionEvent.ACTION_CANCEL, <span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">TYPE_ON_INTERCEPT:</span></span><br><span class="line">                        b.onInterceptTouchEvent(<span class="keyword">this</span>, child, cancelEvent);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">TYPE_ON_TOUCH:</span></span><br><span class="line">                        b.onTouchEvent(<span class="keyword">this</span>, child, cancelEvent);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果还没有被拦截，那么继续询问每个Behavior 是否要处理该事件</span></span><br><span class="line">        <span class="keyword">if</span> (!intercepted &amp;&amp; b != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">TYPE_ON_INTERCEPT:</span></span><br><span class="line">                    intercepted = b.onInterceptTouchEvent(<span class="keyword">this</span>, child, ev);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">TYPE_ON_TOUCH:</span></span><br><span class="line">                    intercepted = b.onTouchEvent(<span class="keyword">this</span>, child, ev);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果有behavior处理了当前的事件，那么把它赋值给mBehaviorTouchView,它其实跟ViewGroup源码中的mFirstTouchTarget作用是一样的</span></span><br><span class="line">            <span class="keyword">if</span> (intercepted) &#123;</span><br><span class="line">                mBehaviorTouchView = child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Don't keep going if we're not allowing interaction below this.</span></span><br><span class="line">        <span class="comment">// Setting newBlock will make sure we cancel the rest of the behaviors.</span></span><br><span class="line">        <span class="comment">// 是否拦截一切在它之后的交互 好暴力-0-</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> wasBlocking = lp.didBlockInteraction();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isBlocking = lp.isBlockingInteractionBelow(<span class="keyword">this</span>, child);</span><br><span class="line">        newBlock = isBlocking &amp;&amp; !wasBlocking;</span><br><span class="line">        <span class="keyword">if</span> (isBlocking &amp;&amp; !newBlock) &#123;</span><br><span class="line">            <span class="comment">// Stop here since we don't have anything more to cancel - we already did</span></span><br><span class="line">            <span class="comment">// when the behavior first started blocking things below this point.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    topmostChildList.clear();</span><br><span class="line">    <span class="keyword">return</span> intercepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析源码，可以知道，Col在关键的方法里把处理权优先交给了Behavior，所以才让Behavior拥有了拦截一切的能力，所以，原来是Col放任了Behavior！！~  </p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Col以及Behavior的重要的几个环节分析完毕，相信大家看完后能够对它们有更深层次的了解，而不是仅仅停留在使用上面。  </p><p>这篇文章断断续续写了快一个月，思路断断续续，也有几次推翻重来，原本也打算想讲得更多更细一些，只是限于篇幅与精力，最终的效果跟我最初的预期有所差距，可能也有些错误或者讲解不清晰的地方。  </p><p>如果你发现任何错误，或者写得不好的地方，或者不理解的地方，非常欢迎批评指正，也非常欢迎吐槽！！！！</p><p>其实我还顺带看了AppBarLayout等的源码，如有可能，我还想把Design库下的所有控件都分析一遍。  </p><p>感谢你的阅读。</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://medium.com/google-developers/intercepting-everything-with-coordinatorlayout-behaviors-8c6adc140c26#.p1v2t3rxo" target="_blank" rel="noopener">Intercepting everything with CoordinatorLayout Behaviors</a>  </p><p><a href="https://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html" target="_blank" rel="noopener">CoordinatorLayout.Behavior</a>  </p><p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0224/3991.html" target="_blank" rel="noopener">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0224/3991.html</a></p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="http://yifeiyuan.me/2016/12/27/deep-into-viewstub/">ViewStub是如何实现懒加载的</a><br><a href="http://yifeiyuan.me/2016/12/29/analyze-space/">Space源码分析</a><br><a href="http://yifeiyuan.me/2017/01/02/analyze-layoutinflater1-inflate/">LayoutInflater源码分析（一）之inflate深度分析</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTFSC </tag>
            
            <tag> CoordinatorLayout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客收到第一次打赏的喜与悲</title>
      <link href="/blog/b149dd8c.html"/>
      <url>/blog/b149dd8c.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天微信突然收到一个 面对面收钱的到账通知 , 楞了一下,谁给我转的钱?<br>仔细一看,显示的名字是 <code>Major</code>,在我的记忆中,我并没有这么一个好友.  </p><p>我一搜,确实不是我的好友.  </p><p>刚开始还没反应过来,后来仔细一想,好像我在我的博客开放着我的微信二维码,那他应该是我的读者,这应该是对我博客的一份支持了!  </p><p>非常激动,非常感激,想加他微信亲自表示感谢,但是搜索不到微信号,很是可惜.  </p><p>  后面是废话和牢骚,不看也罢</p><p>也因此,回想起自己写博客的经历,两年前开始写博客,一路以来自己 <strong>坚持原创</strong>,<strong>坚持授人以鱼 不如授人以渔</strong>,写博客这么久以来,写了约100篇左右,在博客上从来没有收到过打赏支持(说心里话,其实内心是比较失望的,那时候博客的图片放在七牛,连服务费都付不起呢,oh,现在依然如此).  </p><p>因为自己深知写博客写文章的不易,写一篇文章通常比自己学习知识花费的时间更多.  </p><p>特别是随着时间的增长,随着自己能力的提升,担当更多更重的任务,同时也发现自己更多的不足,要不断地去学习更多的知识,(比如什么OkHttp,RxJava<br>,Retrofit,Glide,Dagger2,RN等等等等),被更多的知识Push着,以至于停下脚步来写维护博客的时间越来越少.  </p><p>以前写一篇文章我还同步到简书,慕课网等,还在各个平台分享出去,还去发微博at一大堆大V,甚至还开通了微信公众账号希望分享给更多的朋友,而现在,即使写了,都懒得去折腾这些了.  </p><p>以前开的坑 比如 <code>群英传</code>,<code>艺术探索</code>,<code>EJ</code>,<code>设计模式</code>等系列也都因为时间与精力的关系更新缓慢,再比如最近定的一篇&lt;&lt;一步一步深入理解CoordinatorLayout&gt;&gt;(看了3天源码准备总结的),断断续续写了两个礼拜了,才写了1600字,估计才完成一半,但是始终没有将它完结,分享到博客来!  </p><p>再加上写博客其实是一件十分吃力不讨好的事,花费极大的精力,可能换来的是几十或者一两百的PV,甚至被那些恶心的傻逼网站全文爬走,连个出处都不给你,再加上我自己的拖拉,很多文章以及系列都只存在我的脑海蓝图中,有的甚至还没提笔就已胎死腹中.  </p><p>所以,我想,可能没有人比我更懂坚持写原创博客的艰辛了.  </p><p>所以,我特别佩服那些在百忙之中还能写出精彩文章的作者.  </p><p>而对于优秀的文章,我向来是非常支持的,我本人经常会打赏那些好的文章,特别是在简书上,我打赏出去的钱是我收进来的几十倍!  </p><p>并且在国内现在这个环境下,鸡汤文,垃圾文遍地,各种抄袭,爬文章各种猖狂,<strong>我总怕,坚持写优秀博客的人越来越少,我能支持就支持一下</strong>.  </p><p>另外,在别人支持我的时候,我总是非常感激,<strong>非常非常感激那些给予我支持的人,你们每个人的每一份打赏,我都会在<a href="http://yifeiyuan.me/donate/">这里</a>记录</strong> ,虽然写文章并不是为了钱,但是不可否认的是,这是其中一个动力来源.  </p><p>如果可以,我希望我的读者,屏幕前的你,能够与我多一些互动,多给我一些建议,如果我写得烂,请喷我,如果写得好,可以支持我一下  </p><p>我会非常感激,如果你能这么做的话!    </p><p>我依然会坚持写博客    </p><p>希望你依然会光顾  </p><p>希望你会喜欢  </p><p>但行好事  </p><p>莫问前程  </p><p>就这样  </p><p>祝好  </p><p>安  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android程序猿学Css(上)</title>
      <link href="/blog/7403bd3e.html"/>
      <url>/blog/7403bd3e.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面学习了Html,现在接下去学习一下Css.  </p><p>CSS全称为“层叠样式表 (Cascading Style Sheets)”，它主要是用于定义HTML内容在浏览器内的显示样式，如文字大小、颜色、字体加粗等。</p><p>我觉得可以把CSS理解为Android的Style&amp;Theme   </p><p>css 样式由选择符和声明组成，而声明又由属性和值组成,如下:  </p><p><img src="http://ww1.sinaimg.cn/large/98900c07gw1f5lmptqgrsj208f039aa7.jpg" alt="Css语法"></p><p><strong>选择符：又称选择器，指明网页中要应用样式规则的元素</strong></p><p>例子如下:  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">   <span class="attribute">font-size</span>:<span class="number">12px</span>;</span><br><span class="line">   <span class="attribute">color</span>:red;</span><br><span class="line">   <span class="attribute">font-weight</span>:bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意思是修改<code>&lt;p&gt;</code>标签的相关属性.  </p><a id="more"></a><p>CSS中的注释:<code>/*注释语句*/</code> 跟Java一样<br>HTML中的注释:<code>&lt;!--注释语句--&gt;</code> 跟Xml一样    </p><h2 id="CSS的写法"><a href="#CSS的写法" class="headerlink" title="CSS的写法"></a>CSS的写法</h2><ul><li><p>内联式:<br>直接写在标签里,感觉直观方便,但是不容易统一维护,不方便管理.  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:red"</span>&gt;</span>这里文字是红色。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>嵌入式css样式:  </p></li></ul><p>在<code>&lt;style&gt;</code>标签里定义,嵌入在<code>head</code>里<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">span&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">color</span><span class="selector-pseudo">:red</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>外部式css样式(也可称为外联式)):</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link <span class="attribute">href</span>=<span class="string">"base.css"</span> <span class="attribute">rel</span>=<span class="string">"stylesheet"</span> <span class="attribute">type</span>=<span class="string">"text/css"</span> /&gt;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>css样式文件名称以有意义的英文字母命名，如 main.css。</li><li>rel=”stylesheet” type=”text/css” 是固定写法不可修改。</li><li><link>标签位置一般写在<head><meta name="generator" content="Hexo 3.8.0">标签之内。</head></li></ol><p>感觉像是<code>include</code>和<code>import</code>一样,将独立的CSS文件引入进来,可以解耦,方便维护~~<br>我想,用得更多的是这一种方式吧.  </p><h3 id="三种方式的优先级"><a href="#三种方式的优先级" class="headerlink" title="三种方式的优先级"></a>三种方式的优先级</h3><p><code>内联式 &gt; 嵌入式 &gt; 外部式</code></p><p>跟在Android中Xml给某个View定义属性一样,在<view></view>里的属性总是优先于外部的Style跟Theme的,很好理解</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ul><li><p>标签选择器,选择器是标签名字</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>类选择器<br><strong>作用于Class</strong>,语法(前面有<code>.</code>):  </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.类选器名称&#123;css样式代码<span class="comment">;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>比如:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.stress&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="selector-tag">span</span> class=<span class="string">"stress"</span>&gt;胆小如鼠&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p><code>.stress</code>就是个类选择器</p><ul><li>ID选择器<br>作用于<code>id</code>,语法(前面是<code>#</code>):  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#setGreen</span>&#123;<span class="attribute">color</span>:green;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>例子同类选择器.  </p><p>类选择器和ID选择器的异同</p><p>相同点：可以应用于任何元素<br>不同点：</p><ol><li>ID选择器只能在文档中使用一次。与类选择器不同，在一个HTML文档中，ID选择器只能使用一次，而且仅一次。而类选择器可以使用多次。  </li><li>可以使用类选择器词列表方法为一个元素同时设置多个样式。  </li></ol><ul><li><p>子选择器<br>即大于符号(&gt;),用于选择指定标签元素的 <strong>第一代子元素</strong>.  </p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.food</span>&gt;<span class="selector-tag">li</span>&#123;<span class="attribute">border</span>:<span class="number">1px</span> solid red;&#125;  <span class="comment">//居然没有分号?</span></span><br></pre></td></tr></table></figure></li><li><p>通用选择器<br>通用选择器是功能最强大的选择器，它使用一个 <code>（*）</code>号指定，它的作用是 <strong>匹配html中所有标签元素</strong>   如下使用下面代码使用html中任意标签元素字体颜色全部设置为红色：  </p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* &#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure><ul><li>伪类选择符<br>更有趣的是伪类选择符，为什么叫做伪类选择符，<strong>它允许给html不存在的标签（标签的某种状态）设置样式</strong>，比如说我们给html中一个标签元素的鼠标滑过的状态来设置字体颜色：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS属性"><a href="#CSS属性" class="headerlink" title="CSS属性"></a>CSS属性</h2><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">单位</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">font-size</td><td style="text-align:center">px</td><td style="text-align:center">字体大小</td></tr><tr><td style="text-align:center">color</td><td style="text-align:center">red or #rgb</td><td style="text-align:center">字体颜色</td></tr><tr><td style="text-align:center">font-weight</td><td style="text-align:center">bold(加粗)</td><td style="text-align:center">字体</td></tr><tr><td style="text-align:center">border</td><td style="text-align:center">px</td><td style="text-align:center">边框</td></tr><tr><td style="text-align:center">solid</td><td style="text-align:center">red or#rgb</td><td style="text-align:center">填充色  </td></tr></tbody></table><p>//to do 估计也有很多很多其他属性吧,以后知道了再补充  </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>按照Android的相关知识去理解,发现CSS也挺简单的,很容易理解嘛~<br>当然,入门总是简单的…</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="http://www.imooc.com/learn/9" target="_blank" rel="noopener">http://www.imooc.com/learn/9</a></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Html入门学习</title>
      <link href="/blog/27f963b3.html"/>
      <url>/blog/27f963b3.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天玩了React Native,(<a href="http://yifeiyuan.me/2016/06/28/%E5%88%9D%E8%AF%95ReactNative/">文章</a>),发现如果想真的学好的话,还需要学习一下Html,Css,JavaScript,Node,ES6什么的,感觉东西好多好多<br>一样一样来吧,从Html开始涉猎吧!  </p><a id="more"></a><h2 id="Html基础"><a href="#Html基础" class="headerlink" title="Html基础"></a>Html基础</h2><p>Html似乎都是标签,数量有不少,但是估计常用的就那么些个,比如img,a什么的,所以打算粗略的都过一遍,了解了解,不打算深究  </p><p>因为不知道怎么去学,也没有买书看,所以暂时在慕课网上挑了个基础课程学习,有空闲时间的时候看看,发现还不错!!~~    </p><p>暂时记录一点笔记吧!毕竟还在写Android,容易忘记,还是笔记靠谱!~~    </p><p>固定结构:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello Html!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li><code>&lt;html&gt;</code>为根标签</li><li><code>&lt;head&gt;</code>标签用于定义文档的头部，它是所有头部元素的容器。头部元素有 <code>&lt;title&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;style&gt;</code>、<code>&lt;link&gt;</code>、 <code>&lt;meta&gt;</code> 等标签。</li><li>在<code>&lt;body&gt;</code>和<code>&lt;/body&gt;</code>标签之间的内容是网页的主要内容,在这里的标签中的内容会在浏览器中显示出来。  </li></ul><p>html,yml都跟xml差不多一样的语法格式,看起来也不难,恩,这是好事!~~  </p><p>希望自己能触类旁通!~  </p><h2 id="基本标签"><a href="#基本标签" class="headerlink" title="基本标签"></a>基本标签</h2><p><strong>PS:这主题的表格丑的不能看啊!排版都乱套了~</strong>  </p><table><thead><tr><th style="text-align:left">标签名</th><th style="text-align:center">作用</th><th style="text-align:center">更多属性</th><th style="text-align:center">样例</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;h1&gt;&lt;/h1&gt;</code></td><td style="text-align:center">标题</td><td style="text-align:center">h2-6</td><td style="text-align:center"></td><td style="text-align:center">h1最大</td></tr><tr><td style="text-align:left"><code>&lt;p&gt;&lt;/p&gt;</code></td><td style="text-align:center">段落</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><code>&lt;img src=“imageUrl”&gt;</code></td><td style="text-align:center">显示图片</td><td style="text-align:center">width=”200” height=”200”,<code>alt=&quot;失败后显示的文本&quot;</code>;<code>title=&quot;鼠标hover显示的文本&quot;</code></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><code>&lt;a&gt;&lt;/a&gt;</code></td><td style="text-align:center">链接</td><td style="text-align:center"><code>href</code>指定链接;<code>title</code>属性,当鼠标hover的时候显示的文字;<code>target=&quot;_blank&quot;</code>表示连接在新的网页打开;<code>mailto</code>发送邮件</td><td style="text-align:center"><code>&lt;a href=&quot;http://yifeiyuan.me&quot;&gt;点我跳转到我的博客&lt;/a&gt;</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><code>&lt;em&gt;斜体效果&lt;/em&gt;</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><code>&lt;strong&gt;加粗效果&lt;/strong&gt;</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><code>&lt;span&gt;&lt;/span&gt;</code></td><td style="text-align:center">标签是没有语义的，它的作用就是为了设置单独的样式用的。</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><code>&lt;q&gt;引用的文本&lt;/q&gt;</code></td><td style="text-align:center">表示对文本的引用(少量)</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">会自动加上双引号,不需要自己再加了!</td></tr><tr><td style="text-align:left"><code>&lt;blockquote&gt;引用文本&lt;/blockquote&gt;</code></td><td style="text-align:center">表示对文本的引用,不过是大量的文本</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">浏览器对<code>&lt;blockquote&gt;</code>标签的解析是缩进样式,并且也不需要双引号</td></tr><tr><td style="text-align:left"><code>&lt;br&gt;</code></td><td style="text-align:center">分行/换行</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><code>&amp;nbsp;</code></td><td style="text-align:center">空格</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">在Html里直接输入空格/换行是不支持的</td></tr><tr><td style="text-align:left"><code>&lt;address&gt;地址(默认自动斜体)&lt;/address&gt;</code></td><td style="text-align:center">地址</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">默认斜体</td></tr><tr><td style="text-align:left"><code>&lt;code&gt;代码&lt;/code&gt;</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><code>&lt;pre&gt;语言代码段&lt;/pre&gt;</code></td><td style="text-align:center">大段代码</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符</td></tr><tr><td style="text-align:left"><code>&lt;ul&gt;&lt;li&gt;无序列表信息item&lt;/li&gt;&lt;/ul&gt;</code></td><td style="text-align:center">无序列表</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><code>&lt;ol&gt;&lt;li&gt;有序列表信息item&lt;/li&gt;&lt;/ol&gt;</code></td><td style="text-align:center">有序列表,从1开始</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><code>table、tbody、tr、th、td</code></td><td style="text-align:center">表格</td><td style="text-align:center">summary 摘要;caption 标题(显示在表格上方),方便搜索引擎</td><td style="text-align:center"></td><td style="text-align:center">th表头,tr-行,td列</td></tr></tbody></table><h2 id="div"><a href="#div" class="headerlink" title="div"></a>div</h2><p>似乎在Html中div的作用挺大,就分开记录了,也不知道对不对.  </p><p>在网页制作过程过中，可以把一些独立的逻辑部分划分出来，放在一个<code>&lt;div&gt;</code>标签中，这个<code>&lt;div&gt;</code>标签的作用就相当于一个容器。 相当于Android中的<code>ViewGroup</code>?</p><p>可以给div设置<code>id</code>  </p><h2 id="表单标签-amp-表单控件"><a href="#表单标签-amp-表单控件" class="headerlink" title="表单标签&amp;表单控件"></a>表单标签&amp;表单控件</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">form</span> method=<span class="string">"post"</span> action=<span class="string">""</span>&gt; &lt;/<span class="keyword">form</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">form</span>    method=<span class="string">"post"</span>   action=<span class="string">"save.php"</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">label</span> <span class="keyword">for</span>=<span class="string">"username"</span>&gt;用户名:&lt;/<span class="keyword">label</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"text"</span> name=<span class="string">"username"</span> /&gt;</span><br><span class="line">        &lt;<span class="keyword">label</span> <span class="keyword">for</span>=<span class="string">"pass"</span>&gt;密码:&lt;/<span class="keyword">label</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"password"</span> name=<span class="string">"pass"</span> /&gt;</span><br><span class="line">&lt;/<span class="keyword">form</span>&gt;</span><br></pre></td></tr></table></figure><p>属性<code>action</code> ：浏览者输入的数据被传送到的地方,比如一个PHP页面(save.php)<br>属性<code>method</code> ： 数据传送的方式（get/post）。</p><p>label,input都是<code>表单控件</code></p><p>下面稍微记录一下,肯定会忘记…  </p><ul><li>label 用于显示文字,差不多相当于TextView<br><code>for</code>: 表示应用给哪个控件,?<br><code>name</code>: 控件名,跟id一样?  </li><li>input 输入文本框<br><code>type</code>: 值为<code>submit</code>的时候是提交,当用户需要提交信息给服务器的时候使用;<code>reset</code>为重置;<code>text</code>时是文本;<code>password</code>是密码;<code>radio</code>单选;<code>checkbox</code>复选框;<br><code>value</code>: 可以用作默认值  </li><li>textarea:文本域，支持多行文本输入,支持配置行列cols=”10”,rows=”10”  </li><li>select:下拉列表框<br><code>option</code>可以表示一个选项,如<code>&lt;option value=&quot;看书&quot; selected=&quot;selected&quot;&gt;看书&lt;/option&gt;</code> selected属性表示默认选中<br>select的<code>multiple</code>属性,<code>multiple=&quot;multiple&quot;</code>可以支持多选  </li></ul><h2 id="标签的一些属性"><a href="#标签的一些属性" class="headerlink" title="标签的一些属性"></a>标签的一些属性</h2><p><code>class</code>属性,可以为一个标签设置多个<code>class属性</code>,中间用空格隔开,比如<code>class=&quot;people knight&quot;</code>,可以理解为接口,一个标签可以实现多个接口(class),拥有不同接口(class)的样式.        </p><p><code>id</code>属性,为一个标签设置一个id属性,同Android,css里的<code>id</code>是唯一的,即不能为不同的标签设置同一个<code>id</code>  </p><p>例子:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p <span class="attribute">class</span>=<span class="string">"dev bloger"</span> <span class="attribute">id</span>=<span class="string">"yifeiyuan"</span>&gt;程序亦非猿&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><h2 id="小结-amp-感想"><a href="#小结-amp-感想" class="headerlink" title="小结&amp;感想"></a>小结&amp;感想</h2><p>html还算是很好理解的嘛!~  </p><p>感觉写起来有点麻烦,内容多了估计排版会很乱吧!!!   </p><p>以后能看得懂Html的代码了 😄~</p><p>有没有发现,我的博客右边的SideBar部分,多了个 <strong>打赏支持</strong> 的模块,那就是我自己改的,哈哈哈,学以致用的感觉真棒!!!!  </p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="http://www.imooc.com/learn/9" target="_blank" rel="noopener">HTML+CSS基础课程</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2章-IPC机制</title>
      <link href="/blog/1e0acb19.html"/>
      <url>/blog/1e0acb19.html</url>
      
        <content type="html"><![CDATA[<p>// todo 尚未完成  </p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>IPC是 Inter-Process Communication的缩写,含义为<strong>进程间通信或者跨进程通信</strong>是指两个进程之间进行数据交互的过程.  </p><p>在Android系统中IPC非常非常重要,需要掌握!!!  </p><a id="more"></a><ol><li>线程是 <strong>CPU调度的最小单元</strong>,同时线程是一种有限的系统资源,而进程一般指 <strong>一个执行单元</strong>,在PC和移动设备上指一个程序或者一个应用.  </li><li>一个进程可以包含多个线程,一次进程和线程是 <strong>包含和被包含的关系</strong>  </li><li>Linux上可以通过 命名管道 共享内容 信号量等进行进程间通信,而在Android中使用<code>Binder</code>    </li><li>四大组件可以通过<code>android:process</code>属性开启多进程模式(另外一个方式,在JNI里fork一个新进程)</li><li><code>adb shell ps</code>可以查看进程信息</li><li>每个进程都拥有独立的虚拟机  </li></ol><p>进程名指定方式有两种:<br>假设包名为<code>me.yifeiyuan.android</code></p><ul><li>一种以<code>:</code>开头,表示在当前的进程名前加上包名,比如指定<code>android:process=&quot;:remote&quot;</code>,那么当前组件的进程名为<code>me.yifeiyuan.android.remote</code>,并且该进程属于当前应用的 <strong>私有进程</strong>,其他应用的组件不可以和他跑在同一个进程    </li><li>另一种是完整的方式,如指定为<code>&quot;com.a.b.remote&quot;</code>,那么当前组件的进程名就是<code>com.a.b.remote</code>,其他应用通过sharedUID(每个应用的UID唯一)方式可以和它跑在同一个进程    </li></ul><h2 id="多进程的问题"><a href="#多进程的问题" class="headerlink" title="多进程的问题"></a>多进程的问题</h2><p>每个进程都分配 <strong>一个独立的虚拟机,不同的虚拟机在内存分配上有不同的地址空间</strong>,这就导致 <strong>在不同的虚拟机中访问同一个类的对象会产生多份副本.</strong><br>也就是说只要是通过内存来共享数据,都会失败!  </p><ol><li>静态成员和单例模式完全失效(内存不共享了)  </li><li>线程同步机制完全失效(同上,锁的不是同一个对象了)  </li><li>SharedPreferences的可靠性下降(SP底层通过读写XML文件来实现的,并发会出问题)  </li><li>Application会多次创建(当一个组件需要运行在新的进程里,系统需要在创建新的进程同时分配独立的虚拟机,也会创建新的Application,这就相当于启动一个应用,)  </li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android开发艺术探索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那些做Android开发必须知道的ADB命令</title>
      <link href="/blog/8045358e.html"/>
      <url>/blog/8045358e.html</url>
      
        <content type="html"><![CDATA[<h2 id="那些必须知道的ADB命令"><a href="#那些必须知道的ADB命令" class="headerlink" title="那些必须知道的ADB命令"></a>那些必须知道的ADB命令</h2><p>  科普: ADB的全称是<a href="https://developer.android.com/intl/zh-cn/tools/help/adb.html" target="_blank" rel="noopener">Android Debug Bridge</a>  </p><p>熟练掌握ADB命令可以提高开发效率<br>以下记录一些比较常用的命令:  </p><a id="more"></a><ul><li><p><code>adb start-server</code><br>启动adb服务,如果它没启动的话</p></li><li><p><code>adb kill-server</code><br>关闭服务</p></li><li><p><code>adb devices</code><br>查看所连接的设备以及设备所对应的序列号</p></li><li><p><code>adb install -r xxxx.apk</code><br>安装app,需要注意的是如果连接了两台设备,则会报错,此时可以添加<code>-s &lt;serialNumber&gt;</code>来处理  </p></li><li><p><code>adb uninstall packagename</code><br>卸载app,有时候在手机上卸载App会出现数据清理不干净,导致App再也装不上了,这个时候可以敲命令来卸载  </p></li><li><p><code>adb shell</code><br>进入shell环境  </p></li><li><p><code>adb shell pm clear packagename</code><br>清除应用的数据,很常用吧?</p></li><li><p><code>adb shell am start -n packagename/packagename.activityname</code></p><p>启动某个应用的某个Activity(以前调试老年机,那种Launcher上没有APP的机器,全靠它啊!!!!!!!)  </p></li><li><p><code>adb connect &lt;device-ip-address&gt;</code><br>连接到指定的ip,这个通常配合wifidebug</p></li><li><p><code>adb shell dumpsys activity top</code><br>查看栈顶Activity,可以用来获取包名,可以用来查看其它app的包名</p></li><li><p><code>adb shell ps</code><br>查看进程信息</p></li><li><p><code>adb shell pm list packages -f</code><br>查看所有已安装的应用的包名</p></li><li><p><code>adb shell dumpsys activity</code><br>dumpsys系列命令可以帮助我们查看各种信息<br>am的状态 Activity Manager State</p></li><li><p><code>adb shell dumpsys package</code><br>包信息 Package Information</p></li><li><p><code>adb shell dumpsys meminfo</code><br>内存使用情况Memory Usage</p></li><li><p><code>adb pull &lt;remote&gt; &lt;local&gt;</code><br>从手机复制文件出来,比如把Crash日志写在SD卡上,再pull到电脑上 或者 pull ANR的trace日志    </p></li><li><p><code>adb push &lt;local&gt; &lt;remote&gt;</code><br>向手机发送文件,比如测试热修复补丁~  </p><p>eg. <code>adb push foo.txt /sdcard/foo.txt</code>  </p></li><li><p><code>adb shell cat /proc/cpuinfo</code><br>查看手机CPU,可以看到手机架构(eg.ARMv7) 和几核处理器<br>可以帮助我们选择so库,排查手机cpu架构相关的问题    </p></li></ul><h3 id="不太常用的命令"><a href="#不太常用的命令" class="headerlink" title="不太常用的命令"></a>不太常用的命令</h3><ul><li><p><code>adb shell df</code><br>获取手机磁盘空间  </p></li><li><p><code>adb shell getprop ro.build.version.release</code><br>获取手机系统版本</p></li><li><p><code>adb shell dumpsys procstats</code><br>Memory Use Over Time</p></li><li><p><code>adb shell dumpsys gfxinfo</code><br>Graphics State</p></li><li><p><code>adb version</code><br>查看adb版本</p></li><li><p><code>adb help</code><br>进入adb帮助界面  </p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>其实 am,pm 其实还有很多命令,以后有多的再写吧</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ol><li><a href="https://developer.android.com/intl/zh-cn/tools/help/adb.html" target="_blank" rel="noopener">adb-官方资料</a>  </li><li><a href="https://ar-g.github.io/ADB-Shell-Part-1/" target="_blank" rel="noopener">ADB-Shell</a></li><li><a href="http://adbshell.com/" target="_blank" rel="noopener">adbshell</a></li><li><a href="http://www.jianshu.com/p/860bc2bf1a6a" target="_blank" rel="noopener">ADB命令大全</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> Adb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微博这是要完</title>
      <link href="/blog/d616cf53.html"/>
      <url>/blog/d616cf53.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>玩微博有一两年了,老是遇到偷偷摸摸给我关注一些乱七八糟的账号    </p><p>今天又发现我关注别人了,更可恶的是,tm居然还<strong>自动发微博</strong>了,还有没有底线了?  </p><p>360安全浏览器什么鬼?  </p><p>我用的MAC啊!!!~  </p><p>iPhone什么鬼?  </p><p>我用的Android啊!<del>~</del></p><p>臭不要脸的微博!!!  </p><p>迟早跟百度一样!  </p><p>微博这是要完.  </p><p><img src="http://ww4.sinaimg.cn/large/98900c07gw1f5bb6oiecjj20gv09jjst.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/98900c07gw1f5bb7owhpkj20gu0bi41g.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初试ReactNative</title>
      <link href="/blog/bd630ac6.html"/>
      <url>/blog/bd630ac6.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博客写累了，玩玩 ReactNative！~    </p><a id="more"></a><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p>如果没有Homebrew就先安装brew：  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>bin<span class="regexp">/ruby -e "$(curl -fsSL https:/</span><span class="regexp">/raw.githubusercontent.com/</span>Homebrew<span class="regexp">/install/m</span>aster<span class="regexp">/install)"</span></span><br></pre></td></tr></table></figure><p>有的话接下就去安装下面的工具：<br><code>Node</code>，<code>React Native Command Line Tools</code>，<code>XCode</code>，<code>Watchman</code>，<code>Flow</code>（已有的就不需要了）      </p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>node</span><br><span class="line">npm <span class="keyword">install </span>-g react-native-cli</span><br><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>watchman</span><br><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>flow</span><br></pre></td></tr></table></figure><h2 id="IDE-Nuclide"><a href="#IDE-Nuclide" class="headerlink" title="IDE Nuclide"></a>IDE <a href="https://nuclide.io/" target="_blank" rel="noopener">Nuclide</a></h2><p>还有IDE需要下载，<code>Nuclide</code>基于<code>Atom</code>（以后Atom不再只是用来写博客了），由于Atom已经安装好了，so，也很简单  </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apm <span class="keyword">install</span> nuclide</span><br></pre></td></tr></table></figure><p>安装完后会多出一栏Nuclide：</p><p><img src="http://ww1.sinaimg.cn/large/98900c07gw1f5b2x5763hj209i0dn75t.jpg" alt="Nuclide">  </p><h2 id="Run-Demo"><a href="#Run-Demo" class="headerlink" title="Run Demo"></a>Run Demo</h2><p>所有工具都安装好了，可以跑demo试试了  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">react-<span class="keyword">native</span> <span class="keyword">init</span> AwesomeProject</span><br><span class="line">cd AwesomeProject</span><br><span class="line">react-<span class="keyword">native</span> run-ios</span><br></pre></td></tr></table></figure><p>一切成功的话，可以看到下面的效果图：  </p><p><img src="http://ww4.sinaimg.cn/large/98900c07gw1f5b2t1krqzj20af0j50t3.jpg" alt="demo-效果图"></p><p>RN作为一个跨平台的语言还是很有吸引力的,跟Kotlin相比,我更愿意去学RN!~</p><p>RN以后是趋势,学一点没有坏处!~</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="http://facebook.github.io/react-native/docs/getting-started.html#content" target="_blank" rel="noopener">ReactNative</a><br><a href="https://github.com/reactnativecn/react-native-guide" target="_blank" rel="noopener">react-native-guide</a><br><a href="http://reactnative.cn/docs/0.27/getting-started.html" target="_blank" rel="noopener">reactnative.cn</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1章-Activity的生命周期和启动模式</title>
      <link href="/blog/45aeb1e2.html"/>
      <url>/blog/45aeb1e2.html</url>
      
        <content type="html"><![CDATA[<h2 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a><a href="http://developer.android.com/intl/zh-cn/reference/android/app/Activity.html" target="_blank" rel="noopener">Activity</a>的生命周期</h2><ol><li>正常状态</li><li>异常状态(系统杀死/Configuration变化如屏幕旋转)</li></ol><h3 id="正常状态"><a href="#正常状态" class="headerlink" title="正常状态"></a>正常状态</h3><ol><li>onCreate   表示Activity正在创建,可以做一些初始化操作</li><li>onRestart  正在重新启动,onstop后回来会调用</li><li>onStart    正在被启动,后台,不可交互</li><li>onResume   <strong>可见可交互前台</strong>,非常重要,许许多多的重要的类在这里初始化</li><li>onPause    正在停止 <strong>后台(不一定不可见)</strong> 不可做太耗时的操作,<strong>因为onPause之后新启动Activity的onResume才能被调用</strong></li><li>onStop    即将停止,<strong>不可见</strong> 可以做一些稍微重量级  的回收</li><li>onDestroy 即将销毁,可以做一些回收资源,关闭线程,移除Handler消息等操作</li></ol><p>生命周期配对去记忆效果更佳:<br>create – destroy<br>start – stop<br>resume – pause  </p><a id="more"></a><p>注意点:  </p><p>A 启动 B<br>如果B是透明的Activity,那么A的onStop不会被调用  </p><h3 id="异常状态"><a href="#异常状态" class="headerlink" title="异常状态"></a>异常状态</h3><p>Activity的销毁与重建涉及到这两方法:  </p><ol><li><code>onSaveInstanceState(@Nullable Bundle state)</code>    系统会调用它来保存状态,以便之后恢复  </li><li><code>onRestoreInstanceState(@NonNull Bundle state)</code>  为系统恢复所用</li></ol><p><strong>当Activity将处于可能被销毁或要被销毁的状态,就会调用<code>onSaveInstanceState</code></strong><br>而<strong><code>onRestoreInstanceState</code>则是重建的时候被调用</strong>  </p><h4 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h4><p><code>onSaveInstanceState</code> 在<code>onStop</code>之前调用,而不一定在<code>onPause</code>之后<br><code>onRestoreInstanceState</code> 在<code>onStart</code>之后,<code>onResume</code>之前</p><p>所以,大致的完整的生命周期是这样的:<br>onCreate<br>onRestart<br>onStart<br>onRestoreInstanceState<br>onResume<br>onPause<br>onSaveInstanceState<br>onStop<br>onDestroy  </p><p>PS:<code>onSaveInstanceState</code>如下情况会调用:  </p><ol><li>启动了新的Activity  </li><li>按了Home键等等    </li></ol><p>另外:可以在onCreate里判断bundle是否为null来判断是新建还是重新创建  </p><p>关于完整的生命周期,附上一张图,配有fragment的生命周期,可能你在很多地方都看到过,很多人盗用了它,但是并不给出处,这里提一下,它出自<a href="https://github.com/xxv/android-lifecycle" target="_blank" rel="noopener">android-lifecycle</a>:<br><img src="http://ww1.sinaimg.cn/mw690/98900c07gw1f3qo4cy2f7j21bu2u2wu8.jpg" alt="complete_android_fragment_lifecycle">  </p><h4 id="View-的恢复"><a href="#View-的恢复" class="headerlink" title="View 的恢复"></a>View 的恢复</h4><p>A系统默认做了一定的恢复,如视图结构,LV的滑动的位置等等(View也有save,restore方法)  </p><pre><code>&gt; PS 看到有的文章说解决Fragment重叠的问题,就是注释掉Activity的onSaveInstanceState方法,简直是误人子弟!!!有机会以后讲    </code></pre><p>扯远了,保存和恢复View的层次结构,系统的工作流程是这样子的:<br>Activity==&gt;Window==&gt;DecorView==&gt;ContentView==&gt;View<br>一层一层<strong>委托</strong>保存恢复状态  </p><h3 id="Activity优先级"><a href="#Activity优先级" class="headerlink" title="Activity优先级"></a>Activity优先级</h3><ol><li>前台Activity  正在交互的,onResume状态的Activity</li><li>可见但非前台,弹了Dialog,依然可见但是不能交互</li><li>后台Activity ,执行onStop之后</li></ol><h3 id="Configuration-改变"><a href="#Configuration-改变" class="headerlink" title="Configuration 改变"></a>Configuration 改变</h3><p>Configuration改变的时候系统默认会重建Activity,如果我不想重建,那么可以选择配置<code>android:configChanges</code>属性,一般常用的就<code>orientation</code>,<code>screenSize</code>,<code>keyboardHidden</code>  </p><p>so,一般给Activity配上这个就行了:<br><code>android:configChanges=&quot;orientation|screenSize|keyboardHidden&quot;</code>  </p><h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><h3 id="Standard"><a href="#Standard" class="headerlink" title="Standard"></a>Standard</h3><p>标准模式,默认的启动模式,<strong>每次启动都会新建一个Activity实例</strong>    </p><p>需要注意的是当使用ApplicationContext去启动Standard模式的Activity的时候会报错,说需要添加NEW_TASK 的标记  </p><p>为什么呢?  </p><p>因为<strong>Activity启动需要任务栈</strong>,而用<strong>Standard模式去启动Activity,默认会进入启动它的Activity所属的任务栈中,而非Activity类型的Context并没有所谓的任务栈</strong>.  </p><p>AB–启动C-&gt;ABC</p><h3 id="SingleTop"><a href="#SingleTop" class="headerlink" title="SingleTop"></a>SingleTop</h3><p>栈顶复用模式,如果新的Activity已位于栈顶,那么不会重新创建Activity,而是回调<code>onNewIntent</code>方法  </p><p><code>onNewIntent--&gt;onResume</code></p><p>ABC–启动C–&gt; ABC  </p><h3 id="SingleTask"><a href="#SingleTask" class="headerlink" title="SingleTask"></a>SingleTask</h3><p>栈内复用模式,只要占中存在都不会重新创建,并且也是回调<code>onNewIntent</code><br>另外需要注意的是,该模式拥有<strong>clearTop</strong> 的效果,会把位于它顶上的Activity全部出栈(PS:必须同一个栈)  </p><p>如: ABCDE–启动C(SingleTask)–&gt; ABC  </p><h3 id="SingleInstance"><a href="#SingleInstance" class="headerlink" title="SingleInstance"></a>SingleInstance</h3><p>单实例模式,<strong>栈内单例</strong>,一个Activity实例<strong>独占一个任务栈</strong>,可以说整个手机都只有一个实例  </p><p>指定启动模式有两种方式:  </p><ol><li>清单里修改<code>android:launchMode</code>属性  </li><li>Intent.addFlags() 来指定    </li></ol><h4 id="Activity的Flags"><a href="#Activity的Flags" class="headerlink" title="Activity的Flags"></a>Activity的Flags</h4><p>常用的Flags:  </p><ol><li>FLAG_ACTIVITY_NEW_TASK  指定启动模式为<code>singleTask</code></li><li>FLAG_ACTIVITY_SINGLE_TOP    指定<code>singleTop</code>启动模式</li><li>FLAG_ACTIVITY_CLEAR_TOP  将在它之上的所有Activity移出栈,这个模式一般需要和<code>FLAG_ACTIVITY_NEW_TASK</code>一起出现  </li><li>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS  具有这个标记的Activity不会出现在历史Activity列表中,相当于<code>android:exludeFromRecents=&quot;true&quot;</code>  </li></ol><h2 id="任务栈"><a href="#任务栈" class="headerlink" title="任务栈"></a>任务栈</h2><p>TaskAffinity(任务相关性),<strong>标识了一个Activity的任务栈名称</strong>,<em>默认为应用的包名</em>(万能的包名啊!)      </p><p>我们可以在清单文件里配置,也可以为每个Activity配置不同的值,但是需要注意的是它<strong>不能跟包名相同,并且必须要包含<code>.</code>分隔符!</strong>  </p><p>并且TaskAffinity属性主要和<code>SingleTask</code>或者<code>allowTaskReparenting</code>配对使用,在其他情况下没有意义.  </p><ol><li>TaskAffinity和SingleTask配合: TaskAffinity的值为该模式的任务栈的名字</li><li>TaskAffinity和<code>allowTaskReparenting</code> 配合就比较复杂了:<br>当<code>allowTaskReparenting</code>为<code>true</code>时,A应用启动B应用的一个Activity C,然后按Home回到桌面,然后再单击B的桌面图标,这个时候不是启动B的主Activity,而是重新显示被应用A启动的Activity C(原本来说C是A启动的,那么C应该待在A的任务栈里),或者说C从A的任务栈转移到了B的任务栈中(<em>也许这就是re-parenting的含义吧</em>)  </li></ol><p>补充:<code>allowTaskReparenting</code>需要和<code>FLAG_ACTIVITY_RESET_TASK_IF_NEEDED</code>标记合作才行,而从Home点击图标启动应用的<code>Intent</code>就带有该标记.  </p><h2 id="IntentFilter的匹配规则"><a href="#IntentFilter的匹配规则" class="headerlink" title="IntentFilter的匹配规则"></a>IntentFilter的匹配规则</h2><p>启动Activity有两种方式:<strong>显示调用</strong>和<strong>隐式调用</strong>  </p><p>显示调用非常简单,明确指定被启动对象的组件信息即可.  </p><p>而隐式调用需要配合<code>IntentFilter</code>去匹配,<strong>一个Activity可以有多个IntentFilter</strong>,匹配到了<strong>其中一个</strong>就能启动,否则启动失败,<code>IntentFilter</code>的过滤信息有<em>action,category,data</em>    </p><p>当一个Intent同时匹配<code>IntentFilter</code>的action,category,data,才能启动一个Activity  </p><h3 id="action的匹配规则"><a href="#action的匹配规则" class="headerlink" title="action的匹配规则"></a>action的匹配规则</h3><p>action是个字符串,区分大小写,系统自带一些Action,也可以自定义  </p><p>规则是:<strong>必须要匹配</strong>,即Intent的action需要一模一样!<strong>有多个action的时候,只需要匹配到一个即可</strong>    </p><p>需要注意的是,<strong>Intent必须包含action</strong>,否则匹配失败  </p><h3 id="category的匹配规则"><a href="#category的匹配规则" class="headerlink" title="category的匹配规则"></a>category的匹配规则</h3><p>category跟action一样,也是个字符串,系统也自带了一些,我们也可以自定义.  </p><p>它要求<code>Intent</code>中如果含有<code>category</code>,那么所有的<code>category</code>都必须和过滤规则的其中一个相同,即<strong>被过滤规则所包含,是它的子集</strong>  </p><p><strong>注意:与<code>action</code>不同的是,它可以不指定<code>category</code></strong>,这是因为<code>startActivity</code>和<code>startActivityForResult</code>会默认给Intent加上<code>android.intent.category.DEFAULT</code>这个<code>categrory</code>,所以如果你的Activity要能够接受隐式调用,就必须在清单文件中为这个Activity的<code>IntentFilter</code>中指定<code>android.intent.category.DEFAULT</code>这个<code>category</code>  </p><h3 id="data的匹配规则"><a href="#data的匹配规则" class="headerlink" title="data的匹配规则"></a>data的匹配规则</h3><h4 id="data的组成"><a href="#data的组成" class="headerlink" title="data的组成"></a>data的组成</h4><p>data由两部分组成,<code>mineType</code>和<code>URI</code>  </p><p>mineType指媒体类型,如<code>image/jpeg</code>和<code>video/*</code>  </p><p>URI比较复杂,它的格式:<br><code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;||&lt;pathPrefix&gt;|&lt;pathPattern&gt;]</code>  </p><p>看例子就简单了,比如:<code>http://yifeiyuan.me:80/about</code></p><ul><li>Scheme: <strong>必须</strong> URI的模式,比如http,ftp,如果URI中没有指定scheme,那么整个URI的其他参数无效  </li><li>Host: <strong>必须</strong> URI的主机名,如果Host没有指定,那么URI无效</li><li>Port: URI中的端口号,<strong>非必须</strong>,仅当URI中指定了scheme和host参数的时候port参数才有意义的.  </li><li>path 表示完整的路径,pathPrefix表示路径前缀,pathPattern表示完整的路径,但是它可以包含通配符</li></ul><h4 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h4><p>data也是完全匹配,可以在xml里给Activity配置:<code>&lt;data android:mineType=&quot;image/*&quot;&gt;`</code>  </p><p>启动Activity的时候可以通过<code>intent.setDataAndType()</code>设置</p><pre><code>小Tip:隐式启动可能会遇到匹配不到Activity而导致Crash的情况,可以使用`PackageManager`或者`Intent`的`resolveActivity`的方法先判断是否有匹配到的Activity,防止Crash</code></pre>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android开发艺术探索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第15章-Android性能优化</title>
      <link href="/blog/7747819b.html"/>
      <url>/blog/7747819b.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Android性能优化主要包括布局优化、绘制优化、内存泄露优化、响应速度优化、ListView优化、Bitmap优化、线程优化以及一些优化建议.  </p><p>实际上每个面都可以扩展很多,书中讲的不太多(篇幅少),需要在实际中多去运用.  </p><p>后面还有MAT的基本使用,我没记,可以去搜,资料不少~  </p><a id="more"></a><h2 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h2><ol><li>减少布局文件的层级(测量/布局/绘制的时间减少):可以使用RelativeLayout来减少嵌套,从而达到减少层级的目的,另外在<strong>相同层级</strong>的情况下使用LinearLayout(相比于RelativeLayout更高效)  </li><li>使用<code>include</code>标签复用,<code>merge</code>标签降低层级,<code>ViewStub</code>来实现懒加载,另外补充一个<code>Space</code>可以用来占位</li></ol><h2 id="绘制优化-onDraw"><a href="#绘制优化-onDraw" class="headerlink" title="绘制优化(onDraw)"></a>绘制优化(onDraw)</h2><p>主要是避免执行大量的操作.  </p><ol><li>不要创建新的局部对象,因为onDraw可能会被频繁调用,会在一瞬间产生大量的临时对象,会<strong>导致占用过多内存,系统更加频繁的gc,降低执行效率</strong></li><li>不要做耗时的任务</li></ol><h2 id="内存泄露优化"><a href="#内存泄露优化" class="headerlink" title="内存泄露优化"></a>内存泄露优化</h2><p>其实内存泄露有很多种情况,但是书中列举的比较少</p><ol><li>静态变量导致的内存泄露(比如静态的context,静态的view)</li><li>单例模式持有Activity</li><li>属性动画(repeatCount为无限模式)</li></ol><h2 id="ListView和Bitmap优化"><a href="#ListView和Bitmap优化" class="headerlink" title="ListView和Bitmap优化"></a>ListView和Bitmap优化</h2><p>ListView使用viewholder模式,Bitmap在12章有讲,这里不重复.</p><h2 id="线程优化"><a href="#线程优化" class="headerlink" title="线程优化"></a>线程优化</h2><p>主要是采用线程池(11章有讲)  </p><ol><li>避免存在大量的Thread</li><li>重用Thread,避免线程创建和销毁所带来的开销</li><li>线程池还能控制最大并发数,避免大量线程因互相抢占系统资源从而导致阻塞  </li></ol><h2 id="其他的一些性能优化建议"><a href="#其他的一些性能优化建议" class="headerlink" title="其他的一些性能优化建议"></a>其他的一些性能优化建议</h2><ol><li>避免创建过多的对象</li><li>不要过多使用枚举(枚举占用的内存空间要比整型的大)</li><li>常量使用 <code>static final</code>来修饰</li><li>使用一些Android特有的数据结构,比如<code>SparseArray</code>和<code>Pair</code>等,它们都具有更好的性能(注:减少了自动装箱和拆箱的消耗)</li><li>适当使用软引用和弱引用</li><li>尽量采用静态内部类(不会持有外部类的实例)</li></ol><h2 id="提高可维护性"><a href="#提高可维护性" class="headerlink" title="提高可维护性"></a>提高可维护性</h2><ol><li>命名规范</li><li>代码排版</li><li>给非常关键的代码写注释</li><li>代码要有层次性,可扩展  </li></ol><h2 id="其他的资料推荐"><a href="#其他的资料推荐" class="headerlink" title="其他的资料推荐"></a>其他的资料推荐</h2><p><a href="http://www.slideshare.net/seamaster29/10-ways-to-improve-your-android-app" target="_blank" rel="noopener">10-ways-to-improve-your-android-app</a><br><a href="http://hukai.me/android-performance-patterns-season-4/" target="_blank" rel="noopener">Android性能优化典范 - 第4季</a><br><a href="http://hukai.me/android-performance-patterns-season-3/" target="_blank" rel="noopener">Android性能优化典范 - 第3季</a><br><a href="http://hukai.me/android-performance-patterns-season-2/" target="_blank" rel="noopener">Android性能优化典范 - 第2季</a><br><a href="http://hukai.me/android-performance-patterns/" target="_blank" rel="noopener">Android性能优化典范 - 第1季</a>   </p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android开发艺术探索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一步一步教你150行代码实现简书滑动返回效果</title>
      <link href="/blog/fde88e55.html"/>
      <url>/blog/fde88e55.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天带大家实现简书的滑动返回效果.</p><p>先看看效果图:</p><p><img src="http://ww4.sinaimg.cn/large/98900c07gw1f5lp701v07g20ah0hatf4.gif" alt="最终效果图"></p><p>因为没有具体内容,也没有简书的图片资源,所以稍微简陋了点.<br>但是依然不妨碍我们的效果展示~</p><p>OK,接下来惯例,通过阅读本文你能学习到:</p><ol><li>ViewDragHelper的使用(如果你想学习自定义View,那么ViewDragHelper你绝对不能错过)</li><li>好像也没有什么了….</li></ol><p>这个效果,难度不大,会ViewDragHelper的同学应该10分钟就能写出来了吧~<br>如果不会也没关系~</p><a id="more"></a><h2 id="1-我们自定义一个SwipeBackFrameLayout继承自FrameLayout"><a href="#1-我们自定义一个SwipeBackFrameLayout继承自FrameLayout" class="headerlink" title="1. 我们自定义一个SwipeBackFrameLayout继承自FrameLayout"></a>1. 我们自定义一个SwipeBackFrameLayout继承自FrameLayout</h2><p>1.1 因为看到左边黄色的View是被遮住的,而另外一个View的宽度是MatchParent的,所以FrameLayout是不错的选择.<br>顺便增加一个回调,通知activity去finish<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallback</span>(<span class="params">Callback mCallback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mCallback = mCallback;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Callback mCallback;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Callback</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onShouldFinish</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1.2 Xml布局,非常简单:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;yifeiyuan<span class="selector-class">.practice</span><span class="selector-class">.practicedemos</span><span class="selector-class">.drager</span><span class="selector-class">.SwipeBackFrameLayout</span></span><br><span class="line">xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>    </span><br><span class="line">xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span>    </span><br><span class="line">android:id=<span class="string">"@+id/swipe_back"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span>    </span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span>    </span><br><span class="line">tools:context=<span class="string">"yifeiyuan.practice.practicedemos.drager.SwipeBackActivity"</span>&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=<span class="string">"40dp"</span>        </span><br><span class="line">        android:layout_height=<span class="string">"match_parent"</span>        </span><br><span class="line">        android:text=<span class="string">"@string/hello_world"</span></span><br><span class="line">        android:gravity=<span class="string">"center"</span></span><br><span class="line">        android:<span class="attribute">background</span>=<span class="string">"#ffff00"</span></span><br><span class="line">        /&gt;</span><br><span class="line">    &lt;View</span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span>        </span><br><span class="line">        android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">        android:<span class="attribute">background</span>=<span class="string">"#ff00ff"</span></span><br><span class="line">        /&gt;</span><br><span class="line">&lt;/yifeiyuan<span class="selector-class">.practice</span><span class="selector-class">.practicedemos</span><span class="selector-class">.drager</span><span class="selector-class">.SwipeBackFrameLayout</span>&gt;</span><br></pre></td></tr></table></figure></p><p>1.3 实例化一个ViewDragHelper<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1f代表灵敏度</span></span><br><span class="line">mDragHelper = ViewDragHelper.create(<span class="keyword">this</span>, <span class="number">1</span>f,<span class="keyword">new</span> ViewDragHelper.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryCaptureView</span><span class="params">(View child, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为我们是从左向右滑动 所以设置EDGE_LEFT</span></span><br><span class="line">mDragHelper.setEdgeTrackingEnabled(ViewDragHelper.EDGE_LEFT);</span><br></pre></td></tr></table></figure></p><p>1.4 在SwipeBackFrameLayout里实例化xml里的子View<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> View mDividerView;</span><br><span class="line"><span class="keyword">private</span> View mContentView;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onFinishInflate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onFinishInflate();</span><br><span class="line">   mDividerView = getChildAt(<span class="number">0</span>);</span><br><span class="line">    mDividerView.setAlpha(<span class="number">0</span>f);</span><br><span class="line">    mContentView = getChildAt(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1.5 让ViewDragHelper处理touch事件</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> mDragHelper.<span class="title">shouldInterceptTouchEvent</span><span class="params">(ev)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;    </span><br><span class="line">    mDragHelper.processTouchEvent(event);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.6 重写ViewDragHelper的一些处理方法<br><strong>已附上详细注释</strong><br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onEdgeTouched</span><span class="params">(<span class="keyword">int</span> edgeFlags, <span class="keyword">int</span> pointerId)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">super</span>.onEdgeTouched(edgeFlags, pointerId);</span><br><span class="line">   <span class="comment">//触摸到左边界的时候 我们capture住mContentView           </span></span><br><span class="line">    mDragHelper.captureChildView(mContentView, pointerId);</span><br><span class="line">&#125;            </span><br><span class="line"><span class="meta">@Override</span>            </span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">getViewHorizontalDragRange</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onViewPositionChanged</span><span class="params">(View changedView, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.onViewPositionChanged(changedView, left, top, dx, dy);</span><br><span class="line">     Log.d(TAG, <span class="string">"onViewPositionChanged() called with left = ["</span> + left + <span class="string">"], top = ["</span> + top + <span class="string">"], dx = ["</span> + dx + <span class="string">"], dy = ["</span> + dy + <span class="string">"]"</span>);</span><br><span class="line">     <span class="comment">//0.0 - 1.0</span></span><br><span class="line">     <span class="comment">//Notice 这边可以给个接口回调出去,就可以做各种炫酷的效果了                     </span></span><br><span class="line">     <span class="keyword">float</span> alpha = (<span class="keyword">float</span>) (left*<span class="number">1.0</span>/mDividerWidth);  </span><br><span class="line">     mDividerView.setAlpha(alpha);            </span><br><span class="line">&#125;  </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">clampViewPositionHorizontal</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> dx)</span> </span>&#123;</span><br><span class="line"><span class="comment">//                Log.d(TAG, "clampViewPositionHorizontal() called with  dx = [" + dx + "]");</span></span><br><span class="line">     <span class="comment">// 计算left 我们的目标范围是0-dividerwidth的宽度</span></span><br><span class="line">     mLastdx = dx;</span><br><span class="line">     <span class="keyword">int</span> newLeft = Math.min(mDividerWidth, Math.max(left,<span class="number">0</span>));                           </span><br><span class="line">     <span class="keyword">return</span> newLeft;</span><br><span class="line">&#125;            </span><br><span class="line">     <span class="meta">@Override</span>            </span><br><span class="line">     <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onViewReleased</span><span class="params">(View releasedChild, <span class="keyword">float</span> xvel, <span class="keyword">float</span> yvel)</span> </span>&#123;                </span><br><span class="line">     <span class="comment">//&gt;0代表用户想关闭                </span></span><br><span class="line">     <span class="keyword">if</span> (mLastdx&gt;<span class="number">0</span>)&#123;</span><br><span class="line">     <span class="comment">// 还不到关闭条件,我们让view滑动过去,再关闭                    </span></span><br><span class="line">     <span class="keyword">if</span> (mDividerWidth != releasedChild.getLeft()) &#123;    </span><br><span class="line">       mDragHelper.settleCapturedViewAt(mDividerWidth,releasedChild.getTop();</span><br><span class="line">       invalidate();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">     <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;  </span><br><span class="line">          mCallback.onShouldFinish();  </span><br><span class="line">      &#125;     </span><br><span class="line">&#125;  </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;            </span><br><span class="line">        <span class="comment">//用户不想关闭 ,则滑动到最左边</span></span><br><span class="line">     <span class="keyword">if</span> (mDividerWidth != <span class="number">0</span>) &#123;   </span><br><span class="line">          mDragHelper.settleCapturedViewAt(<span class="number">0</span>, releasedChild.getTop());  </span><br><span class="line">          invalidate();  </span><br><span class="line">     &#125;</span><br><span class="line">&#125;            </span><br><span class="line">&#125;            </span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span>            </span><br><span class="line">     <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onViewDragStateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;  </span><br><span class="line">              <span class="keyword">super</span>.onViewDragStateChanged(state);</span><br><span class="line"><span class="comment">//滑动停止,并且到达了滑动的判断条件 则回调关闭</span></span><br><span class="line"><span class="keyword">if</span>(mDragHelper.getViewDragState()==ViewDragHelper.STATE_IDLE&amp;&amp;mCallback != <span class="keyword">null</span>&amp;&amp;mDividerWidth==mContentView.getLeft()&amp;&amp;mLastdx&gt;<span class="number">0</span>) &#123;                    </span><br><span class="line">mCallback.onShouldFinish();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><p>1.7 增加对view滑动事件处理,对于以上mDividerWidth我们在onLayout里获取<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mDividerWidth;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);</span><br><span class="line">    mDividerWidth = mDividerView.getWidth();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Notice view 刚初始化的时候就会被调用一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.computeScroll();</span><br><span class="line">      <span class="comment">//        Log.d(TAG, "computeScroll() called with " + "");</span></span><br><span class="line">    <span class="keyword">if</span> (mDragHelper.continueSettling(<span class="keyword">true</span>)) &#123;</span><br><span class="line">        invalidate();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们写完自定义view后还需要自定义一下activity的退出动画~</p><h2 id="2-定义activity的finish动画"><a href="#2-定义activity的finish动画" class="headerlink" title="2.定义activity的finish动画"></a>2.定义activity的finish动画</h2><p>2.1 在anim目录下,创建两个动画xml:<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//no_anim</span><br><span class="line">&lt;alpha</span><br><span class="line"><span class="symbol">android:</span>duration=<span class="string">"300"</span>    </span><br><span class="line"><span class="symbol">xmlns:</span>android=<span class="string">"http://schemas.android.com/apk/res/android"</span>    </span><br><span class="line"><span class="symbol">android:</span>fromAlpha=<span class="string">"1.0"</span></span><br><span class="line"><span class="symbol">android:</span>toAlpha=<span class="string">"1.0"</span></span><br><span class="line">&gt;&lt;/alpha&gt;</span><br><span class="line"></span><br><span class="line">//out_to_right</span><br><span class="line">&lt;translate    </span><br><span class="line"><span class="symbol">xmlns:</span>android=<span class="string">"http://schemas.android.com/apk/res/android"</span>    </span><br><span class="line"><span class="symbol">android:</span>duration=<span class="string">"300"</span>    </span><br><span class="line"><span class="symbol">android:</span>fromXDelta=<span class="string">"0%"</span>    </span><br><span class="line"><span class="symbol">android:</span>toXDelta=<span class="string">"100%"</span>    </span><br><span class="line">&gt;&lt;/translate&gt;</span><br></pre></td></tr></table></figure></p><p>2.2 在activity里设置callback监听,并运用动画<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mSwipeBack.setCallback(<span class="keyword">new</span> SwipeBackFrameLayout.Callback() &#123;    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onShouldFinish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        finish();</span><br><span class="line">        overridePendingTransition(R.anim.no_anim, R.anim.out_to_right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>好了!!~代码量非常少!~就是这么简单~</p><p>源码在我的<a href="https://github.com/AlanCheen/PracticeDemo" target="_blank" rel="noopener">Github</a>上</p><p>如果你觉得喜欢,举手之劳,给我点个赞吧!~<br>如果有什么不好的,不对的欢迎指出!~<br>如果有什么更好的方式,也欢迎指导!!!!</p><p>下次见!~</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自定义View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android获取本地视频文件的截图</title>
      <link href="/blog/3fb99b54.html"/>
      <url>/blog/3fb99b54.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上次在<a href="http://www.jianshu.com/p/5f8a535c2c2e" target="_blank" rel="noopener">异步之AsyncTask(一)</a>中我们讲了AsyncTask的基础,这次来再结合新的功能来巩固一下知识点.</p><p>阅读本文你需要掌握AsyncTask的基本用法,如果不懂AsyncTask,推荐阅读<a href="http://www.jianshu.com/p/5f8a535c2c2e" target="_blank" rel="noopener">异步之AsyncTask(一)</a>.</p><p>通过阅读本文你将能够学到:</p><ol><li>如何创建本地视频缩略图</li><li>如何AsyncTask使用自带线程池</li><li>如何使用回调</li><li>如何防止ListView加载多张图片造成位置混乱</li><li>如何使用内存/磁盘缓存</li></ol><p>由于功能需求要获取本地视频文件的截图,用于显示,而我们所用的图片加载工具为ImageLoader,很不巧,UIL不支持该需求,所以需要我们自己写了.<br>So,动手开始写吧:</p><a id="more"></a><h2 id="1-获取本地视频截图"><a href="#1-获取本地视频截图" class="headerlink" title="1. 获取本地视频截图"></a>1. 获取本地视频截图</h2><p>在尝试过许多方法之后,我最终使用了<strong>ThumbnailUtils</strong>这个类,使用ThumbnailUtils来获取视频的缩略图比较简单,它有个方法可以用来创建视频的缩略图:  </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>Create </span>a<span class="markdown"> video thumbnail for </span>a<span class="markdown"> video. May return null if </span>the<span class="markdown"> video is</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>corrupt or </span>the<span class="markdown"> format is not supported.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>@param filePath </span>the<span class="markdown"> path of video file   文件路径</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>@param kind could be MINI<span class="emphasis">_KIND or MICRO_</span>KIND   种类,该参数决定了获取到的图片的大小 MINI<span class="emphasis">_KIND:512 x 384 ,MICRO_</span>KIND:96 x 96</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*/</span></span></span><br><span class="line">public <span class="keyword">static</span> Bitmap createVideoThumbnail(<span class="built_in">String</span> filePath, <span class="built_in">int</span> kind) </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">有了这个方法就好办了,我们封装一个方法用于获取:</span><br></pre></td></tr></table></figure><p>/**</p><pre><code>* @param videoPath 视频路径* @param width       图片宽度* @param height      图片高度* @param kind      eg:MediaStore.Video.Thumbnails.MICRO_KIND   MINI_KIND: 512 x 384，MICRO_KIND: 96 x 96* @return*/</code></pre><p>private Bitmap getVideoThumbnail(String videoPath, int width, int height,int kind) {<br>        // 获取视频的缩略图<br>        Bitmap bitmap = ThumbnailUtils.createVideoThumbnail(videoPath, kind);<br>       //extractThumbnail 方法二次处理,以指定的大小提取居中的图片,获取最终我们想要的图片<br>        bitmap = ThumbnailUtils.extractThumbnail(bitmap, width, height, ThumbnailUtils.OPTIONS_RECYCLE_INPUT);<br>        return bitmap;<br>    }<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 2.自定义VideoThumbnailLoader</span><br><span class="line">方法我们写完了,但是实际运用时候,发现非常的卡,因为*<span class="strong">*创建bitmap耗时非常严重,达到上百毫秒,按16毫秒1帧算,加载一个缩略图就要卡上好几帧!!卡爆了!!*</span><span class="strong">*</span></span><br><span class="line"><span class="strong">相信机智的你早已经想到,下一步我们需要把创建缩略图的处理放在异步线程中去.</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">另外我们需要考虑一个问题,我们不停地去加载,会发现,*</span><span class="strong">*同一个视频我们加载了好几次缩略图,这个时候怎么办?*</span><span class="strong">*</span></span><br><span class="line"><span class="strong">这个时候就需要引入缓存了,使用过UIL等图片加载工具的同学应该知道了*</span><span class="strong">*一级缓存(内存缓存)*</span><span class="strong">*,*</span><span class="strong">*二级缓存(文件/磁盘缓存)*</span><span class="strong">*这些概念.</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">刚好,我们项目中使用了UIL,所以为了进一步提高加载效率,我顺带加了缓存.写了一个单例VideoThumbnailLoader类,来负责加载.</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">那么问题又来了,我用的单例,那么多图片在加载,我怎么通知界面我加载完成了呢?</span></span><br><span class="line"><span class="strong">这个时候回调就派上大用场了,在VideoThumbnailLoader中我增加了一个回调,通过回调方式告诉外部,我加载完成了,你可以显示了:</span></span><br></pre></td></tr></table></figure></p><p>//自己定义一个回调,通知外部图片加载完毕<br>public interface ThumbnailListener{<br>    void onThumbnailLoadCompleted(String url,ImageView iv,Bitmap bitmap);<br>}<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">好了,思考完毕,准备完毕,上代码!~</span><br><span class="line">最终代码如下:</span><br></pre></td></tr></table></figure></p><p>public class VideoThumbnailLoader {</p><pre><code>private static final String TAG = &quot;VideoThumbnailLoader&quot;;private MemoryCache mMCache;//一级缓存,内存缓存private static VideoThumbnailLoader ins = new VideoThumbnailLoader();public static VideoThumbnailLoader getIns(){    return ins;}private VideoThumbnailLoader() {    mMCache = ImageLoader.getInstance().getMemoryCache();}public void display(TLLiveEntity mEntity,String url,ImageView iv,int width,int height,ThumbnailListener thumbnailListener){    new ThumbnailLoadTask(mEntity,url,iv,width,height,thumbnailListener).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);//使用AsyncTask自带的线程池}private class ThumbnailLoadTask extends AsyncTask&lt;Void, Void, Bitmap&gt; {    private String url;    private ImageView iv;    private ThumbnailListener thumbnailListener;    private int width;    private int height;    public ThumbnailLoadTask(String url,ImageView iv,int width,int height,ThumbnailListener thumbnailListener){        this.url = url;        this.iv = iv;        this.width = width;        this.height = height;        this.thumbnailListener = thumbnailListener;    }    @Override    protected Bitmap doInBackground(Void... params) {        /**         * 注意,由于我们使用了缓存,所以在加载缩略图之前,我们需要去缓存里读取,如果缓存里有,我们则直接获取,如果没有,则去加载.并且加载完成之后记得放入缓存.         */        Bitmap bitmap = null;        if (!TextUtils.isEmpty(url)) {            String key = getMemoryKey(url);            bitmap = mMCache.get(key);//先去内存缓存取            if (bitmap == null||bitmap.isRecycled()) {                File file = TLFileUtils.getExternalFile(path, &quot;xxx.png&quot;);//创建文件,这里由于项目原因,我就随便写一个,实际情况不是这样,大家留意一下                if (null != file &amp;&amp; file.exists()) {//去磁盘缓存取                    bitmap = BitmapFactory.decodeFile(file.getPath());                    if (null==bitmap) {                        bitmap = getVideoThumbnail(url, width, height, MediaStore.Video.Thumbnails.MICRO_KIND);                        //将图片保存到磁盘文件,作为缓存                        BitmapUtils.saveBitmapToFile(file, bitmap,Bitmap.CompressFormat.PNG);                    }                } else {                    bitmap = getVideoThumbnail(url, width, height, MediaStore.Video.Thumbnails.MICRO_KIND);                    if (null==bitmap) {                        bitmap = getVideoThumbnail(url, width, height, MediaStore.Video.Thumbnails.MICRO_KIND);                        //将图片保存到磁盘文件,作为缓存                        BitmapUtils.saveBitmapToFile(file, bitmap,Bitmap.CompressFormat.PNG);                    }                }                if (null != bitmap) {                    mMCache.put(key, bitmap);//存入内存缓存                }            }        }        return bitmap;    }    @Override    protected void onPostExecute(Bitmap bitmap) {        super.onPostExecute(bitmap);        thumbnailListener.onThumbnailLoadCompleted(url, iv, bitmap);//回调    }}/** * @param videoPath 视频路径 * @param width * @param height * @param kind      eg:MediaStore.Video.Thumbnails.MICRO_KIND   MINI_KIND: 512 x 384，MICRO_KIND: 96 x 96 * @return */private Bitmap getVideoThumbnail(String videoPath, int width, int height,                                 int kind) {    // 获取视频的缩略图    Bitmap bitmap = ThumbnailUtils.createVideoThumbnail(videoPath, kind);    bitmap = ThumbnailUtils.extractThumbnail(bitmap, width, height, ThumbnailUtils.OPTIONS_RECYCLE_INPUT);    return bitmap;}/** *  imageloader 的内存缓存的 key 以_ 结尾  截取key比较的时候如果没有加_ 会报错崩溃,所以自己自定义 * @param filePath 文件地址 * @return */private  String getMemoryKey(String filePath) {    String key ;    int index = filePath.lastIndexOf(&quot;/&quot;);    key = filePath.substring(index + 1, filePath.length())+&quot;_&quot;;    return key;}//自己定义一个回调,通知外部图片加载完毕public interface ThumbnailListener{    void onThumbnailLoadCompleted(String url,ImageView iv,Bitmap bitmap);}}</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">在需要加载的地方使用:</span><br></pre></td></tr></table></figure><p>mHolder.ivBg.setTag(imgUrl);  //这里注意,我们给imageview设置了一个Tag,后面自有妙用<br>VideoThumbnailLoader.getIns().display(entity,url, mHolder.ivBg,mImgWidth,mImgHeight, new VideoThumbnailLoader.ThumbnailListener() {<br>            @Override<br>            public void onThumbnailLoadCompleted(String url, ImageView iv, Bitmap bitmap) {<br>                //通过判断imageview的tag,和我们加载的图片的url是否是同一个来判断是否显示,这样可以避免滑动造成的位置错乱等问题.<br>                String tag = (String) iv.getTag();<br>                if (null != bitmap&amp;&amp;null!=tag&amp;&amp;tag.equals(url)) {<br>                    iv.setImageBitmap(bitmap);<br>                }else{<br>                    iv.setImageResource(R.mipmap.defaultvideo);<br>                }<br>            }<br>        });<br><code>`</code></p><p>至此功能已经实现,并且使用了线程池,缓存,效率比一开始提高不少,不过还是有地方可以优化,至于优化,后面有机会再写吧~</p><p>好了,本文结束,如果有疑问,欢迎提问,如果喜欢,欢迎点赞,欢迎关注我,关注我的专题~~</p><p>谢谢,下次见!</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AsyncTask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InstalMaterial学习笔记之Reveal效果</title>
      <link href="/blog/42329287.html"/>
      <url>/blog/42329287.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文记录<a href="https://github.com/frogermcs/InstaMaterial" target="_blank" rel="noopener">开源项目 InstalMaterial</a>学习到的Reveal效果<br>国内有对应博客的<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0204/2415.html" target="_blank" rel="noopener">翻译</a></p><p>先看一下效果图:<br><img src="/img/reveal.gif" alt="最后效果图"></p><a id="more"></a><p><strong>惯例,不过这次是我学到了什么</strong></p><ol><li>对自定义属性使用属性动画</li><li>属性动画,get方法不一定需要</li><li>最重要的是ViewTreeObserver.OnPreDrawListener()的使用,另一种过渡动画的实现方式</li></ol><p>OK,开始吧</p><h5 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h5><p>仔细看动画效果,其实就是一个半径不断变大的圆</p><p>那么来实现这个效果吧</p><ol><li>先定义个类RevealView,重载构造方法</li><li>增加一个成员变量 radius 表示圆的半径</li><li>增加一个Paint变量 mPaint 用来画</li></ol><p>如此后代码如下:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public RevealView(<span class="built_in">Context</span> <span class="built_in">context</span>) &#123;</span><br><span class="line">    super(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">    init()<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public RevealView(<span class="built_in">Context</span> <span class="built_in">context</span>, AttributeSet attrs) &#123;</span><br><span class="line">    super(<span class="built_in">context</span>, attrs)<span class="comment">;</span></span><br><span class="line">    init()<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public RevealView(<span class="built_in">Context</span> <span class="built_in">context</span>, AttributeSet attrs, int defStyleAttr) &#123;    super(<span class="built_in">context</span>, attrs, defStyleAttr)<span class="comment">;</span></span><br><span class="line">    init()<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void init() &#123;</span><br><span class="line">    mPaint=new Paint()<span class="comment">;</span></span><br><span class="line">    mPaint.setColor(getResources().getColor(R.color.primary_dark))<span class="comment">; </span></span><br><span class="line">mPaint.setAntiAlias(true)<span class="comment">;</span></span><br><span class="line">    mPaint.setStyle(Paint.Style.FILL)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">private Paint mPaint<span class="comment">;</span></span><br><span class="line">private int radius<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>#####接下来,我们重写onDraw,画个圆</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;    </span><br><span class="line"><span class="keyword">super</span>.onDraw(canvas);    </span><br><span class="line"><span class="comment">//原点是中心    </span></span><br><span class="line">canvas.drawCircle(getWidth() / <span class="number">2</span>, getHeight() / <span class="number">2</span>, radius, mPaint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####接下去就是让radius得值不断发生变化了<br>到这里,可能有同学会想着起个thread不停去赋值,再invalidate.<br>其实不必这么麻烦,我们使用属性动画即可:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里我计算了斜对角线的长度,这样可以保证画的圆能够保证覆盖整个view</span></span><br><span class="line"><span class="keyword">int</span> maxRadius = (<span class="keyword">int</span>) (Math.<span class="built_in">sqrt</span>(Math.<span class="built_in">pow</span>(getHeight(), <span class="number">2</span>)+ Math.<span class="built_in">pow</span>(getWidth(), <span class="number">2</span>)));</span><br><span class="line">ObjectAnimator revealAnimator = ObjectAnimator.ofInt(<span class="keyword">this</span>, <span class="string">"radius"</span>, <span class="number">0</span>,maxRadius).setDuration(<span class="number">300</span>);</span><br><span class="line">revealAnimator.setInterpolator(<span class="keyword">new</span> AccelerateInterpolator());</span><br><span class="line">revealAnimator.start();</span><br></pre></td></tr></table></figure><p>到这里熟悉属性动画的同学可能就知道,还差了getter setter方法<br><strong>Tip:其实事实上getter方法不是必须的,少了setter方法也不会崩溃,只是动画没有效果而已</strong><br>注意:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Notice 这里传入了两个值 如果只传了一个,则会在动画开始时候去调用gettter方法</span></span><br><span class="line">ObjectAnimator.ofInt(<span class="keyword">this</span>, <span class="string">"radius"</span>, <span class="number">0</span>,maxRadius).setDuration(<span class="number">300</span>);</span><br></pre></td></tr></table></figure></p><p>OK,让我们加入setter方法:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setRadius(int radius) &#123;</span><br><span class="line">    this.radius = radius;</span><br><span class="line">    Log.d(TAG, <span class="string">"setRadius "</span>+radius);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>恩,OK,问自己一下,这样,就好了吗?<br>答案是,没有!<br>我们还需要对setter方法加工一下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">int</span> radius)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    Log.d(TAG, <span class="string">"setRadius "</span>+radius);</span><br><span class="line">    <span class="comment">//Notice 调用invalidate 之后 onDraw才会被调用</span></span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此,我们运行一下:</p><p><img src="http://upload-images.jianshu.io/upload_images/531570-0c0d9cf4e335246a.gif" alt="reveal_效果1阶段.gif"></p><p>初始效果已经出来了,但是你会发现,动画结束后,我们的revealview把其他View都挡住了.</p><p>呵呵,这个还不简单吗?动画结束后给gone了不得了嘛?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新增一个callback 回调动画结束</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(Callback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callback = callback;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Callback callback;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onRevealEnd</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在activity里设置</span></span><br><span class="line">mVReveal.setCallback(<span class="keyword">new</span> RevealView.Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRevealEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//隐藏</span></span><br><span class="line">                mVReveal.setVisibility(View.GONE);</span><br><span class="line"><span class="comment">//                todo 其他事情</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>然后跑起来试试:<br><img src="http://upload-images.jianshu.io/upload_images/531570-225b16ca746c58ae.gif" alt="第一阶段效果.gif"></p><p>还不错吧?</p><p>##接下来我们运用到Activity跳转<br>这个时候我们需要用到<strong>ViewTreeObserver.OnPreDrawListener()</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在跳转的activity里</span></span><br><span class="line">mVReveal.getViewTreeObserver().addOnPreDrawListener(<span class="keyword">new</span> ViewTreeObserver.OnPreDrawListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onPreDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//必须remove掉 不然会重复调用</span></span><br><span class="line">        mVReveal.getViewTreeObserver().removeOnPreDrawListener(<span class="keyword">this</span>);</span><br><span class="line">        mVReveal.startReveal();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;&#125;);</span><br></pre></td></tr></table></figure><p>//按钮点击事件<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Intent</span> <span class="keyword">intent</span> = new <span class="keyword">Intent</span>(this, RevealActivity.<span class="keyword">class</span>);<span class="keyword">intent</span>.putExtra(<span class="string">"location"</span>, location);startActivity(<span class="keyword">intent</span>);overridePendingTransition(<span class="number">0</span>, <span class="number">0</span>);//Notice 这个绝对不能省..不然没有效果</span><br></pre></td></tr></table></figure></p><p>好了,差不多介绍到这里..<br>不过其实还有其他的优化扩展,<br>1.比如传坐标,指定圆心开始reveal<br>2.reveal结束后继续其他的动画<br>大家自己试试吧:<a href="https://github.com/AlanCheen/PracticeDemo" target="_blank" rel="noopener">Github</a>.</p><p>###最后总结下</p><ol><li>InstalMaterial 是一个值得你认真去学习的开源项目.</li><li>时间允许的话一定要动手实践,不要觉得看着简单就以为自己会了,其实没你想的那么简单.就像我,看着这个效果很简单,原本觉得不用这么麻烦就可以实现,结果,最后还是一步一步照着frogermcs的代码写了下去,这样才能真正学到东西.</li><li>自学不易,请坚持!</li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自定义View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一步一步教你实现Periscope点赞效果</title>
      <link href="/blog/ed8278fb.html"/>
      <url>/blog/ed8278fb.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在视频应用越来越火,Periscope火起来后,国内也出现了不少跟风者,界面几乎跟Periscope一模一样.Periscope确实不错,点赞的效果也让人眼前一亮,很漂亮,于是乎,我就想着自己实现一下.</p><p>最终的效果图如下:</p><p><img src="http://ww2.sinaimg.cn/large/98900c07gw1f5lp94avvwg20el0gz146.gif" alt="最终效果图"></p><p>录制的效果不太好,手机运行起来还是挺好看的.<br>不能说一模一样,但是也差不多了吧!~<br><a id="more"></a></p><p>惯例:<br><strong>通过本文你将学习到什么?</strong></p><ol><li>自定义view的一些基础方法以及一些注意点</li><li>随机数的使用</li><li>插补器的使用</li><li><strong>属性动画的高级用法</strong></li><li><strong>贝塞尔曲线在Android中的实现以及应用</strong></li></ol><p>OK,如果感兴趣,那么跟着我来看看这个效果是如何实现的吧!</p><p>##仔细看看,这个效果中包含了什么细节?</p><ol><li>爱心出现在底部并且水平居中</li><li>爱心的颜色/类型 随机</li><li>爱心进入时候有一个缩放的动画</li><li>缩放完毕后,开始变速向上移动,并且伴随alpha渐变效果</li><li>爱心移动的轨迹光滑,是个曲线</li></ol><p><strong>OK,接下去我们一个一个去实现它</strong></p><h2 id="1-第一步-底部-水平居中"><a href="#1-第一步-底部-水平居中" class="headerlink" title="1.第一步,底部,水平居中"></a>1.第一步,底部,水平居中</h2><p>这个我相信大家很容易想到使用RelativeLayout,对,没错,那么我们先定义一个类姑且叫FavorLayout吧,继承自RelativeLayout,并且重载构造函数,并定义一些变量.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FavorLayout</span> <span class="keyword">extends</span> <span class="title">RelativeLayout</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();<span class="comment">//用于实现随机功能</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> dHeight;<span class="comment">//爱心的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> dWidth;<span class="comment">//爱心的宽度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mHeight;<span class="comment">//FavorLayout的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mWidth;<span class="comment">//FavorLayout的宽度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FavorLayout</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FavorLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">super</span>(context, attrs);</span><br><span class="line"> <span class="comment">//为了显示区域,我设置了一个背景颜色,随意</span></span><br><span class="line">  setBackgroundColor(getResources().getColor(R.color.bg));</span><br><span class="line"><span class="comment">//init里做一些初始化变量的操作</span></span><br><span class="line">  init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//重写onMeasure 获取控件宽高</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        <span class="comment">//注意!!  获取本身的宽高 需要在测量之后才有宽高</span></span><br><span class="line">        mWidth = getMeasuredWidth();</span><br><span class="line">        mHeight = getMeasuredHeight();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义完毕后我们来实现底部,水平居中:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个LayoutParams 用它来控制子view的位置</span></span><br><span class="line">        <span class="keyword">private</span> LayoutParams lp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//底部 并且 水平居中</span></span><br><span class="line">        lp = <span class="keyword">new</span> LayoutParams(dWidth, dHeight);</span><br><span class="line">        lp.addRule(CENTER_HORIZONTAL, <span class="keyword">TRUE</span>); <span class="comment">//这里的TRUE 要注意 不是true</span></span><br><span class="line">        lp.addRule(ALIGN_PARENT_BOTTOM, <span class="keyword">TRUE</span>);</span><br><span class="line">        <span class="comment">//好了,之后只要给子view设置LayoutParams就可以实现了</span></span><br></pre></td></tr></table></figure></p><h2 id="2-接下来实现第二步-随机爱心"><a href="#2-接下来实现第二步-随机爱心" class="headerlink" title="2.接下来实现第二步,随机爱心"></a>2.接下来实现第二步,随机爱心</h2><p>在Android实现随机数可以使用Random类,这里我只准备了3种不同的爱心,来看看代码如何实现吧:<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先定义 3个代表不同爱心的drawable,以及他们的和drawables</span></span><br><span class="line">    <span class="keyword">private</span> Drawable <span class="built_in">red</span> ;</span><br><span class="line">    <span class="keyword">private</span> Drawable yellow ;</span><br><span class="line">    <span class="keyword">private</span> Drawable <span class="built_in">blue</span> ;</span><br><span class="line">    <span class="keyword">private</span> Drawable[] drawables ;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//接下去我们初始化:</span></span><br><span class="line">       <span class="comment">//初始化显示的图片</span></span><br><span class="line">        drawables = <span class="keyword">new</span> Drawable[<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">red</span> = getResources().getDrawable(R.mipmap.<span class="built_in">red</span>);</span><br><span class="line">        yellow = getResources().getDrawable(R.mipmap.yellow);</span><br><span class="line">        <span class="built_in">blue</span> = getResources().getDrawable(R.mipmap.<span class="built_in">blue</span>);</span><br><span class="line">        <span class="comment">//赋值给drawables</span></span><br><span class="line">        drawables[<span class="number">0</span>]=<span class="built_in">red</span>;</span><br><span class="line">        drawables[<span class="number">1</span>]=yellow;</span><br><span class="line">        drawables[<span class="number">2</span>]=<span class="built_in">blue</span>;</span><br></pre></td></tr></table></figure></p><p>这样,下次取值时候只要使用如下代码,就能随机获取到爱心了:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drawables[<span class="built_in">random</span>.nextInt(<span class="number">3</span>)]<span class="comment">//表示0-2的随机数,注意,3是取不到的,是个开区间</span></span><br></pre></td></tr></table></figure></p><h2 id="3-好了随机的爱心问题搞定-接下去让我们做缩放动画吧"><a href="#3-好了随机的爱心问题搞定-接下去让我们做缩放动画吧" class="headerlink" title="3.好了随机的爱心问题搞定,接下去让我们做缩放动画吧~"></a>3.好了随机的爱心问题搞定,接下去让我们做缩放动画吧~</h2><p>说到Android动画,我们以前常用Animation,它通常情况下能满足我们的需求,但是它的功能比较弱,并不是很好用.好在3.0后,强大的属性动画的出现,让动画在Android中实现起来变得非常容易.如果你还不知道属性动画怎么使用,赶紧去了解一下吧!<br>(以前在eoe上发过一篇帖子,很基础,<a href="http://www.eoeandroid.com/thread-563698-1-1.html" target="_blank" rel="noopener">ObjectAnimator的运用</a>,有兴趣可以看下,提前说下,那是很久以前写的!)</p><p>废话不说了,那么具体怎么做呢,来看代码吧:<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我封装了一个方法  利用ObjectAnimator AnimatorSet来实现 alpha以及x,y轴的缩放功能</span></span><br><span class="line"><span class="comment">//target就是爱心</span></span><br><span class="line"><span class="keyword">private</span> <span class="function">AnimatorSet <span class="title">getEnterAnimtor</span><span class="params">(<span class="keyword">final</span> View <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ObjectAnimator alpha = ObjectAnimator.ofFloat(<span class="keyword">target</span>,View.ALPHA, <span class="number">0.2</span>f, <span class="number">1</span>f);</span><br><span class="line">        ObjectAnimator scaleX = ObjectAnimator.ofFloat(<span class="keyword">target</span>,View.SCALE_X, <span class="number">0.2</span>f, <span class="number">1</span>f);</span><br><span class="line">        ObjectAnimator scaleY = ObjectAnimator.ofFloat(<span class="keyword">target</span>,View.SCALE_Y, <span class="number">0.2</span>f, <span class="number">1</span>f);</span><br><span class="line">        AnimatorSet enter = <span class="keyword">new</span> AnimatorSet();</span><br><span class="line">        enter.setDuration(<span class="number">500</span>);</span><br><span class="line">        enter.setInterpolator(<span class="keyword">new</span> LinearInterpolator());</span><br><span class="line">        enter.playTogether(alpha,scaleX, scaleY);</span><br><span class="line">        enter.setTarget(<span class="keyword">target</span>);</span><br><span class="line">        <span class="keyword">return</span> enter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>OK,缩放功能已经加了,第一个阶段也算是完成了,我们来看看效果吧:</p><p>偶,忘记说了,我们给外面的按钮设置点击事件,并且提供外部一个方法调用:<br><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mBtnStartAnim.setOnClickListener(<span class="function"><span class="keyword">new</span> <span class="title">View</span>.<span class="title">OnClickListener</span>() &#123;</span></span><br><span class="line"><span class="function">            @<span class="title">Override</span></span></span><br><span class="line"><span class="function">            <span class="title">public</span> <span class="title">void</span> <span class="title">onClick</span>(<span class="type">View</span> v) &#123;</span></span><br><span class="line"><span class="function">                <span class="title">mFavorLayout</span>.<span class="title">addFavor</span>();</span></span><br><span class="line"><span class="function">            &#125;</span></span><br><span class="line"><span class="function">        &#125;);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">void</span> <span class="title">addFavor</span>() &#123;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">ImageView</span> <span class="title">imageView</span> = <span class="title">new</span> <span class="title">ImageView</span>(getContext());</span></span><br><span class="line"><span class="function">        <span class="comment">//随机选一个</span></span></span><br><span class="line"><span class="function">        <span class="title">imageView</span>.<span class="title">setImageDrawable</span>(drawables[random.nextInt(<span class="number">3</span>)]);</span></span><br><span class="line"><span class="function">        <span class="comment">// 设置底部 水平居中</span></span></span><br><span class="line"><span class="function">        <span class="title">imageView</span>.<span class="title">setLayoutParams</span>(lp);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">addView</span>(imageView);</span></span><br><span class="line"><span class="function">        <span class="title">Log</span>.<span class="title">v</span>(<span class="type">TAG</span>, "add后子view数:"+getChildCount());</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">Animator</span> <span class="title">set</span> = <span class="title">getEnterAnimtor</span>(imageView);</span></span><br><span class="line"><span class="function">        <span class="title">set</span>.<span class="title">start</span>();</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p>好了这下可以运行看看效果啦:<br><img src="http://upload-images.jianshu.io/upload_images/531570-6b9b34c1061ba665.gif" alt="缩放效果图.gif"></p><p>可以看到,爱心的颜色是随机的,并且也有了缩放动画.</p><p>到此,简单的功能我们已经完成了,那么接下去就是大头了.</p><h2 id="4-实现贝塞尔曲线效果"><a href="#4-实现贝塞尔曲线效果" class="headerlink" title="4.实现贝塞尔曲线效果"></a>4.实现贝塞尔曲线效果</h2><p>我们怎么让爱心按照曲线移动?而且还有随机呢?</p><p>OK,接下去就是本文的主角贝塞尔曲线登场的时刻啦,这也是我实现这个效果学到的最重要的知识.</p><p>我是看这篇文章学习了解<a href="http://blog.csdn.net/androidzhaoxiaogang/article/details/8680330" target="_blank" rel="noopener">贝塞尔曲线</a>的,推荐一下.<br>简单来说,就是给定几个点,计算出一个曲线.(其实复杂得我看不懂)</p><p>简单了解贝塞尔曲线后,发现<strong>三次方贝塞尔曲线</strong> 符合我们的要求<br>公式:</p><p><img src="http://upload-images.jianshu.io/upload_images/531570-b905b01c6e5f63d6.png" alt="公式.png"></p><p>拿到了公式,先不要着急,我们先思考一下,明确一下它的参数是干什么的:<br><strong>公式中需要四个P,P0,是我们的起点,P3是终点,P1,P2是途径的两个点</strong><br><strong>而t则是我们的一个因子,取值范围是0-1,熟悉动画的同学应该就明白,0-1,对动画的作用有多么重大!!!所以看到这个,真是笑了~~</strong></p><p>因为需要自己实现贝塞尔,所以我想到了属性动画中的TypeEvaluator,它就是我们需要的.</p><p>好了,接下来,我们来实现吧~</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们自定义一个BezierEvaluator 实现 TypeEvaluator</span></span><br><span class="line"><span class="comment">//由于我们view的移动需要控制x y 所以就传入PointF 作为参数,是不是感觉完全契合??</span></span><br><span class="line">public <span class="keyword">class</span> BezierEvaluator <span class="keyword">implements</span> TypeEvaluator&lt;PointF&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private PointF pointF1;<span class="comment">//途径的两个点</span></span><br><span class="line">    private PointF pointF2;</span><br><span class="line">    public BezierEvaluator(PointF pointF1,PointF pointF2)&#123;</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.pointF1</span> = pointF1;</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.pointF2</span> = pointF2;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public PointF evaluate(float <span class="keyword">time</span>, PointF startValue,</span><br><span class="line">                           PointF endValue) &#123;</span><br><span class="line"></span><br><span class="line">        float timeLeft = <span class="number">1</span><span class="variable">.0f</span> - <span class="keyword">time</span>;</span><br><span class="line">        PointF point = <span class="keyword">new</span> PointF();<span class="comment">//结果</span></span><br><span class="line"></span><br><span class="line">        PointF point0 = (PointF)startValue;<span class="comment">//起点</span></span><br><span class="line"></span><br><span class="line">        PointF point3 = (PointF)endValue;<span class="comment">//终点</span></span><br><span class="line">        <span class="comment">//代入公式</span></span><br><span class="line">        point<span class="variable">.x</span> = timeLeft * timeLeft * timeLeft * (point0<span class="variable">.x</span>)</span><br><span class="line">                + <span class="number">3</span> * timeLeft * timeLeft * <span class="keyword">time</span> * (pointF1<span class="variable">.x</span>)</span><br><span class="line">                + <span class="number">3</span> * timeLeft * <span class="keyword">time</span> * <span class="keyword">time</span> * (pointF2<span class="variable">.x</span>)</span><br><span class="line">                + <span class="keyword">time</span> * <span class="keyword">time</span> * <span class="keyword">time</span> * (point3<span class="variable">.x</span>);</span><br><span class="line"></span><br><span class="line">        point<span class="variable">.y</span> = timeLeft * timeLeft * timeLeft * (point0<span class="variable">.y</span>)</span><br><span class="line">                + <span class="number">3</span> * timeLeft * timeLeft * <span class="keyword">time</span> * (pointF1<span class="variable">.y</span>)</span><br><span class="line">                + <span class="number">3</span> * timeLeft * <span class="keyword">time</span> * <span class="keyword">time</span> * (pointF2<span class="variable">.y</span>)</span><br><span class="line">                + <span class="keyword">time</span> * <span class="keyword">time</span> * <span class="keyword">time</span> * (point3<span class="variable">.y</span>);</span><br><span class="line">        <span class="keyword">return</span> point;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这一步,只要我们传入两个PonitF就能得到一个贝塞尔曲线了.接下来我们在FavorLayout中定义获取一个贝塞尔动画的方法:<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function">ValueAnimator <span class="title">getBezierValueAnimator</span><span class="params">(View <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化一个BezierEvaluator</span></span><br><span class="line">        BezierEvaluator evaluator = <span class="keyword">new</span> BezierEvaluator(getPointF(<span class="number">2</span>),getPointF(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里最好画个图 理解一下 传入了起点 和 终点</span></span><br><span class="line">        ValueAnimator animator = ValueAnimator.ofObject(evaluator,<span class="keyword">new</span> PointF((mWidth-dWidth)/<span class="number">2</span>,mHeight-dHeight),<span class="keyword">new</span> PointF(random.nextInt(getWidth()),<span class="number">0</span>));<span class="comment">//随机</span></span><br><span class="line">        animator.addUpdateListener(<span class="keyword">new</span> BezierListenr(<span class="keyword">target</span>));</span><br><span class="line">        animator.setTarget(<span class="keyword">target</span>);</span><br><span class="line">        animator.setDuration(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> animator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里涉及到另外一个方法:getPointF(),这个是我用来获取途径的两个点</span></span><br><span class="line"><span class="comment">// 这里的取值可以随意调整,调整到你希望的样子就好</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取中间的两个 点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> scale</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function">PointF <span class="title">getPointF</span><span class="params">(<span class="keyword">int</span> scale)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        PointF pointF = <span class="keyword">new</span> PointF();</span><br><span class="line">        pointF.x = random.nextInt((mWidth - <span class="number">100</span>));<span class="comment">//减去100 是为了控制 x轴活动范围,看效果 随意~~</span></span><br><span class="line">        <span class="comment">//再Y轴上 为了确保第二个点 在第一个点之上,我把Y分成了上下两半 这样动画效果好一些  也可以用其他方法</span></span><br><span class="line">        pointF.y = random.nextInt((mHeight - <span class="number">100</span>))/scale;</span><br><span class="line">        <span class="keyword">return</span> pointF;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>眼尖的你一定发现了我给动画加了一个监听,<strong>只有在回调里使用了计算的值,才能真正做到曲线运动</strong>,否则没有效果哦:<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BezierListenr</span> <span class="keyword">implements</span> <span class="title">ValueAnimator</span>.<span class="title">AnimatorUpdateListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> View <span class="keyword">target</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BezierListenr</span><span class="params">(View <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//这里获取到贝塞尔曲线计算出来的的x y值 赋值给view 这样就能让爱心随着曲线走啦</span></span><br><span class="line">            PointF pointF = (PointF) animation.getAnimatedValue();</span><br><span class="line">            <span class="keyword">target</span>.setX(pointF.x);</span><br><span class="line">            <span class="keyword">target</span>.setY(pointF.y);</span><br><span class="line">            <span class="comment">// 这里偷个懒,顺便做一个alpha动画,这样alpha渐变也完成啦</span></span><br><span class="line">            <span class="keyword">target</span>.setAlpha(<span class="number">1</span>-animation.getAnimatedFraction());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>好了这个方法写完,让我们来测试一下效果如何吧!<br>对了,需要修改一下addFavor方法<br><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void addFavor() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ImageView</span> imageView = <span class="function"><span class="keyword">new</span> <span class="title">ImageView</span>(getContext());</span></span><br><span class="line"><span class="function">        <span class="comment">//随机选一个</span></span></span><br><span class="line"><span class="function">        <span class="title">imageView</span>.<span class="title">setImageDrawable</span>(drawables[random.nextInt(<span class="number">3</span>)]);</span></span><br><span class="line"><span class="function">        <span class="title">imageView</span>.<span class="title">setLayoutParams</span>(lp);</span></span><br><span class="line"><span class="function">        <span class="title">addView</span>(imageView);</span></span><br><span class="line"><span class="function">        <span class="title">Log</span>.<span class="title">v</span>(<span class="type">TAG</span>, "add后子view数:"+getChildCount());</span></span><br><span class="line"><span class="function">        <span class="title">getBezierValueAnimator</span>(imageView).<span class="title">start</span>();</span></span><br><span class="line"><span class="function">    &#125;</span></span><br></pre></td></tr></table></figure></p><p>好了,点击一下,看看效果吧!!!<br><img src="http://upload-images.jianshu.io/upload_images/531570-bb9b19d2ace41d0a.gif" alt="Bezier效果图.gif"></p><p>怎么样?还不错吧???</p><p>缩放的效果我们做了,曲线效果也有了<br>那么接下去把他们连起来即可!!~</p><h2 id="5-收尾-最终效果"><a href="#5-收尾-最终效果" class="headerlink" title="5.收尾,最终效果"></a>5.收尾,最终效果</h2><h5 id="5-1-实现变速"><a href="#5-1-实现变速" class="headerlink" title="5.1 实现变速"></a>5.1 实现变速</h5><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我为了实现 变速效果 挑选了几种插补器</span></span><br><span class="line"><span class="keyword">private</span> Interpolator <span class="built_in">line</span> = <span class="keyword">new</span> LinearInterpolator();<span class="comment">//线性</span></span><br><span class="line">    <span class="keyword">private</span> Interpolator acc = <span class="keyword">new</span> AccelerateInterpolator();<span class="comment">//加速</span></span><br><span class="line">    <span class="keyword">private</span> Interpolator dce = <span class="keyword">new</span> DecelerateInterpolator();<span class="comment">//减速</span></span><br><span class="line">    <span class="keyword">private</span> Interpolator accdec = <span class="keyword">new</span> AccelerateDecelerateInterpolator();<span class="comment">//先加速后减速</span></span><br><span class="line">     <span class="comment">// 在init中初始化</span></span><br><span class="line">    <span class="keyword">private</span> Interpolator[] interpolators ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终 init方法长这样:</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> init() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化显示的图片</span></span><br><span class="line">        drawables = <span class="keyword">new</span> Drawable[<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">red</span> = getResources().getDrawable(R.mipmap.<span class="built_in">red</span>);</span><br><span class="line">        yellow = getResources().getDrawable(R.mipmap.yellow);</span><br><span class="line">        <span class="built_in">blue</span> = getResources().getDrawable(R.mipmap.<span class="built_in">blue</span>);</span><br><span class="line"></span><br><span class="line">        drawables[<span class="number">0</span>]=<span class="built_in">red</span>;</span><br><span class="line">        drawables[<span class="number">1</span>]=yellow;</span><br><span class="line">        drawables[<span class="number">2</span>]=<span class="built_in">blue</span>;</span><br><span class="line">        <span class="comment">//获取图的宽高 用于后面的计算</span></span><br><span class="line">        <span class="comment">//注意 我这里3张图片的大小都是一样的,所以我只取了一个</span></span><br><span class="line">        dHeight = <span class="built_in">red</span>.getIntrinsicHeight();</span><br><span class="line">        dWidth = <span class="built_in">red</span>.getIntrinsicWidth();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//底部 并且 水平居中</span></span><br><span class="line">        lp = <span class="keyword">new</span> LayoutParams(dWidth, dHeight);</span><br><span class="line">        lp.addRule(CENTER_HORIZONTAL, TRUE);<span class="comment">//这里的TRUE 要注意 不是true</span></span><br><span class="line">        lp.addRule(ALIGN_PARENT_BOTTOM, TRUE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化插补器</span></span><br><span class="line">        interpolators = <span class="keyword">new</span> Interpolator[<span class="number">4</span>];</span><br><span class="line">        interpolators[<span class="number">0</span>] = <span class="built_in">line</span>;</span><br><span class="line">        interpolators[<span class="number">1</span>] = acc;</span><br><span class="line">        interpolators[<span class="number">2</span>] = dce;</span><br><span class="line">        interpolators[<span class="number">3</span>] = accdec;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="5-2-合并前俩种动画-做成最终动画"><a href="#5-2-合并前俩种动画-做成最终动画" class="headerlink" title="5.2 合并前俩种动画,做成最终动画"></a>5.2 合并前俩种动画,做成最终动画</h5><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private Animator getAnimator(View target)&#123;</span><br><span class="line">        AnimatorSet set = getEnterAnimtor(target)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        ValueAnimator <span class="keyword">bezierValueAnimator </span>= getBezierValueAnimator(target)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        AnimatorSet finalSet = new AnimatorSet()<span class="comment">;</span></span><br><span class="line">        finalSet.playSequentially(set)<span class="comment">;</span></span><br><span class="line">        finalSet.playSequentially(set, <span class="keyword">bezierValueAnimator);</span></span><br><span class="line"><span class="keyword"> </span>       finalSet.setInterpolator(interpolators[<span class="built_in">random</span>.nextInt(<span class="number">4</span>)])<span class="comment">;//实现随机变速</span></span><br><span class="line">        finalSet.setTarget(target)<span class="comment">;</span></span><br><span class="line">        return finalSet<span class="comment">;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="5-3-最后修改addFavor方法"><a href="#5-3-最后修改addFavor方法" class="headerlink" title="5.3 最后修改addFavor方法:"></a>5.3 最后修改addFavor方法:</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFavor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ImageView imageView = <span class="keyword">new</span> ImageView(getContext());</span><br><span class="line">        <span class="comment">//随机选一个</span></span><br><span class="line">        imageView.setImageDrawable(drawables[random.nextInt(<span class="number">3</span>)]);</span><br><span class="line">        imageView.setLayoutParams(lp);</span><br><span class="line"></span><br><span class="line">        addView(imageView);</span><br><span class="line">        Log.v(TAG, <span class="string">"add后子view数:"</span>+getChildCount());</span><br><span class="line"></span><br><span class="line">        Animator <span class="built_in">set</span> = getAnimator(imageView);</span><br><span class="line">        <span class="built_in">set</span>.addListener(<span class="keyword">new</span> AnimEndListener(imageView));</span><br><span class="line">        <span class="built_in">set</span>.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在修改addFavor方法的同时我增加了一个监听,目的是为了在动画结束后,把爱心移除,不然,子view只增不减!!!!<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimEndListener</span> <span class="keyword">extends</span> <span class="title">AnimatorListenerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> View <span class="keyword">target</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AnimEndListener</span><span class="params">(View <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onAnimationEnd(animation);</span><br><span class="line">            <span class="comment">//因为不停的add 导致子view数量只增不减,所以在view动画结束后remove掉</span></span><br><span class="line">            removeView((<span class="keyword">target</span>));</span><br><span class="line">            Log.v(TAG, <span class="string">"removeView后子view数:"</span>+getChildCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>呼!呼!~好了,最终的效果我们也实现了.</p><p>实际上,实现这个效果,我遇到了不少困难与问题,逐个击破后才迎来了最后的这个效果,收获颇丰.</p><p>希望大家看完后都能亲自动手去实现一下,相信你会学到更多东西!</p><p>写到这里,我发现,写文章比敲代码难多了啊!!!写文章花费的时间不少于我实现这个功能花费的时间!!!!真心的!!!!!(不知不觉,到端午了)</p><p>So,在这里无耻的请求大家,如果喜欢,请点赞,帮忙分享一下吧!~</p><p>欢迎关注我,第一时间获取新消息~</p><p>最后,祝大家端午快乐!</p><p>下次见~~</p><p><strong>更新</strong><br>源码已经上传至jcenter,集成超级方便—&gt;<a href="https://github.com/AlanCheen/PeriscopeLayout" target="_blank" rel="noopener">走起</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自定义View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App研发录读书笔记</title>
      <link href="/blog/ac7f996a.html"/>
      <url>/blog/ac7f996a.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>书的title都取得很高端,但是内容比较一般,特别是讲开发的,知识点分散,又不具体,不深入,差不多就是告诉你有XX东西,很有必要,但是又不教你怎么去做,所以几乎等于没讲啊。（很失望）作者可能在开发领域有挺长的时间,积累了很多开发和管理经验,但是这书的内容不太行.（针对Android方面，针对个人而言）</p><p>这里记录一些<strong>我还觉得还算有用的</strong>知识点      </p><a id="more"></a><h2 id="高效App框架设计与重构"><a href="#高效App框架设计与重构" class="headerlink" title="高效App框架设计与重构"></a>高效App框架设计与重构</h2><ol start="0"><li>自定义一些基类(如BaseActivity)</li><li>采取一定的方式在客户端模拟API返回数据,用于测试  </li><li>启用Cookie</li><li>Http数据要加密</li><li>公共参数可以存放到Header里</li><li>时间校准(返回服务器时间与本地时间比较(非常有必要))  </li><li>HTTP请求开启<strong>gzip压缩</strong>来减少传输量(省流量,加快速度),如果用Okhttp,gzip挺简单的,不过需要服务端的支持  </li><li>根据网络状况去下载不同尺寸的图片</li><li>急速模式(比如不显示图片,提供开关)</li><li>城市列表<strong>增量更新</strong>(本地保留版本号,与服务器对照,下发需要修改的数据,CURD进行操作)  </li><li>H5跳转Activity,可以传递一个String,按照约定的协议去解析,再跳转(一般传递Activity的全称,再 key-value来传递参数)</li><li>命名规范和代码规范(我推荐checkstyle)  </li></ol><h2 id="App开发中的高级技巧"><a href="#App开发中的高级技巧" class="headerlink" title="App开发中的高级技巧"></a>App开发中的高级技巧</h2><p>同上一章节,关于Crash竟然没写Android具体应该怎么做,却写了一堆数据库代码,真是醉了~<br>然后分析Crash,没什么软用,crash什么的碰到一次,你就知道了,提前看也没什么作用,而且,很多作者自己也根本没弄懂,呵呵.  </p><p>持续集成章节基于Eclipse,Ant,这能看?(反正我是不用Eclipse也不用Ant的直接跳过了)<br>单元测试差不多就是讲了有这么东西,然而并不教你怎么做.  </p><p>诶~忍不住又吐槽了~   </p><ol><li>通过实现<strong>UncaughtExceptionHandler</strong>去捕获异常</li><li>异常分析时出现<strong>Unknown Source</strong>,丢失了文件名和行号,这比较蛋疼,可以在ProGuard文件中增加<code>-keepattributes SourceFile,LineNumberTable</code>(umong分析是上传mapping文件,这个方法还有待验证,扩展阅读-&gt;<a href="http://bugly.qq.com/bbs/forum.php?mod=viewthread&amp;tid=244" target="_blank" rel="noopener">bugly</a> and <a href="http://bugly.qq.com/bbs/forum.php?mod=viewthread&amp;tid=26" target="_blank" rel="noopener">精神哥</a>)    </li></ol><h2 id="App竞品技术分析"><a href="#App竞品技术分析" class="headerlink" title="App竞品技术分析"></a>App竞品技术分析</h2><p>利用 <strong>AXMLPrinter2.jar</strong>可以还原被压缩过后的xml (这个对反编译有帮助,尝试有效)<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">java </span>-<span class="keyword">jar </span>AXMLPrinter2.<span class="keyword">jar </span><span class="keyword">AndroidManifest.xml</span></span><br></pre></td></tr></table></figure></p><ol start="0"><li>获取最佳服务器</li><li>数据采集</li><li>ABTest</li><li>Android打包META-INF目录的妙用</li><li>拆分classes.dex</li><li>模块化 热修复 插件化</li></ol><h2 id="项目管理和团队建设"><a href="#项目管理和团队建设" class="headerlink" title="项目管理和团队建设"></a>项目管理和团队建设</h2><p>这章我差不多就浏览了一遍,内容很日常化,也就不想多记录什么了,自有体会.  </p><ol><li>不能没有测试团队(赞同!我司没有,深感痛苦 自测测出的bug很少,而且会占用开发大量的时间)</li><li>模块化分工</li><li>每天例会</li><li>…  </li></ol><p>推荐阅读:<a href="https://github.com/AlanCheen/ReadingNotes" target="_blank" rel="noopener">所有的读书笔记</a>  </p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> App研发录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4章 类和接口</title>
      <link href="/blog/40b3036f.html"/>
      <url>/blog/40b3036f.html</url>
      
        <content type="html"><![CDATA[<h2 id="第4章-类和接口"><a href="#第4章-类和接口" class="headerlink" title="第4章 类和接口"></a>第4章 类和接口</h2><p><strong>类和接口是Java程序设计语言的核心，它们也是Java语言的基本抽象单元</strong>。</p><p>初学Java的时候感觉类和接口都好简单，后续慢慢发现类和接口的设计并非是想象总的那么简单的，还有好多需要学习。</p><p>而这一章作者就阐述了一些指导原则，指导我们设计出更加有用、健壮和灵活的类和接口，很有意义。 </p><a id="more"></a><h2 id="第13条-使类和成员的可访问性最小化"><a href="#第13条-使类和成员的可访问性最小化" class="headerlink" title="第13条 使类和成员的可访问性最小化"></a>第13条 使类和成员的可访问性最小化</h2><p>设计良好的模块对外部而言总是<strong>隐藏了所有的细节</strong>  </p><p>模块之间中通过它们的API进行通信，<strong>一个模块不需要知道其他模块的内部工作情况</strong>，这个概念被称为<strong>信息隐藏</strong>或<strong>封装</strong>，是<em>软件设计的基本原则之一</em>（还是封装好听啊，信息隐藏好low啊）  </p><p>封装可以<strong>有效解除各个模块之间的耦合关系</strong>，是现在模块化开发的基础，使模块<strong>可以独立地开发、测试、优化、使用、理解和修改</strong>。      </p><h3 id="尽可能地使每个类或者成员不被外界访问。"><a href="#尽可能地使每个类或者成员不被外界访问。" class="headerlink" title="尽可能地使每个类或者成员不被外界访问。"></a>尽可能地使每个类或者成员不被外界访问。</h3><p>Java中可以通过<strong>包</strong>、<strong>访问修饰符</strong>（private protected public）控制类、接口和成员的<code>可访问性（accessibility）</code>  </p><p>除了应该暴露的API之外，我们应该尽可能少的开放访问权。<br>因为一旦暴露给外界，可能会有风险，另外还需要保证一直维护与兼容。  </p><p>可以想象一下，当我们使用一个第三方库的时候，如果它暴露了一个不该暴露的类（假设为BitmapUtil），而我们恰好用了它里面的方法，结果它一升级，把方法改了，或者把方法去掉了，那我们不是懵了？  </p><p>所以<strong>不要去暴露那些不该暴露的类、接口、成员</strong>  </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>作者在最后给了小结：<strong>应该始终尽可能地降低可访问性。应该防止把任何散乱的类、接口和成员变成API的一部分。除了公有静态final域的特殊情形之外，共有类都不应该包含公有域。并且要确保公有静态final域所引用的对象都不是可变的</strong>  </p><h2 id="第14条-在共有类中使用访问方法而非公有域"><a href="#第14条-在共有类中使用访问方法而非公有域" class="headerlink" title="第14条 在共有类中使用访问方法而非公有域"></a>第14条 在共有类中使用访问方法而非公有域</h2><p>假设有一个类：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">double</span> x;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">double</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>作者的意思是不应该直接暴露<code>x y</code>,要为它们提供<code>getter</code>、<code>setter</code>方法，这样有利于添加约束条件，辅助行为。    </p><p>本人表示道理我懂，但是现在一般的类都不愿意去写getter setter了，真心觉得好烦啊，虽然方法可以用AS自动生成，我还是不太愿意去写，直接public就是那么任性      </p><h2 id="第15条-使可变性最小化"><a href="#第15条-使可变性最小化" class="headerlink" title="第15条 使可变性最小化"></a>第15条 使可变性最小化</h2><blockquote><p><em>不可变类：实例不能被修改的类</em>。<strong>每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变</strong>。如：String、基本类型的包装类、BigInteger和BigDecimal<br>不可变类比可变类更加易于设计、实现和使用。它们不容易出错，且更加安全。  </p></blockquote><p>不可变类的五条规则：</p><ol><li>不要提供任何会修改对象状态的方法。   </li><li>保证类不会被扩展。 一般用final修饰  </li><li>使所有的域都是final的。  </li><li>使所有的域都成为私有的。（降低访问权限）  </li><li>确保对于任何可变组件的互斥访问。（什么意思呢？）  </li></ol><h3 id="不可变类的优缺点"><a href="#不可变类的优缺点" class="headerlink" title="不可变类的优缺点"></a>不可变类的优缺点</h3><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>不要求同步，无惧多线程并发访问  </p><h4 id="不可变对象可以被自由地共享"><a href="#不可变对象可以被自由地共享" class="headerlink" title="不可变对象可以被自由地共享"></a>不可变对象可以被自由地共享</h4><p>所以不需要保护性拷贝（如String类的拷贝构造器）<br>也可以重复利用，如:Boolean.FALSE/TRUE  </p><h4 id="不可变对象为其他对象提供了大量的构建（building-blocks）"><a href="#不可变对象为其他对象提供了大量的构建（building-blocks）" class="headerlink" title="不可变对象为其他对象提供了大量的构建（building blocks）"></a>不可变对象为其他对象提供了大量的构建（building blocks）</h4><p>不是很懂  </p><h4 id="唯一的缺点：对于每个不同的值都需要一个单独的对象"><a href="#唯一的缺点：对于每个不同的值都需要一个单独的对象" class="headerlink" title="唯一的缺点：对于每个不同的值都需要一个单独的对象"></a>唯一的缺点：对于每个不同的值都需要一个单独的对象</h4><p>如FALSE TRUE ，不过如果值少，到也没什么关系<br>但是如String这样的不可变类，我们需要注意，多用StringBuilder（可变，性能好）  </p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>除非有很好的理由要让类成为可变的类，否则就应该是不可变的。<br>如果类不能被做成是不可变的，仍然应该尽可能地限制它的可变性。（降低出错的可能性）  </p><h2 id="第16条-复合优先于继承"><a href="#第16条-复合优先于继承" class="headerlink" title="第16条 复合优先于继承"></a>第16条 复合优先于继承</h2><p>在读HeadFirstDesignPattern的时候已经看到太多次了  </p><blockquote><p>这里的继承是指 <code>实现继承</code>（implementation inheritance）也即<code>extends</code> 而不是<code>接口继承</code> 复合（composition）也应该是常听到的<code>组合</code>  </p></blockquote><p><strong>继承打破了封装性</strong> 子类依赖于超类中特定功能的实现细节  当超类发生改变，子类可能会遭到破坏  </p><p>比如随着版本的发布，超类需要新增方法，但是这些方法不是所有子类需要的，那么就破坏了子类！    </p><h3 id="复合（组合）"><a href="#复合（组合）" class="headerlink" title="复合（组合）"></a>复合（组合）</h3><p>复合，即使用包装类（wrapper class），其实这也就是设计模式中的<code>装饰者模式</code>   </p><p>另外值得一提的是，<strong>复合以及转发并不是委托（delegation）</strong>  </p><p>装饰者模式的优缺点不多说了，可以看设计模式的笔记  </p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>继承功能确实强大，但它也存在很多问题，比如违背了封装原则（是不是很矛盾？），对于两个类，它们确实有<code>is-a</code>的关系时候才使用继承！  </p><p>所以使用继承的时候要考虑清楚  </p><h2 id="第17条-要么为继承而设计，并提供文档说明，要么就禁止继承"><a href="#第17条-要么为继承而设计，并提供文档说明，要么就禁止继承" class="headerlink" title="第17条 要么为继承而设计，并提供文档说明，要么就禁止继承"></a>第17条 要么为继承而设计，并提供文档说明，要么就禁止继承</h2><pre><code>好的API文档应该描述一个给定的方法做了什么工作,而不是描述它是如何做到的  </code></pre><p>如标题，恩，我可是连注释都懒得写的人，怎么会写文档。。。</p><h2 id="第18条-接口优于抽象类"><a href="#第18条-接口优于抽象类" class="headerlink" title="第18条 接口优于抽象类"></a>第18条 接口优于抽象类</h2><p>Java提供两种机制用来定义允许多个实现的类型:<code>接口</code>和<code>抽象类</code>。  </p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>接口和抽象类的区别有很多，其中 <strong>最为明显</strong> 的区别是： <strong>抽象类可以包含某些方法的实现，而接口不允许，即接口都是抽象方法</strong>  </p><p>而另外还有一个 <strong>更重要</strong> 的区别是：为了实现由抽象类定义的类型，<strong>类必须成为抽象类的一个子类</strong>。而Java是单继承的，所以抽象类作为类型定义受到了极大的限制，而接口没有这个限制。  </p><h3 id="接口的优势"><a href="#接口的优势" class="headerlink" title="接口的优势"></a>接口的优势</h3><ul><li><p>现有的类可以很容易被更新，以实现新的接口<br>当需要增加方法的时候只需要<code>implements</code>具体的接口即可,非常方便,而如果通过抽象类来实现,则需要在抽象类里新增方法,而这会导致其他继承该抽象类的类也被强制加上额外的方法!  </p></li><li><p>接口是定义mixin(混合类型)的理想选择<br>mixin是指主要的类型: 类除了实现它的”基本类型”之外,还可以实现这个mixin类型(一脸懵逼!这翻译的什么玩意?)  <code>Comparable</code>是一个mixin接口  </p></li></ul><p>我的理解是:<strong>一个类,利用实现多个接口可以达到混合类型的目的,而利用抽象类只能继承一个类,则不能达到混合类型的效果!</strong>  </p><ul><li>接口允许我们构造非层次结构的类型框架  </li></ul><h2 id="第19条-接口只用于定义类型"><a href="#第19条-接口只用于定义类型" class="headerlink" title="第19条 接口只用于定义类型"></a>第19条 接口只用于定义类型</h2><p>我们知道当类实现接口时,我们可以把该类的类型当做是接口的类型来使用,这是我们定义接口的唯一目的,也即接口 <strong>只应该用来定义类型</strong>  </p><p>看到这里,可能你会跟我一样奇怪,接口不就是用来定义类型的吗,还能用来干嘛?    </p><p>有一种接口被称为 <strong>常量接口</strong> ,就是没有方法,只有常量的接口,<em>这常量接口模式是对接口的不良使用</em>,因为它没什么卵用还会污染实现类  </p><p>Java中有几个常量接口,如<code>java.io.ObjectStreamConstants</code>,千万别学啊!~<br>建议常量用<code>工具类</code>或者<code>枚举</code>或者<code>@IntDef</code>注解来实现  </p><h2 id="第20条-类层次优于标签类"><a href="#第20条-类层次优于标签类" class="headerlink" title="第20条 类层次优于标签类"></a>第20条 类层次优于标签类</h2><p><strong>标签类</strong>，书中对它的定义说得很拗口。<br>我的理解是一个类，拥有多个风格，通过一个属性来区分不同的风格，类里充斥着<code>if else</code>或者<code>switch case</code>  </p><p>举个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isMan;</span><br><span class="line">    <span class="function">String <span class="title">sayHi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMan) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Yo hi man!~"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Person类，通过<code>isMan</code>属性来区分是男的还是女的，<code>sayHi()</code>方法针对男女有不同的表现，这个就是一个非常简单的标签类  </p><p>标签类的缺点非常明显，当你要表现的风格非常多样的时候，你需要写大量的判断语句，非常容易出错，而且当你需要修改某一个风格的时候，你需要在一大堆代码里找出你要改的地方，很有可能引入bug，非常难以维护。  </p><p>这个时候，将标签类转变成类层次就非常方便了：   </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="type">String</span> sayHi();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">String</span> sayHi() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Yo hi man!~"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">String</span> sayHi() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象出一个<code>Person</code>类，定义<code>Man</code>和<code>Woman</code>类继承它，根据自己的需求实现<code>sayHi()</code>方法，当需要修改<code>Man</code>的行为时，你不需要也不用担心会破坏<code>Woman</code>的代码，代码可读性，可维护性一下子高了很多，有木有？！  </p><h2 id="第21条-用函数对象表示策略"><a href="#第21条-用函数对象表示策略" class="headerlink" title="第21条 用函数对象表示策略"></a>第21条 用函数对象表示策略</h2><p><code>函数对象</code>的概念:<strong>如果一个类仅仅导出这样的一个方法(执行其他对象(这些对象被显示传递给这些方法)上的操作),它的实例实际上就等同于一个指向该方法的指针.</strong><br>这样的实例被称为函数对象(<code>function object</code>).    </p><p>如:<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">class</span> <span class="keyword">StringLengthComparator&#123;</span></span><br><span class="line"><span class="keyword"></span>public int compare(<span class="keyword">String </span><span class="built_in">s1</span>,<span class="keyword">String </span><span class="built_in">s2</span>)&#123;</span><br><span class="line">return <span class="built_in">s1</span>.length()-<span class="built_in">s2</span>.length()<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>StringLengthComparator</code>类即是一个典型的函数对象,指向<code>StringLengthComparator</code>对象的引用可以被当做是一个指向该比较器的<code>函数指针(function pointer)</code>,它也是一个用于字符串比较操作的具体策略,这个<em>策略</em>为<strong>策略模式中</strong>的策略,并且<em>函数指针</em>的主要用途就是实现策略模式.(关于策略模式这里就不多讲,推荐看&lt;<head first="" design="" pattern=""><meta name="generator" content="Hexo 3.8.0">&gt;,如果你不着急,可以等我出笔记~)    </head></p><p><strong>PS:指针的英语是 pointer</strong>   </p><h2 id="第22条-优先考虑静态成员类"><a href="#第22条-优先考虑静态成员类" class="headerlink" title="第22条 优先考虑静态成员类"></a>第22条 优先考虑静态成员类</h2><p><code>嵌套类</code>(nested class)是指<strong>被定义在另一个类的内部的类</strong>,它存在的目的应该<em>只是</em>为它的外围类(enclosing class)提供服务.  </p><p>嵌套类分为四种:  </p><ol><li>静态成员类(static member class) （<strong>不是内部类</strong>）  </li><li>非静态成员类(nonstatic member class)  </li><li>匿名类(anonymous class)  </li><li>局部类(local class)  </li></ol><p>除了第一种之外,其他三种都被称为 <strong>内部类(inner class)</strong>  </p><h3 id="静态成员类-amp-非静态成员类"><a href="#静态成员类-amp-非静态成员类" class="headerlink" title="静态成员类 &amp; 非静态成员类"></a>静态成员类 &amp; 非静态成员类</h3><p>最简单的嵌套类，<strong>最好把它看成普通的类，只是碰巧被声明在另一个类的内部而已（挺不错的解释）</strong>，所以它可以<strong>脱离外部类单独存在</strong>。  </p><p>它可以访问外部类的所有成员，包括<code>private</code>修饰的,也可以被访问修饰符修饰，来控制它的可见性。  </p><p>作用：静态成员类一般是用来<strong>辅助</strong>外部类的，比如<code>CoordinatorLayout</code>类中的<code>Behavior</code>类，它定义了一系列的行为用于辅助它的外部类<code>CoordinatorLayout</code>，例子有很多，不多说了。  </p><h4 id="静态成员类-amp-非静态成员类-的差别"><a href="#静态成员类-amp-非静态成员类-的差别" class="headerlink" title="静态成员类 &amp; 非静态成员类 的差别"></a>静态成员类 &amp; 非静态成员类 的差别</h4><p>虽然它们只差了一个<code>static</code>修饰符，但是其实它们差别巨大。 </p><p>非静态成员类的实例都<strong>隐含持有一个外部类的实例（enclosing instance）</strong>  </p><p>这不仅仅会消耗更多的空间，还可能会导致<strong>外部类的实例泄漏，内存泄漏</strong>，而静态成员类并不会。    </p><p>这在Android中很常见，比如我们使用<code>Handler</code>的时候，AS都会提示我们这可能造成内存泄漏，让我们使用静态成员类。  </p><p>所以<strong>通常情况更推荐静态成员类</strong>，书中有一句话：<strong>如果声明成员类不要求访问外围实例，就要始终把static修饰符放在它的声明中，使它成为静态成员类，而不是非静态成员类</strong>  </p><h3 id="匿名类-amp-局部类"><a href="#匿名类-amp-局部类" class="headerlink" title="匿名类 &amp; 局部类"></a>匿名类 &amp; 局部类</h3><p>匿名类，没有名字，也不是外部类的成员，它是在<strong>使用的同时被声明和实例化</strong>   </p><p>需要注意的是：<strong>当匿名类出现在非静态的环境中时，它会持有外部类的实例</strong>，所以它可能引起内存泄漏。  </p><p>匿名类的作用：通常用于创建<strong>函数对象</strong>（见21条），比如<code>Thread</code>，<code>Runnable</code>  </p><p>局部类非常少用，自己没用过，在源码里也没留意到它的存在，就不多写了。  </p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>虽然本条推荐静态成员类，不过每个嵌套类都有自己的用途，还是得按实际情况去抉择。    </p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>本章的内容在Java中非常重要，如果要提升架构能力，那么本章的学习必不可少！   </p><h2 id="本系列作品"><a href="#本系列作品" class="headerlink" title="本系列作品"></a>本系列作品</h2><p><a href="https://github.com/AlanCheen/ReadingNotes" target="_blank" rel="noopener">所有的读书笔记</a><br><a href="http://yifeiyuan.me/2016/04/11/%E7%AC%AC2%E7%AB%A0-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/">第2章 创建和销毁对象</a><br><a href="http://yifeiyuan.me/2016/05/18/%E7%AC%AC3%E7%AB%A0-%E5%AF%B9%E4%BA%8E%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%83%BD%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/">第3章 对于所有对象都通用的方法</a><br><a href="http://yifeiyuan.me/2016/06/20/%E7%AC%AC4%E7%AB%A0-%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/">第4章 类和接口</a>  </p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给博客添加PV和UV统计啦</title>
      <link href="/blog/e2b990c3.html"/>
      <url>/blog/e2b990c3.html</url>
      
        <content type="html"><![CDATA[<p>上次给博客添加了文章的统计,这次利用不蒜子给站点增加统计功能~~  </p><p>使用起来也非常简单,按照<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">不蒜子</a>官方的教程一步一步走就行,  这里稍微记录一下</p><p>修改<strong>next/layout/_partials/footer.swig”</strong>文件,在里面新增一些代码即可:</p><p>脚本:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>显示效果(其中 PV,UV字样可以自己修改):  </p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_pv"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    PV:<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_uv"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  UV:<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_uv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> footer %&#125;</span><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml">//注意 这行原来就有</span></span><br></pre></td></tr></table></figure><p>这样就能在博客的首页底部显示PV和UV啦!~ </p><p>很可惜的是,我在刚搭建博客的时候没有去统计,现在才开通,非常吃亏-0-~~ </p><blockquote><p>2016年6月14日 21:18</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3章 对于所有对象都通用的方法</title>
      <link href="/blog/f231b2f8.html"/>
      <url>/blog/f231b2f8.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Object的设定是为了扩展,它的所有非final方法(equals hashCode toString clone finalize)都有明确的通用约定,因为<strong>它们被设计是要被覆盖</strong>(override)的<br>而在覆盖这些方法时,都<strong>有责任遵守这些通用的约定</strong>,否则,其他依赖这些约定的类(如HashMap&amp;HashSet)就无法结合该类一起正常运作.</p><a id="more"></a><h2 id="第8条-覆盖equals时请遵守通用约定"><a href="#第8条-覆盖equals时请遵守通用约定" class="headerlink" title="第8条 覆盖equals时请遵守通用约定"></a>第8条 覆盖equals时请遵守通用约定</h2><h3 id="不覆盖equals"><a href="#不覆盖equals" class="headerlink" title="不覆盖equals"></a>不覆盖equals</h3><p>不覆盖equals的情况下,类的每个实例都与它自身相等,如果满足以下任何一个条件,就是所期望的结果:  </p><ul><li>类的每个实例本质上都是唯一的</li><li>不关心类是否提供了”逻辑相等”的测试功能</li><li>超类已经覆盖了equals,从超类继承过来的行为对于子类也是合适的(要小心)   </li><li>类是私有的或是包级私有的,可以确定它的equals方法永远不会被调用 (不懂为什么)</li></ul><p>讲得怪怪的  </p><blockquote><p>PS: 逻辑相等,就是逻辑上是相等的,比如id一样,判定它们相等,即使它们是两个不同的对象</p></blockquote><h3 id="什么时候应该覆盖equals"><a href="#什么时候应该覆盖equals" class="headerlink" title="什么时候应该覆盖equals"></a>什么时候应该覆盖equals</h3><p>当类需要逻辑相等这个概念的时候就应该覆盖equals<br>比如要判断两个<code>student</code>是否是同一个人,这个时候我们就需要按需重写equals  </p><h3 id="通用约定"><a href="#通用约定" class="headerlink" title="通用约定"></a>通用约定</h3><p>重写equals的时候就必须要遵守它的通用约定<br>equals方法实现了等价关系(equivalence relation):  </p><ul><li>自反性(reflexive) 对于任何非null的引用值x,x.equals(x)必须返回true  </li><li>对称性(symmetric) 对于任何非null的引用值x和y,当且仅当y.equals(x)返回true时,x.equals(y)必须返回true  </li><li>传递性(transitive) 对于任何非null的引用值,x,y,z,如果x.equals(y)为true,并且y.equals(z)也返回true,那么x.equals(z)也必须返回true</li><li>一致性(consistent) 对于任何非null的引用值x和y,只要equals的比较操作在对象中所用的信息没有被修改,多次调用x.equals(y)就会一致地返回true,或者false</li><li>对于任何非null的引用值,x,x.equals(null)必须返回false</li></ul><p>感觉又回到了学数学交换律什么的的时候了~  </p><p><strong>有些类(如集合,HashMap)与<code>equals</code>方法息息相关,所以重写的时候要仔细小心</strong></p><h3 id="高质量的equals"><a href="#高质量的equals" class="headerlink" title="高质量的equals"></a>高质量的equals</h3><p>ej对equals提了几点建议:    </p><ol><li>使用<code>==</code>操作符检查”参数是否为这个对象的引用” 如果是,则返回true. 这只不过是一种性能优化,如果比较操作有可能很昂贵,就值得这么做 (平时没有用过,怎么样的比较操作算是昂贵的呢?)</li><li>使用<code>instanceof</code>操作符检查”参数是否为正确的类型” 如果不是,则返回false。    </li><li>把参数装换成正确的类型。(这个比较好理解,instanceof检测后,一般都会强转成所需类型)</li><li>对于该类中的每个『关键』域,检查参数中的域是否与对象中对应的域相配。(比如学生类有学号，班级，姓名这些重要的属性，我们都需要去比对)</li><li>当你编写完成了equals方法之后，应该问自己是哪个问题:它是否是对称的、传递的、一致的？  </li></ol><p>另外EJ还告诫我们<em>覆盖equals的时候总要覆盖hashCode</em>（见第9条）  </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>最后按照上诉建议，用一个<code>Student</code>类来总结一下equals的写法：  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Student &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> className;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> equals(<span class="built_in">Object</span> obj) &#123;</span><br><span class="line">        <span class="comment">//对于一个null的对象 我们总是返回false</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用instanceof检查类型后,强转</span></span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">            Student other = (Student) obj;</span><br><span class="line">            <span class="comment">//再对关键的属性做比较 得出结论</span></span><br><span class="line">            <span class="keyword">if</span> (name.equals(other.name) &amp;&amp; className.equals(other.className)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>equals</code>是一个看上去简单,实则是个比较容易犯错的方法,需要小心仔细  </p><h2 id="第9条-覆盖equals时总要覆盖hashCode"><a href="#第9条-覆盖equals时总要覆盖hashCode" class="headerlink" title="第9条 覆盖equals时总要覆盖hashCode"></a>第9条 覆盖equals时总要覆盖hashCode</h2><p>覆盖了equals方法,也必须覆盖hashCode方法,if not,就违反了hashCode的通用约定,会导致无法跟基于散列的集合正常运作.    </p><p>Object通用约定(在Object类中的注释即是):  </p><ul><li>在应用程序的执行期间,只要对象的<code>equals</code>方法的比较操作所用到的信息没有被修改,那么对这同一个对象调用多次,<code>hashCode</code>方法都必须始终如一地返回同一个整数.在同一个应用程序的多次执行过程中,每次执行所返回的整数可以不一致.  </li><li>如果两个对象根据<code>equals</code>方法比较是相等的,那么调用这两个对象中任意一个对象的<code>hashCode</code>方法都必须产生同样的整数结果.(<strong>即equals相等,那么hashCode一定相等,需要注意的是,反过来不一定成立,即hashCode相等不代表equals相等</strong>)  </li><li>如果两个对象根据<code>equals</code>方法比较是不相等的,那么调用这两个对象中任意一个对象的<code>hashCode</code>方法,则不一定要产生不同的整数结果.但是程序员应该知道,给不相等的对象产生截然不同的证书结果,有可能提高散列表(hash table)的性能.  </li></ul><h3 id="不重写hashCode带来的问题"><a href="#不重写hashCode带来的问题" class="headerlink" title="不重写hashCode带来的问题"></a>不重写<code>hashCode</code>带来的问题</h3><p>正如之前提到的,hashCode其实主要用于跟基于散列的集合合作<br>如HashMap会把<strong>相同的hashCode的对象放在同一个散列桶</strong>(hash bucket)中,那么即使equals相同而hashCode不相等,那么跟HashMap一起使用,则<strong>会得到与预期不相同的结果</strong>.  </p><p>具体是怎么样的不同的效果？来看一段代码：<br><strong>PS：<code>Student</code>类是第8条里的类，重写了<code>equals</code></strong>    </p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[]args) &#123;</span><br><span class="line">    Student lilei = <span class="keyword">new</span> Student(<span class="string">"lilei"</span>,<span class="string">"class1"</span>);</span><br><span class="line">    <span class="keyword">HashMap</span>&lt;Student, <span class="keyword">String</span>&gt; hashMap = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">    hashMap.put(lilei, lilei.className);</span><br><span class="line">    <span class="keyword">String</span> className = hashMap.<span class="built_in">get</span>(<span class="keyword">new</span> Student(<span class="string">"lilei"</span>,<span class="string">"class1"</span>));<span class="comment">//值与之前的lilei相同，即equals会为true</span></span><br><span class="line"></span><br><span class="line">    System.out.<span class="built_in">println</span>(className);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>className</code>的值为多少呢？<br><code>class1</code>?<br>NO！是<code>null</code>！！！！(诶？)  </p><p>为什么呢？因为我们并没有重写<code>hashcode</code>，所以即使我们去<code>get</code>的时候传入的<code>Student</code>的name以及classname与<code>put</code>的时候的对象值是一样的，也即<strong>它们是<code>equals</code>的</strong>(我重写了<code>equals</code>！)，但是要注意，<strong>它们的<code>hashcode</code>是不一样的</strong>，这样就违反了上面所说的<strong>equals相等，hashCode也要相等</strong>的原则，所以当我们期望<code>get</code>到的是<code>class1</code>的时候，我们需要重写<code>hashCode</code>方法，让它们的hashcode相同！   </p><p>那么问题来了，如何去重写<code>hashCode</code>呢？返回一个固定值?比如1？NO!!!<br>So,how?  </p><h3 id="如何重写hashCode"><a href="#如何重写hashCode" class="headerlink" title="如何重写hashCode"></a>如何重写<code>hashCode</code></h3><p>EJ给出的解决办法：  </p><ol><li>把某个<strong>非零</strong>的常数值，比如17，保存在一个名为result的int类型的变量中。  </li><li>对于对象中每个关键域f(<strong>指equals方法中涉及的每个域</strong>)，完成以下步骤：  <ul><li><strong>步骤(a)</strong> 为该域计算<code>int</code>类型的散列码c：  <ul><li>如果f是boolean，则计算 <strong>f?1:0</strong>    </li><li>如果是byte，char，short或int，则计算 <strong>(int)f</strong>    </li><li>如果是long，则<strong>计算(int)(f^(f&gt;&gt;&gt;32))</strong>    </li><li>如果是float，则<strong>Float.floatToIntBits(s)</strong>    </li><li>如果是double，则计算<strong>Double.doubleToLongBits(f)</strong>,再按long类型计算一遍  </li><li>如果是f是个对象引用，并且该类的equals方法通过递归地调用equals的方式来比较这个域，则同样为这个域递归调用hashCode。如果需要更复杂的比较，则为这个域计算一个‘范式’，然后针对这个范式调用hashCode。如果这个域的值为null，则返回0(或者其他某个常数，但通常是0)。  </li><li>如果是个数组，则需要把每个元素当做单独的域来处理。也就是说，递归地应用上述规则，对每个重要的元素计算一个散列码，然后根据步骤b中的做法把这些散列值组合起来。 如果数组域中的每个元素都很重要，可以利用发行版本1.5中增加的其中一个<code>Arrays.hashCode</code>方法。  </li><li><strong>步骤(b)</strong> 按照下面公式，把(a)步骤中计算得到的散列码c合并到result中：<code>result = 31*result+c</code> (为什么是31呢？)    </li></ul></li></ul></li><li>返回result    </li><li>测试，是否符合『相等的实例是否都具有相等的散列码』   </li></ol><p>OK，知道怎么写之后，我们重写Student类的hashCode方法：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Override</span></span><br><span class="line">public <span class="built_in">int</span> hashCode() &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="literal">result</span> = <span class="number">17</span>;//非<span class="number">0</span> 任选</span><br><span class="line">    <span class="literal">result</span> = <span class="number">31</span>*<span class="literal">result</span> + name.hashCode();</span><br><span class="line">    <span class="literal">result</span> = <span class="number">31</span>*<span class="literal">result</span> + className.hashCode();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这下之前的代码输出的结果为<code>class1</code>了！！！~  </p><pre><code>为什么要选31？</code></pre><p>因为它是个<strong>奇素数</strong>，另外它还有个很好的特性，即用移位和减法来代替乘法，可以得到更好的性能：31*i == (i&lt;&lt;5)-i  </p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>终于学会如何写<code>hashCode</code>了！<br>老实说，我并没有做到这条要求!<br>因为一般来说我不会把<code>Student</code>这样的类当做一个<code>Key</code>去处理  </p><p>PS：书中讲到的知识点很多，光看这个笔记是不够的，如果可以，自己去阅读书籍吧！  </p><h3 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h3><p>dim提供：<a href="http://www.importnew.com/18851.html" target="_blank" rel="noopener">浅谈Java中的hashcode方法</a></p><h2 id="第10条-始终要覆盖toString"><a href="#第10条-始终要覆盖toString" class="headerlink" title="第10条 始终要覆盖toString"></a>第10条 始终要覆盖toString</h2><p>Object类默认toString的实现方法是这样的：  </p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">'@'</span> + <span class="built_in">Integer</span>.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它只有类名+‘@’+散列值，<code>toString</code>的通用约定指出，被返回的字符串应该是一个『简洁的，但信息丰富，并且易于阅读的表达形式』<br>虽然够简单，但是信息并不丰富，而且更多时候我们更希望<code>toString</code><strong>返回对象中包含的所有值得关注的信息</strong>,当属性多了，只显示信息重要的即可</p><p><code>toString</code>倒没有特别大的约束    </p><h2 id="第11条-谨慎地覆盖clone"><a href="#第11条-谨慎地覆盖clone" class="headerlink" title="第11条 谨慎地覆盖clone"></a>第11条 谨慎地覆盖clone</h2><p><code>clone</code>说到<code>clone</code>(protected)就必须提及一下<code>Cloneable</code>接口，这个接口很奇怪，没有方法：  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Cloneable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<em>Object的<code>clone</code>方法</em>，<strong>当我们尝试调用一个没有实现<code>Cloneable</code>接口的类的clone方法数时，clone会抛出<code>CloneNotSupportedException</code>，是不是很坑爹？</strong>  </p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function">Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Cloneable)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CloneNotSupportedException(<span class="string">"Class "</span> + getClass().getName() +</span><br><span class="line">                                             <span class="string">" doesn't implement Cloneable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">internalClone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么不把clone方法放Cloneable接口里面去却偏偏塞给了Object？<br>这个设计我真的想不明白！！！！！       </p><p><code>clone</code>方法自己没怎么用过,不过可以看看其他优秀的库的设计,比如<code>Retrofit</code>中的<code>OkHttpCall</code>:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> OkHttpCall&lt;T&gt; <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS:在使用优秀的开源库的时候,如果可以,多看看它的源码,你会学到很多!相信我!  </p><h2 id="第12条-考虑实现Comparable接口"><a href="#第12条-考虑实现Comparable接口" class="headerlink" title="第12条 考虑实现Comparable接口"></a>第12条 考虑实现Comparable接口</h2><p>注意<code>compareTo</code>不是Object的方法,而是<code>Comparable</code>接口的方法:  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Comparable&lt;T&gt;&#123;</span><br><span class="line">int compareTo(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compareTo的约定跟equals类似：  </p><blockquote><p>PS：符合<code>sgn</code>（表达式）表示数学中的signum函数，它根据表达式（expression）的值为负值、零、和正直，分别返回-1、0或1  </p></blockquote><ul><li>确保sgn(x.compareTo(y))== <code>-sgn</code>(y.compareTo(x))  </li><li>可传递：x.compareTo(y)&gt; 0 &amp;&amp; y.compareTo(z) 暗示 x.compareTo(z)&gt; 0  </li><li>确保x.compareTo(y)==0暗示所有z都满足sgn(x.compareTo(z)）== sgn(y.compareTo(z)）  </li><li>强烈建议(x.compareTo(y)==0)，但这并非绝对重要<br>（个人觉得还是遵守更好一些！）  </li></ul><p>如果不想写compareTo或者类并没有实现Comparable接口的可以自定义一个<code>Comparator</code>类来进行比较。  </p><p>需要注意,排序是不允许出现逻辑漏洞的,否则会crash!  </p><h2 id="本章完结"><a href="#本章完结" class="headerlink" title="本章完结"></a>本章完结</h2><p>题外话:Object一共有<strong>12</strong>个方法,其中<strong>7个是native</strong>方法  </p><h2 id="本系列作品"><a href="#本系列作品" class="headerlink" title="本系列作品"></a>本系列作品</h2><p><a href="https://github.com/AlanCheen/ReadingNotes" target="_blank" rel="noopener">所有的读书笔记</a><br><a href="http://yifeiyuan.me/2016/04/11/%E7%AC%AC2%E7%AB%A0-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/">第2章 创建和销毁对象</a><br><a href="http://yifeiyuan.me/2016/05/18/%E7%AC%AC3%E7%AB%A0-%E5%AF%B9%E4%BA%8E%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%83%BD%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/">第3章 对于所有对象都通用的方法</a><br><a href="http://yifeiyuan.me/2016/06/20/%E7%AC%AC4%E7%AB%A0-%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/">第4章 类和接口</a>  </p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EditText使用小技巧</title>
      <link href="/blog/a34a4dcc.html"/>
      <url>/blog/a34a4dcc.html</url>
      
        <content type="html"><![CDATA[<h2 id="设置回车-send"><a href="#设置回车-send" class="headerlink" title="设置回车/send/.."></a>设置回车/send/..</h2><p>通过<code>setImeOptions(EditorInfo.IME_ACTION_SEND)</code>  方法我们可以设定输入法的Action,即经常看到的Enter/Send/回车等.</p><h2 id="屏蔽长按事件"><a href="#屏蔽长按事件" class="headerlink" title="屏蔽长按事件"></a>屏蔽长按事件</h2><p>长按EditText会弹出复制/黏贴等功能栏,而Android自带的界面很丑,而且会挤压我们的UI(MIUI的不会),所以我们需要屏蔽它:  </p><a id="more"></a><h3 id="实现ActionMode-Callback接口"><a href="#实现ActionMode-Callback接口" class="headerlink" title="实现ActionMode.Callback接口"></a>实现<code>ActionMode.Callback</code>接口</h3><p>在<code>onCreateActionMode</code>方法返回<code>false</code>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActionModeListener</span> <span class="keyword">implements</span>           <span class="title">ActionMode</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateActionMode</span><span class="params">(ActionMode mode, Menu menu)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPrepareActionMode</span><span class="params">(ActionMode mode, Menu menu)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onActionItemClicked</span><span class="params">(ActionMode mode, MenuItem item)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroyActionMode</span><span class="params">(ActionMode mode)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="通过setCustomSelectionActionModeCallback设置"><a href="#通过setCustomSelectionActionModeCallback设置" class="headerlink" title="通过setCustomSelectionActionModeCallback设置"></a>通过<code>setCustomSelectionActionModeCallback</code>设置</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mEdtInput.setCustomSelectionActionModeCallback(<span class="keyword">new</span> <span class="type">MyActionModeListener</span>());<span class="comment">//屏蔽长按事件</span></span><br></pre></td></tr></table></figure><h2 id="对话框中有ET-弹不出输入法"><a href="#对话框中有ET-弹不出输入法" class="headerlink" title="对话框中有ET,弹不出输入法"></a>对话框中有ET,弹不出输入法</h2><p>当我们需要弹出一个有EditText的同时,弹出输入法,我们需要做如下处理:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dialog.setOnShowListener(new </span><span class="keyword">DialogInterface.OnShowListener() </span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onShow(<span class="keyword">DialogInterface </span><span class="keyword">dialog) </span>&#123;</span><br><span class="line">        InputMethodManager inputMethodManager = (InputMethodManager) mActivity.getSystemService(<span class="built_in">Context</span>.INPUT_METHOD_SERVICE)<span class="comment">;</span></span><br><span class="line">        inputMethodManager.<span class="keyword">showSoftInput(editText, </span>InputMethodManager.<span class="keyword">SHOW_IMPLICIT);//用 </span><span class="keyword">SHOW_FORCED </span>来打开的话 对话框消失后输入法不会自己消失</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="焦点问题"><a href="#焦点问题" class="headerlink" title="焦点问题"></a>焦点问题</h2><h3 id="清除焦点"><a href="#清除焦点" class="headerlink" title="清除焦点"></a>清除焦点</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mEdtNick.clearFocus()<span class="comment">;</span></span><br><span class="line">mEdtNick.setFocusableInTouchMode(false)<span class="comment">;</span></span><br><span class="line">mEdtNick.setFocusable(false)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="重新能够获取焦点"><a href="#重新能够获取焦点" class="headerlink" title="重新能够获取焦点"></a>重新能够获取焦点</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mEdtNick.setFocusable(<span class="literal">true</span>);<span class="comment">//光这句不行 点击之后不能输入</span></span><br><span class="line">mEdtNick.setFocusableInTouchMode(<span class="literal">true</span>);<span class="comment">//</span></span><br></pre></td></tr></table></figure><h2 id="动态修改drawable"><a href="#动态修改drawable" class="headerlink" title="动态修改drawable"></a>动态修改drawable</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Drawable</span> <span class="keyword">right</span> = getResources().getDrawable(<span class="type">R</span>.drawable.bg_change_name);</span><br><span class="line"><span class="comment">//setbounds 不能少                    </span></span><br><span class="line"><span class="keyword">right</span>.setBounds(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">right</span>.getIntrinsicWidth(),<span class="keyword">right</span>.getIntrinsicWidth());</span><br><span class="line"><span class="comment">//l t r b                    </span></span><br><span class="line">mEdtNick.setCompoundDrawables(null,null,<span class="keyword">right</span>,null);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tip </tag>
            
            <tag> EditText </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型</title>
      <link href="/blog/a14eb637.html"/>
      <url>/blog/a14eb637.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>泛型程序设计意味着编写的代码可以被很多不同的类型的对象所重用  </p><p>泛型在集合框架里拥有着非常广泛的运用,如果没有泛型估计是一大堆Object以及强转代码吧!  </p><p>想想都可怕啊!    </p><h3 id="泛型类-generic-class"><a href="#泛型类-generic-class" class="headerlink" title="泛型类(generic class)"></a>泛型类(generic class)</h3><p>泛型类就是具有一个或多个<strong>类型变量</strong>的类,如</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Pair&lt;<span class="built_in">T</span>,V&gt;&#123;</span><br><span class="line"><span class="built_in">T</span> first;</span><br><span class="line"><span class="built_in">T</span> <span class="built_in">second</span>;</span><br><span class="line">V <span class="built_in">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么是类型变量?  </p><a id="more"></a><p><strong>上诉代码中的 T和V 就是类型变量 ,用&lt;&gt;括起来,放在类名后面</strong>  </p><p>类型变量使用大写形式,且比较短  </p><p>一些常用的:  </p><ul><li>E 表示集合的元素类型  </li><li>K和V 分别表示表的关键字与值的类型  </li><li>T(U或者S) 表示任意类型</li></ul><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class A&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;<span class="function">T <span class="title">test</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">hi</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型变量放在修饰符(public static等)的后面,返回类型的前面  </p><h3 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h3><p>当我们想要<strong>对类型变量加以约束</strong>的时候我们就需要用到<strong>限定符</strong> </p><h4 id="子类型限定"><a href="#子类型限定" class="headerlink" title="子类型限定"></a>子类型限定</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;<span class="built_in">T</span> extends Comparable&gt;<span class="built_in">T</span> <span class="built_in">min</span>(<span class="built_in">T</span>[] a)...</span><br></pre></td></tr></table></figure><p>表示<code>T</code>需要实现或继承Comparable接口,值得注意的是这里是<code>extends</code> </p><p>这里的<code>extends</code>表示<code>T</code>必须是子类型(实现或继承)    </p><p>当然也可以用多个限定符来限制类型变量(用<code>&amp;</code>):    </p><p><code>T extends Comparable&amp;Serializable</code>  </p><h4 id="通配符-的超类型限定"><a href="#通配符-的超类型限定" class="headerlink" title="通配符 的超类型限定"></a>通配符 的超类型限定</h4><p>通配符用<code>?</code>来表示,超类型限定(supertype bound)用<code>super</code>关键字表示  </p><p>值得注意的是<strong>超类限定只能用于通配符</strong>  </p><p><code>Pair&lt;? extends Employee&gt;</code>表示任何泛型Pair类型,它的类型参数是Employee的子类  </p><p><strong>? super Manager</strong>   </p><p>将通配符限制为Manager的所有超类型  </p><p>====</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>写了个练习的小例子,总结一下:  </p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">GenericPractice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[]args)&#123;</span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        Hero hero = <span class="keyword">new</span> Hero();</span><br><span class="line">        Knight knight = <span class="keyword">new</span> Knight();</span><br><span class="line"></span><br><span class="line">        attack(person);<span class="comment">// wrong !!!</span></span><br><span class="line">        attack(hero);</span><br><span class="line">        attack(knight);</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Knight&gt; knights = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">group</span>(persons);</span><br><span class="line">        <span class="keyword">group</span>(heros);</span><br><span class="line">        <span class="keyword">group</span>(knights);<span class="comment">//wrong !!!</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Hero&gt; <span class="keyword">void</span> attack(T t)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">group</span>(List&lt;? <span class="keyword">super</span> Hero&gt; <span class="keyword">group</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Knight</span> <span class="keyword">extends</span> <span class="title">Hero</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>留点笔记:</p><p>前提:<br><code>Knight extends Hero</code>,<code>Hero extends Person</code>  </p><p>attack方法使用<code>&lt;T extends Hero&gt;</code>来限定,即<code>T</code>必须是<code>Hero</code>类本身或者子类,所以<code>attack(person)</code>不能通过编译.  </p><p>group方法使用<code>&lt;? super Hero&gt;</code>来限定,即<code>?</code>必须是<code>Hero</code>类的本身或者父类,所以<code>group(knights)</code>不能通过编译.  </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HotFix的抉择</title>
      <link href="/blog/8eba3328.html"/>
      <url>/blog/8eba3328.html</url>
      
        <content type="html"><![CDATA[<h2 id="HotFix-的抉择"><a href="#HotFix-的抉择" class="headerlink" title="HotFix 的抉择"></a>HotFix 的抉择</h2><p>现有框架 ：  </p><ul><li><a href="https://github.com/alibaba/AndFix" target="_blank" rel="noopener">AndFix</a> </li><li><a href="https://github.com/alibaba/dexposed" target="_blank" rel="noopener">dexposed</a>  </li><li><a href="https://github.com/rovo89/Xposed" target="_blank" rel="noopener">Xposed</a></li><li><a href="https://github.com/jasonross/Nuwa" target="_blank" rel="noopener">Nuwa</a> </li><li><a href="https://github.com/dodola/HotFix" target="_blank" rel="noopener">HotFix</a> </li></ul><p>qq空间的暂时还没开源      </p><h2 id="AndFix"><a href="#AndFix" class="headerlink" title="AndFix"></a><a href="https://github.com/alibaba/AndFix" target="_blank" rel="noopener">AndFix</a></h2><p>alibaba出品  </p><p>功能：<code>method body&#39;s replacing</code> 即支持方法级别修复    </p><h3 id="Support"><a href="#Support" class="headerlink" title="Support"></a>Support</h3><p>Android Version :2.3-6.0<br>dalvik &amp; art runtime  </p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>无需重启</strong>  </p><p>andfix只能替换方法而不能增减新的字段，也不能下发类  </p><a id="more"></a><h3 id="issue（122个）"><a href="#issue（122个）" class="headerlink" title="issue（122个）"></a>issue（122个）</h3><p>查看了一些issue，记录一些<strong>可能存在的</strong>问题以及缺陷：  </p><ol><li>兼容性问题  </li><li>部分手机奔溃  </li><li>部分手机ANR  </li><li>不能改变量的值，不过方法的添加修改，删除，都可以</li><li>需要注意多进程    </li><li>ART下模式无法对同一个方法进行多次更新  </li></ol><p>只是说可能，因为很多issue都没人回复  </p><h2 id="Nuwa"><a href="#Nuwa" class="headerlink" title="Nuwa"></a><a href="https://github.com/jasonross/Nuwa" target="_blank" rel="noopener">Nuwa</a></h2><p>贾吉鑫（原点评）出品    </p><h2 id="Support-1"><a href="#Support-1" class="headerlink" title="Support"></a>Support</h2><p>dalvik &amp; art runtime<br>productFlavor &amp; buildType<br>proguard &amp; multidex<br>纯Java 实现   </p><h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><p>基于类级别的修复，不仅仅只是修复方法    </p><p><strong>需要重启</strong>  </p><h3 id="issue-46个"><a href="#issue-46个" class="headerlink" title="issue(46个)"></a>issue(46个)</h3><ol><li>ART环境支持的不好</li><li><a href="https://github.com/jasonross/Nuwa/issues/50" target="_blank" rel="noopener">i50</a> nuwa只支持 4.0以上，并不是作者所描述的2.3~6.0,作者使用的BaseDexClassLoader这个4.0才有的API，导致4.0以下的手机用Nuwa就必定崩溃，特此提醒</li></ol><p>同AndFix  </p><h2 id="Compare"><a href="#Compare" class="headerlink" title="Compare"></a>Compare</h2><p>dexposed <strong>不支持art(5.0+)</strong> 比较<strong>致命</strong>，所以最开始就被排除了    </p><p>Nuwa HotFix DroidFix 都基于ClassLoader,兼容性以及稳定性好，支持2.3~6.0,对于启动速度有影响，补丁<strong>重启后才能生效</strong> </p><p>AndFix,支持2.3~6.0，但是兼容性以及稳定性较差，关键是<strong>不需要重启</strong>    </p><p>原本想画个表，但是时间有限，不画了，就是这么任性。。。   </p><table><thead><tr><th style="text-align:center">HotFix</th><th style="text-align:center">Reboot</th><th style="text-align:center">Version</th><th>LastUpdateTime</th></tr></thead><tbody><tr><td style="text-align:center">AndFix</td><td style="text-align:center">No</td><td style="text-align:center">0.4.0</td><td>2016.4</td></tr><tr><td style="text-align:center">Nuwa</td><td style="text-align:center">Yes</td><td style="text-align:center">1.0.0</td><td>五个月之前</td></tr></tbody></table><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>虽然我原本从各个维度去考虑如何选择，比如Star数，版本号，更新频率，issue解答率等等，<br>但是到最后其实可选的余地就两个，<strong>想要不重启即可生效，就选AndFix，否则可以考虑Nuwa</strong>  </p><p>另外据小道消息听闻，QQ空间团队的热补（ClassLoader的鼻祖）会在qcan结束后开源，时间未知  </p><p>我这个只是简单的比较，较为详细的可以看看大帅的『各大热补丁方案分析和比较』一文  </p><h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzIxNDE1NjQ2Mw==&amp;mid=502388591&amp;idx=1&amp;sn=4ad49aea488bb2d4075644b2cc2cf52a#rd" target="_blank" rel="noopener">HotFix调研</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzIxNDE1NjQ2Mw==&amp;mid=2649872243&amp;idx=1&amp;sn=e4998ed201087249de74731beb9ea423#rd" target="_blank" rel="noopener">HotFix的抉择</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzIxNDE1NjQ2Mw==&amp;mid=2649872246&amp;idx=1&amp;sn=9c23327cdf7bb9eafa2a427e9c853d2d#rd" target="_blank" rel="noopener">AndFix简单使用教程</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzIxNDE1NjQ2Mw==&amp;mid=2649872253&amp;idx=1&amp;sn=3990dc075f31ac2d63ee5a96fc483f73#rd" target="_blank" rel="noopener">AndFix从入门到放弃 </a><br><a href="http://mp.weixin.qq.com/s?__biz=MzIxNDE1NjQ2Mw==&amp;mid=2649872256&amp;idx=1&amp;sn=253973ed6b5539b0fbfffa3ae18bdae6#rd" target="_blank" rel="noopener">AndFix从放弃到捡起</a>  </p><p>另外提供了些许资料，有兴趣的可以看看  </p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="http://blog.csdn.net/lzyzsd/article/details/49843581" target="_blank" rel="noopener">Android热更新实现原理</a><br><a href="http://blog.zhaiyifan.cn/2015/11/20/HotPatchCompare/" target="_blank" rel="noopener">各大热补丁方案分析和比较</a><br><a href="http://zhuanlan.zhihu.com/p/20308548" target="_blank" rel="noopener">安卓App热补丁动态修复技术介绍</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HotFix </tag>
            
            <tag> AndFix </tag>
            
            <tag> Nuwa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2章 创建和销毁对象</title>
      <link href="/blog/9921f64d.html"/>
      <url>/blog/9921f64d.html</url>
      
        <content type="html"><![CDATA[<h1 id="第2章-创建和销毁对象"><a href="#第2章-创建和销毁对象" class="headerlink" title="第2章 创建和销毁对象"></a>第2章 创建和销毁对象</h1><p>何时以及如何创建对象,何时以及如何避免创建对象<br>如何确保适时销毁,如何管理对象销毁前必要的清理  </p><h2 id="第1条-考虑用静态工厂方法代替构造器"><a href="#第1条-考虑用静态工厂方法代替构造器" class="headerlink" title="第1条 考虑用静态工厂方法代替构造器"></a>第1条 考虑用静态工厂方法代替构造器</h2><p>静态工厂方法是一个<strong>返回类的实例的静态方法</strong>,对它其实只是一个普通的静态方法而已,需要注意的是它与设计模式中的工厂方法不同,不要弄混淆了  </p><p>Java源码中的例子:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">Boolean</span> valueOf(<span class="keyword">boolean</span> b)&#123;</span><br><span class="line"><span class="keyword">return</span> b?<span class="keyword">Boolean</span>.<span class="keyword">TRUE</span>:<span class="keyword">Boolean</span>.<span class="keyword">FALSE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>列举静态工厂方法与构造器相比,有哪些优势  </p><a id="more"></a><h4 id="静态工厂方法有名称"><a href="#静态工厂方法有名称" class="headerlink" title="静态工厂方法有名称"></a>静态工厂方法有名称</h4><p>构造方法没有名称,给静态工厂取一个适当的方法名称会更易于阅读,也更易于客户端使用.  </p><p>特别是在面对有多个参数或者多个构造方法的类的时候,会让客户端不知道如何选择构造方法(自行脑补一个大写的懵B).  </p><h4 id="不必在每次调用它们的时候都创建一个新对象"><a href="#不必在每次调用它们的时候都创建一个新对象" class="headerlink" title="不必在每次调用它们的时候都创建一个新对象"></a>不必在每次调用它们的时候都创建一个新对象</h4><p>我们知道构造方法每次都会创建一个新的实例,而当我们需要避免重复创建不必要的对象(或者不可变的类)时通过构造方法去做是做不到的,而静态方法可以为重复的调用返回相同的对象(比如返回的对象需要是一个单例)  </p><h4 id="它们可以返回原返回类型的任何子类型的对象"><a href="#它们可以返回原返回类型的任何子类型的对象" class="headerlink" title="它们可以返回原返回类型的任何子类型的对象"></a>它们可以返回原返回类型的任何子类型的对象</h4><p>构造方法只能返回类本身,而静态方法可以返回它的子类,利用多态的特性使得静态方法更加灵活<br>比如<code>Executors</code>类的各种<code>newxxx</code>方法返回<code>ExecutorService</code>的子类</p><h4 id="在创建参数化类型实例的时候-它们使代码变得更加简洁"><a href="#在创建参数化类型实例的时候-它们使代码变得更加简洁" class="headerlink" title="在创建参数化类型实例的时候,它们使代码变得更加简洁"></a>在创建参数化类型实例的时候,它们使代码变得更加简洁</h4><p>调用参数化构造器时,即使类型参数很明显也必须指明.<br>书中列举了实例化HashMap的例子:<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt;m = <span class="keyword">new</span> HashMap&lt;Stirng,<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt;();</span><br></pre></td></tr></table></figure></p><p>如果用静态工厂可以这么写:<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt;HashMap&lt;K,V&gt;<span class="keyword">new</span><span class="type">Instance</span>()&#123;</span><br><span class="line">reutrn <span class="keyword">new</span> <span class="type">HashMap</span>&lt;K,V&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>想想以前也确实烦这些类型指定,一写一长串,但是现在(Java1.7)已经实现了类型推导,所以其实也没那么复杂了.  </p><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><p>静态工厂方法的劣势</p><h4 id="类如果不含公有的或者受保护的构造器-就不能被子类化"><a href="#类如果不含公有的或者受保护的构造器-就不能被子类化" class="headerlink" title="类如果不含公有的或者受保护的构造器,就不能被子类化"></a>类如果不含公有的或者受保护的构造器,就不能被子类化</h4><h4 id="它们与其他的静态方法实际上没有任何区别"><a href="#它们与其他的静态方法实际上没有任何区别" class="headerlink" title="它们与其他的静态方法实际上没有任何区别"></a>它们与其他的静态方法实际上没有任何区别</h4><p>确实,静态方法真的只是一个静态的方法而已,如果文档上不提到创建该类的实例可以使用静态方法的时候,很容易被忽略  </p><p>所以能我们需要遵守一定的命名习惯:</p><h5 id="静态方法推荐的命名名称"><a href="#静态方法推荐的命名名称" class="headerlink" title="静态方法推荐的命名名称"></a>静态方法推荐的命名名称</h5><ul><li>valueOf 返回的实例与参数具有相同的值,一般用于类型转换(如String Boolean Double等等)</li><li>of  valueOf的简洁代替</li><li>getInstance 返回的实例工具参数而定,对于单例,则一般没有参数,并且每次返回的都是同一个实例</li><li>newInstance 每次返回一个新的实例</li><li>getType  </li><li>newType</li></ul><h4 id="不能很好的扩展到大量的可选参数"><a href="#不能很好的扩展到大量的可选参数" class="headerlink" title="不能很好的扩展到大量的可选参数"></a>不能很好的扩展到大量的可选参数</h4><p>当参数非常多的时候静态方法的可读性,维护性等就非常差了,这个后面会说</p><h3 id="实际运用"><a href="#实际运用" class="headerlink" title="实际运用"></a>实际运用</h3><p>现在在我们新建一个Fragment的时候,AS会自动生成一个<code>newInstance(String ,String )</code>的一个方法,这个就是静态工厂方法了,可见官方也推荐我们使用静态工厂方法.  </p><p>另外Java源码中也有非常多的静态工厂方法的运用,比如上面提及的<code>Executors</code>,自己去体会~</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>静态工厂方法与构造器各有优势,不过一般来说静态工厂通常更加合适,所以以后多考虑使用静态工厂吧.</p><h2 id="第2条-遇到多个构造器参数时要考虑用构建器-Builder"><a href="#第2条-遇到多个构造器参数时要考虑用构建器-Builder" class="headerlink" title="第2条 遇到多个构造器参数时要考虑用构建器(Builder)"></a>第2条 遇到多个构造器参数时要考虑用构建器(Builder)</h2><p>当实例化一个类时有很多<em>可选参数</em>的时候,我们或许会写很多不同参数的构造方法,可读性会非常差,并且客户端也不知道在什么时候用什么构造器,这是非常非常糟糕的,同样<em>静态方工厂也不能避免</em>,这个时候我们需要用到构建器,也即设计模式里的<strong>Builder模式</strong></p><p>Builder模式非常常见了,列举个列子就过了:  </p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AlertDialog dialog = <span class="keyword">new</span> <span class="type">AlertDialog</span>.Builder(<span class="built_in">this</span>)</span><br><span class="line">        .setCancelable(<span class="literal">true</span>)</span><br><span class="line">        <span class="comment">//...各种可选参数 想要什么设置什么</span></span><br><span class="line">        .setMessage(<span class="string">"Builder模式"</span>)</span><br><span class="line">        .create();</span><br></pre></td></tr></table></figure><p>Builder模式虽然能解决多参数遇到的问题,但是它也有缺点:<br><em>为了创建对象,我们必须先创建一个Builder,这是一个多余的开销</em>,虽然开销并不明显,但确实存在.</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>当有多个参数的时候,Builder模式是非常不错的选择.</p><h2 id="第3条-用私有构造器或者枚举类型强化Singleton属性"><a href="#第3条-用私有构造器或者枚举类型强化Singleton属性" class="headerlink" title="第3条 用私有构造器或者枚举类型强化Singleton属性"></a>第3条 用私有构造器或者枚举类型强化Singleton属性</h2><p>所谓<em>Singleton</em>即单例,指仅仅被实例化一次的类,这一条与单例息息相关.  </p><h3 id="私有构造器强化"><a href="#私有构造器强化" class="headerlink" title="私有构造器强化"></a>私有构造器强化</h3><p>写过单例的一定知道,构造器一定要私有,否则别人随便new,怎么保证单例呢?  </p><p>书中还讲到了单例如何<em>防反射</em>,<em>防反序列化</em>,这里就不提了  </p><h3 id="枚举强化"><a href="#枚举强化" class="headerlink" title="枚举强化"></a>枚举强化</h3><p>java 1.5 版本之后,单例多了一个实现方法(包含单个元素的枚举类型):<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">enum</span> <span class="type">Elvis</span>&#123;</span><br><span class="line"><span class="type">INSTANCE</span>;</span><br><span class="line">public <span class="built_in">void</span> leaveTheBuilding()<span class="meta">&#123;...&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>优势:  </p><ul><li>无偿提供序列化机制  </li><li>绝对防止多次实例化  </li><li>防反射  </li><li>简洁  </li></ul><p>书中说:<strong>单元素的枚举类型已经成为实现Singleton的最佳方法</strong>,可惜的是我没在实际中用过,也没见过这种实现方式.  </p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>单例有很多实现方式,也是不容易的~  </p><h2 id="第4条-通过私有构造器强化不可实例化的能力"><a href="#第4条-通过私有构造器强化不可实例化的能力" class="headerlink" title="第4条 通过私有构造器强化不可实例化的能力"></a>第4条 通过私有构造器强化不可实例化的能力</h2><p>首先理解什么是<em>不可实例化</em>?<br>不可实例化是指<strong>只包含静态方法和静态域的类</strong><br>比如<em>BitmapUtil</em>等各种Utils,它们包含各种静态方法,但是实际上我们不会也不需要去实例化它!    </p><pre><code>静态域(static-field) 比如:` public static Object obj`</code></pre><p>既然工具类不希望被实例化,那么如何做呢?  </p><p><strong>提供一个私有构造器,并在里面抛出异常即可</strong></p><p>eg:  </p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Util</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Util&#123;</span><br><span class="line">   <span class="comment">// Suppress default constructor for noninstantiability</span></span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">AssertionError</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信都会感觉这多此一举,谁tm没事去实例化工具类啊,以前我也这么觉得,直到我的膝盖中了…  </p><p>偶不,直到我在优秀的库中看到这写法,比如RxJava中的<code>Subscriptions</code>类:   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscriptions</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Subscriptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No instances!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又如<code>Jake</code>大神的<code>RxBinding</code>中各种<code>RxXXXX</code>也是如此：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">RxAppBarLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"No instances."</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>优秀的项目，细节处理都非常优秀  </p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>有时候有些东西非常有道理,只是自己太弱小,悟不到而已,虚心学习,keep growing    </p><blockquote><p>PS: EffectiveJava是本好书,RxJava是个优秀的库,Jake是真大神！！    </p></blockquote><h2 id="第5条-避免创建不必要的对象"><a href="#第5条-避免创建不必要的对象" class="headerlink" title="第5条 避免创建不必要的对象"></a>第5条 避免创建不必要的对象</h2><p>一般的讲,最后能重用对象而不是在每次需要的时候创建一个相同功能的新对象.<br>另外对于一个不可变的对象(immutable 后面会讲),它始终可以被重用.  </p><p>作者举了几个例子来说明:  </p><h3 id="创建String实例"><a href="#创建String实例" class="headerlink" title="创建String实例"></a>创建String实例</h3><p>用<code>String s = &quot;stringette&quot;;</code>替代<code>String s = new String(&quot;stringette&quot;)</code><br>因为后者的参数其实就是一个实例,每一次调用都会多创建一个没用的对象.   </p><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Boolean</span> <span class="keyword">TRUE</span> = <span class="keyword">new</span> <span class="keyword">Boolean</span>(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Boolean</span> <span class="keyword">FALSE</span> = <span class="keyword">new</span> <span class="keyword">Boolean</span>(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>Boolean.valueOf()方法重用了<code>FALSE</code>和<code>TRUE</code>来避免重复创建相同功能的对象    </p><h3 id="自动装箱autoboxing"><a href="#自动装箱autoboxing" class="headerlink" title="自动装箱autoboxing"></a>自动装箱autoboxing</h3><p>自动装箱允许我们将基本类型和装箱基本类型(Boxed Primitive Type)混用,按需自动装箱和拆箱  </p><p>它们俩之间性能是有明显的差别的(基本类型更优)  </p><p>eg:  </p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args)&#123;</span><br><span class="line">Long <span class="keyword">sum</span> = <span class="number">0</span>L;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>;i&lt;Integer.MAX_VALUE;i++)&#123;</span><br><span class="line">    <span class="keyword">sum</span> += i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="keyword">sum</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sum 的类型为<code>Long</code>,这样会比<code>long</code>多创建约2的31次方的Long实例,影响性能,所需时间大约是long的6倍多,非常可怕啊  </p><p>so,记住,<strong>优先使用基本类型!</strong>  </p><blockquote><p>PS 这里要说的不是创建对象非常昂贵,因为<em>小对象的创建和回收是非常廉价的</em>  </p></blockquote><h3 id="对象池-object-pool"><a href="#对象池-object-pool" class="headerlink" title="对象池(object pool)"></a>对象池(object pool)</h3><p>维护对象池来避免创建对象<em>只针对非常重量级的对象</em>,如数据库连接池  </p><p>Android中对象池有很多,如<code>Message</code>类,又如Glide中的Bitmap池</p><h4 id="对象池的缺点"><a href="#对象池的缺点" class="headerlink" title="对象池的缺点"></a>对象池的缺点</h4><ol><li>代码更乱  涉及到回收、重用必然会增加许多代码</li><li>增加内存占用,损害性能</li></ol><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>当需要重用的时候,就不要创建</p><h2 id="第6条-消除过期的对象引用"><a href="#第6条-消除过期的对象引用" class="headerlink" title="第6条 消除过期的对象引用"></a>第6条 消除过期的对象引用</h2><p>首先需要明确,Java即使有GC,<em>我们依然要自己考虑内存管理</em>的事情.  </p><p>当一个数组扩容后又缩减,比如size从0-&gt;200-&gt;100(一个栈先增长,后收缩),那么元素的index&gt;=100的那些元素(被pop掉的)都算是<em>过期</em>元素,那些引用就是<em>过期引用</em>(<strong>永远不会再被解除的引用</strong>)  </p><p>过期引用导致了内存泄露  </p><p>虽然对于自己来说pop掉的元素我们不会去用,但是<strong>由于过期引用的存在,GC并不会去回收它们</strong>,所以<strong>需要我们手动清空这些引用</strong>.  </p><p>eg:  </p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> pop()&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">size</span>==<span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line"><span class="keyword">Object</span> result = elements[--<span class="built_in">size</span>];</span><br><span class="line">elements[<span class="built_in">size</span>] = <span class="keyword">null</span>; <span class="comment">//Eliminate obsolete reference</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>PS:书中还提到了 *磁盘交换*(Disk Paging)--[wiki](https://en.wikipedia.org/wiki/Paging)  备注:*[虚拟内存](https://en.wikipedia.org/wiki/Virtual_memory)*  </code></pre><h2 id="第7条-避免使用终结方法"><a href="#第7条-避免使用终结方法" class="headerlink" title="第7条 避免使用终结方法"></a>第7条 避免使用终结方法</h2><p>终结方法:<code>finalizer</code> (老实说,这个真没用过)</p><p>没看懂,记录一些点..  </p><ul><li>终结方法会导致行为不稳定,降低性能,以及可移植性问题  </li><li>不能保证会被及时地执行,而且根本不保证它们会被执行(这..好过分..)  </li></ul><p>还是没看懂,被自己蠢哭了..</p><h2 id="本系列作品"><a href="#本系列作品" class="headerlink" title="本系列作品"></a>本系列作品</h2><p><a href="https://github.com/AlanCheen/ReadingNotes" target="_blank" rel="noopener">所有的读书笔记</a><br><a href="http://yifeiyuan.me/2016/04/11/%E7%AC%AC2%E7%AB%A0-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/">第2章 创建和销毁对象</a><br><a href="http://yifeiyuan.me/2016/05/18/%E7%AC%AC3%E7%AB%A0-%E5%AF%B9%E4%BA%8E%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%83%BD%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/">第3章 对于所有对象都通用的方法</a><br><a href="http://yifeiyuan.me/2016/06/20/%E7%AC%AC4%E7%AB%A0-%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/">第4章 类和接口</a>  </p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我又开始更新博客了,棒</title>
      <link href="/blog/1afe5229.html"/>
      <url>/blog/1afe5229.html</url>
      
        <content type="html"><![CDATA[<p>公司给配置了电脑,所以每天用的都是公司的电脑,很多笔记文章也都放github了  </p><p>而博客在自己的电脑上,导致博客长时间没更新了,也有很多以前的TODO都没有完成  </p><p>去NexT官网看了,又更新了好多东西  </p><p>比如给博客新增了阅读次数,好棒,添加了一下该功能~  </p><p>为了什么呢?明明没什么人看—-为了打自己脸  </p><p>呵呵,开心就好  </p><p>恩  </p><p>我又更博客了,这是个好消息  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git规范</title>
      <link href="/blog/95244a08.html"/>
      <url>/blog/95244a08.html</url>
      
        <content type="html"><![CDATA[<h2 id="分支模型"><a href="#分支模型" class="headerlink" title="分支模型"></a>分支模型</h2><p>每个项目必须要有<code>master</code>、<code>develop</code>分支。<br>每个开发人员拥有一个自己的分支，如<code>czn</code>、<code>mrfu</code>。  </p><h3 id="master-分支"><a href="#master-分支" class="headerlink" title="master 分支"></a>master 分支</h3><p><code>master</code> 分支<strong>只能存在release版本</strong>的代码，并需要对每个release<strong>打对应的tag</strong>。  </p><h3 id="develop-分支"><a href="#develop-分支" class="headerlink" title="develop 分支"></a>develop 分支</h3><p><code>develop</code> 由<code>master</code>分支检出，它作用主要是日常开发合并代码，并与<code>master</code>分支做交互。<br>当参与开发的人员较多时，可指定一个人管理<code>develop</code>分支，专门负责合并代码，便于管理，避免多人同时使用develop分支而出现问题。  </p><p>另外当功能开发完毕后，代码合并入<code>develop</code>分支，测试完成通过后，merge到master分支，并在master上打tag。  </p><a id="more"></a><h3 id="开发人员自己的分支"><a href="#开发人员自己的分支" class="headerlink" title="开发人员自己的分支"></a>开发人员自己的分支</h3><p>开发人员自己的分支，由<code>develop</code>分支检出，是自己负责的功能分支的上游</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h3 id="Feature-（新需求开发）"><a href="#Feature-（新需求开发）" class="headerlink" title="Feature （新需求开发）"></a>Feature （新需求开发）</h3><p>当有新需求需要开发时： </p><ol><li>每个开发人员在自己的分支上检出一个新的feature分支，如在<code>czn</code>上检出<code>feature_search</code>分支</li><li>在新的feature分支上进行开发</li><li>新功能开发完毕后合并到自己的分支</li><li>所有人员的分支合并到develop分支，并进行测试</li><li>测试通过后合并到master，并打tag</li></ol><h3 id="Hotfix-（紧急修复bug）"><a href="#Hotfix-（紧急修复bug）" class="headerlink" title="Hotfix （紧急修复bug）"></a>Hotfix （紧急修复bug）</h3><p>当有紧急bug需要修复时  </p><ol><li>从master 拉分支hotfix_xxx  </li><li>修复完毕后合并到develop分支  </li><li>测试完毕后合并到master分支，并打tag  </li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>分支模型已经工作流程大约如图所示：<br><img src="http://ww1.sinaimg.cn/mw690/98900c07gw1f248jlj1haj20vy16cai2.jpg" alt="分支模型-工作流程"></p><h2 id="Gitflow"><a href="#Gitflow" class="headerlink" title="Gitflow"></a>Gitflow</h2><p>gitflow是git的一个辅助工具，可以简化我们新建分支，合并分支，删除分支的操作，也可以减少人工误操作而出错的概率  </p><p>举个例子：<br>新功能能开发，使用gitflow之前：   </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git checkout czn</span><br><span class="line">git checkout -<span class="selector-tag">b</span> feature_search</span><br><span class="line">..<span class="selector-class">.developing</span>...</span><br><span class="line">git checkout czn</span><br><span class="line">git merge feature_search</span><br><span class="line">git branch -d feature_search</span><br></pre></td></tr></table></figure><p>使用gitflow之后：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git flow feature <span class="keyword">start</span> <span class="keyword">search</span></span><br><span class="line">...developing...</span><br><span class="line">git flow feature <span class="keyword">finish</span> <span class="keyword">search</span></span><br></pre></td></tr></table></figure><p>是不是省去了很多繁琐的操作？  </p><blockquote><p>gitflow 的功能不止如此~    </p></blockquote><p>gitflow虽好，但是考虑到大家刚开始使用git，需要熟悉git以及git命令，所以它现在不是强制的，如果有兴趣或者你也懒得敲那么多命令的话，建议看看 <a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html" target="_blank" rel="noopener">git-flow 备忘清单</a>  </p><blockquote><p>PS: 事实上git最开始是没有gitflow的，它是用户实际经验的总结，so，希望我们团队最终能拥有最适合我们自己的gitflowgitf  </p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>规范是死的，人是活的，上诉所说都是比较理想化的，实际情况可能更加复杂，大家可以根据实际情况调整。  </p><p>如果有疑问或更好的建议，欢迎反馈~~~        </p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git分享</title>
      <link href="/blog/7591e963.html"/>
      <url>/blog/7591e963.html</url>
      
        <content type="html"><![CDATA[<h2 id="控制版本系统-VCS"><a href="#控制版本系统-VCS" class="headerlink" title="控制版本系统(VCS)"></a>控制版本系统(VCS)</h2><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统  </p><h3 id="集中化控制系统-CVCS"><a href="#集中化控制系统-CVCS" class="headerlink" title="集中化控制系统(CVCS)"></a>集中化控制系统(CVCS)</h3><p>集中化控制系统都有一个单一的集中管理的服务器,保存所有文件的修订版本,客户端通过这台服务器获取文件或提交更新.</p><p><img src="http://git-scm.com/figures/18333fig0102-tn.png" alt=""></p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>很明显,中央服务器是个中心,一旦它出了问题就会影响整个系统.  </p><p>中央服务器单点故障,如果服务器一挂,那么整个系统就挂了,无法工作  </p><p>甚至,中央服务器磁盘故障,很可能导致数据丢失,丢失所有历史更改记录等重要信息.  </p><h3 id="分布式版本控制系统-DVCS"><a href="#分布式版本控制系统-DVCS" class="headerlink" title="分布式版本控制系统(DVCS)"></a>分布式版本控制系统(DVCS)</h3><p>客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份</p><p><img src="http://git-scm.com/figures/18333fig0103-tn.png" alt=""></p><h2 id="Git–控制版本之神"><a href="#Git–控制版本之神" class="headerlink" title="Git–控制版本之神"></a>Git–控制版本之神</h2><h3 id="简史"><a href="#简史" class="headerlink" title="简史"></a>简史</h3><p>作者,大神 Linus Torvalds</p><p>优点:</p><ul><li>速度</li><li>简单的设计</li><li>对非线性开发模式的强力支持（允许上千个并行开发的分支）</li><li>完全分布式</li><li>有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</li></ul><a id="more"></a><h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>git config –global</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global user.name <span class="string">"alan"</span></span><br><span class="line">git<span class="built_in"> config </span>--global user.email alancheen06@gmail.com</span><br></pre></td></tr></table></figure><p><code>git config --list</code> 查看配置列表</p><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p><code>git init</code>用来初始化项目</p><p>它会创建一个<code>.git</code>目录,它包含所有初始化git的所有文件</p><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">url</span></span><br><span class="line">git <span class="keyword">clone</span> <span class="title">url</span> name <span class="comment">#重命名成name</span></span><br></pre></td></tr></table></figure><h2 id="文件的状态"><a href="#文件的状态" class="headerlink" title="文件的状态"></a>文件的状态</h2><p>接下去的命令跟</p><p><img src="http://git-scm.com/book/en/v2/book/02-git-basics/images/lifecycle.png" alt=""></p><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p>untracked===&gt;staged</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> file</span></span><br><span class="line">git <span class="keyword">add</span><span class="bash"> .</span></span><br></pre></td></tr></table></figure><p>staged===&gt;untracked</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="keyword">HEAD</span> <span class="keyword">file</span></span><br></pre></td></tr></table></figure><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">commit</span> -m <span class="string">"init"</span></span><br><span class="line">git <span class="keyword">commit</span> -a -m <span class="string">"init"</span></span><br><span class="line">git <span class="keyword">commit</span> -am <span class="string">"init"</span></span><br></pre></td></tr></table></figure><h3 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h3><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span><span class="keyword">branchname</span></span><br></pre></td></tr></table></figure><blockquote><p>PS:当init一个仓库时,master需要先commit一遍才能新建其他分支,否则会得到一个错误<code>fatal: Not a valid object name:&#39;master&#39;.</code></p></blockquote><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git checkout branchname</span></span><br></pre></td></tr></table></figure><h4 id="创建并切换分支"><a href="#创建并切换分支" class="headerlink" title="创建并切换分支"></a>创建并切换分支</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -<span class="selector-tag">b</span> branchname</span><br></pre></td></tr></table></figure><h4 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r -<span class="selector-tag">a</span> -l</span><br></pre></td></tr></table></figure><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">branch </span>-d <span class="keyword">banchname </span> <span class="comment">#删除本地分支  </span></span><br><span class="line">git <span class="keyword">branch </span>--delete <span class="keyword">branchname </span><span class="comment">#删除远程分支</span></span><br></pre></td></tr></table></figure><h3 id="远程协作"><a href="#远程协作" class="headerlink" title="远程协作"></a>远程协作</h3><h4 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin <span class="literal">master</span></span><br></pre></td></tr></table></figure><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>git log</p><p>git reflog</p><p>git reset</p><p>git stash/pop</p><p>git help add</p><p>….</p><h3 id="gitignore"><a href="#gitignore" class="headerlink" title="gitignore"></a>gitignore</h3><h3 id="gitflow"><a href="#gitflow" class="headerlink" title="gitflow"></a>gitflow</h3><h2 id="iTerm-oh-my-zsh"><a href="#iTerm-oh-my-zsh" class="headerlink" title="iTerm+oh my zsh"></a>iTerm+oh my zsh</h2><h2 id="Git学习资料推荐"><a href="#Git学习资料推荐" class="headerlink" title="Git学习资料推荐"></a>Git学习资料推荐</h2><p>git学习资料太多,但是鱼龙混杂,很多都是抄来抄去,错误百出,这里收集一些优秀的资料.  </p><h3 id="GitPro2"><a href="#GitPro2" class="headerlink" title="GitPro2"></a><a href="http://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">GitPro2</a></h3><p>内容很多,很详细,堪称权威,而且还有中文版,还有pdf等下载,一定要看看.</p><h3 id="git-简明指南-很棒"><a href="#git-简明指南-很棒" class="headerlink" title="git-简明指南(很棒)"></a><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener">git-简明指南(很棒)</a></h3><p>非常棒的指南,极力推荐</p><h3 id="githug"><a href="#githug" class="headerlink" title="githug"></a><a href="https://github.com/Gazler/githug" target="_blank" rel="noopener">githug</a></h3><p>一个git的游戏,现在一共有54个关卡,从init开始,让你在玩的过程中学习git,挺有意思</p><h3 id="learnGitBranching"><a href="#learnGitBranching" class="headerlink" title="learnGitBranching"></a><a href="http://pcottle.github.io/learnGitBranching/" target="_blank" rel="noopener">learnGitBranching</a></h3><p>又是一个学习git的游戏,不过这个是针对分支的游戏,非常棒~非常推荐</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git分支常用命令</title>
      <link href="/blog/96ece75c.html"/>
      <url>/blog/96ece75c.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><p><code>git branch &lt;branchname&gt;</code>  </p><p><code>git checkout -b &lt;branchname&gt;</code> 创建并检出到新分支</p><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><h3 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h3><p><code>git branch -d branchname</code></p><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>git 1.7之前 :<code>git push origin :branchname</code> 注意<code>origin</code>后面有个空格,而<code>:</code>后面不能跟空格,什么鬼语法!<br>还好git 1.7之后可用 :<code>git push origin --delete branchname</code>,这个好容易理解<br><a id="more"></a></p><h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2><p><code>git branch [options]</code></p><ul><li>-r 查看远程分支</li><li>-l 查看本地分支</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>当init一个仓库时,master需要先commit一遍才能新建其他分支,否则会得到一个错误<code>fatal: Not a valid object name: &#39;master&#39;.</code></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android屏幕适配</title>
      <link href="/blog/f5bef4f2.html"/>
      <url>/blog/f5bef4f2.html</url>
      
        <content type="html"><![CDATA[<h2 id="屏幕适配"><a href="#屏幕适配" class="headerlink" title="屏幕适配"></a>屏幕适配</h2><p>Android设备众多,虽然Android会自动缩放,重新定尺寸来适应,但是<code>you should make the effort to optimize your application for different screen sizes and densities</code></p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>Screen size</li></ul><p>屏幕大小(屏幕的对角线长度,单位为英寸,1英寸=2.54cm),按屏幕大小可分:<code>small, normal, large, and extra-large.</code></p><ul><li>Screen density(dpi)</li></ul><p>屏幕密度,某个尺寸区域内的像素密度(跟数学题求密度差不多,即面积/数量),它通常就是<code>dpi (dots per inch)</code>,<br>根据屏幕密度可分为<code>low, medium, high, extra-high, extra-extra-high, and extra-extra-extra-high.</code>,<br>与我们项目中的<code>mdpi</code>,<code>hdpi</code>,<code>xhdpi</code>等对应,可以看出<code>x</code>是<code>extra</code>的缩写,<code>h</code>是high的缩写~       </p><ul><li><p>Resolution<br>分辨率,整个屏幕所包含的物理像素,如经常听到的1080<em>1920,480</em>800,屏幕大小一定,分辨率越高越清晰,这相信大家都知道</p></li><li><p>Density-independent pixel (dp/dip)<br>密度独立像素,我们布局的时候最常用也最推荐的单位就是这个了!</p></li></ul><p>Android按160dpi为标准,在160dpi的设备中,1dp=1px,由此也可以得知dp与px的换算公式:<code>px = dp * (dpi / 160)</code></p><p>非常值得注意的是,在Android中有个<code>DisplayMetrics</code>类,它存放了部分displayer的信息,当我们在PX与DP之间转换时,我们可能已经见到过如下方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dip2px</span><span class="params">(Context context, <span class="keyword">float</span> dpValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> density = context.getResources().getDisplayMetrics().density;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (dpValue * scale + <span class="number">0.5f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">px2dip</span><span class="params">(Context context, <span class="keyword">float</span> pxValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> density = context.getResources().getDisplayMetrics().density;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (pxValue / scale + <span class="number">0.5f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意,代码中的<code>density</code>与我们之前所说的screen density不同,这个density是 <strong><em>(screen density)/160</em></strong> 的值!!!<br>所以把它代入到之前的换算公式中去就得到了px=dp*density,那么为什么代码中出现了0.5f呢?那是为了避免精度损失.</p><p>  PS:如果你需要知道当前设备的dpi,可以用metrics.densityDpi来获取,另外其实Android系统还有一个类提供了各种单位之间的转换–&gt;<code>TypedValue</code>  </p><h2 id="sw-sh-w-h"><a href="#sw-sh-w-h" class="headerlink" title="sw/sh/w/h"></a><a href="http://developer.android.com/intl/zh-cn/guide/practices/screens_support.html#NewQualifiers" target="_blank" rel="noopener">sw/sh/w/h</a></h2><p>sw,sh是3.2开始出现的限定词:如: layout-sw600dp, values-sw600dp</p><ul><li><em>sw<n>dp</n></em> 表示smallestwidth,当最下宽度大于N时采用,如sw600dp表示设备的宽度大于600dp时采用  </li><li><p><em>sh<n>dp</n></em> 表示smallestheight  </p><p>PS: sw,sh不会随着屏幕变化而变化,</p></li><li><p><em>w<n>dp</n></em>,<em>h<n>dp</n></em> 与之前的不同,它们随着屏幕的变化而变化的  </p></li></ul><p>值得一说的是,并不推荐用这种方式!  </p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="http://developer.android.com/intl/zh-cn/guide/practices/screens_support.html" target="_blank" rel="noopener">Supporting Multiple Screens</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 屏幕适配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android MutilDex解决方案</title>
      <link href="/blog/47af996.html"/>
      <url>/blog/47af996.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近也遇到了mutildex的问题,原因是一个dex.class不能超过65536,根据官网的指示<a href="http://developer.android.com/intl/zh-cn/tools/building/multidex.html" target="_blank" rel="noopener">Building Apps with Over 65K Methods</a><br>解决了,记录一下步骤</p><h3 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h3><p>添加依赖 <code>compile &#39;com.android.support:multidex:1.0.0&#39;</code></p><h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><p>配置app的<code>build.gradle</code>,新增<code>multiDexEnabled true</code>如下:   </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">defaultConfig</span> &#123;</span><br><span class="line">   <span class="attribute">multiDexEnabled</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h3><p>让App继承<a href="http://developer.android.com/intl/zh-cn/reference/android/support/multidex/MultiDexApplication.html" target="_blank" rel="noopener">MultiDexApplication</a></p><h3 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h3><p>重写App的<code>attachBaseContext</code>方法<br>如下:<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line"> MultiDex.install(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="获取当前项目的方法数"><a href="#获取当前项目的方法数" class="headerlink" title="获取当前项目的方法数"></a>获取当前项目的方法数</h2><a id="more"></a><p>现在有个gradle插件可以检测当前项目所占的总方法数–&gt;<a href="https://github.com/KeepSafe/dexcount-gradle-plugin" target="_blank" rel="noopener">dexcount</a>,使用很简单.</p><h3 id="step1-配置app-build-gradle"><a href="#step1-配置app-build-gradle" class="headerlink" title="step1 配置app/build.gradle"></a>step1 配置app/build.gradle</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        mavenCentral() <span class="comment">// or jcenter()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">'com.getkeepsafe.dexcount:dexcount-gradle-plugin:0.3.1'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: <span class="string">'com.getkeepsafe.dexcount'</span></span><br></pre></td></tr></table></figure><h3 id="step2-build项目即可"><a href="#step2-build项目即可" class="headerlink" title="step2 build项目即可"></a>step2 build项目即可</h3><p>编译项目,如<code>./gradlew assembleDebug</code><br>就可以得知结果了:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:app:assembleInternalDebug</span><br><span class="line">Total methods <span class="keyword">in</span> app-Internal-debug<span class="selector-class">.apk</span>: <span class="number">58359</span></span><br><span class="line">Total fields <span class="keyword">in</span> app-Internal-debug<span class="selector-class">.apk</span>:  <span class="number">31843</span></span><br><span class="line">Methods remaining <span class="keyword">in</span> app-Internal-debug<span class="selector-class">.apk</span>: <span class="number">7176</span></span><br><span class="line">Fields remaining <span class="keyword">in</span> app-Internal-debug<span class="selector-class">.apk</span>:  <span class="number">33692</span></span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br></pre></td></tr></table></figure></p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>后来另外一个项目也到了需要使用mutildex的情况,然而当我配置完后,发现出现了另外的问题,<code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code>,仔细检查,发现并没有配置错误,于是内心是崩溃的…  </p><p>搜索之后,发现这里有个讨论—&gt;<a href="http://stackoverflow.com/questions/5839359/java-lang-outofmemoryerror-gc-overhead-limit-exceeded" target="_blank" rel="noopener">stackoverflow</a>,最后添加了个配置到app/build.gradle文件即可</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">dexOptions</span> &#123;</span><br><span class="line">        <span class="attribute">javaMaxHeapSize</span> <span class="string">"4g"</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>呵呵,又学了一招!~~</p><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><ol><li>艺术探索中也有提到,可以看看  </li><li><a href="http://blog.csdn.net/t12x3456/article/details/40837287" target="_blank" rel="noopener"> Android 使用android-support-multidex解决Dex超出方法数的限制问题,让你的应用不再爆棚</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mutildex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atom学习笔记</title>
      <link href="/blog/4eaa987.html"/>
      <url>/blog/4eaa987.html</url>
      
        <content type="html"><![CDATA[<p>#Atom<a href="https://atom.io/docs" target="_blank" rel="noopener">官网</a></p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ol><li>cmd+shift+p  打开命令窗口,可以运行各种菜单功能</li><li>cmd+t  快速多文件切换</li><li>ctrl+g 文件内跳转到指定行</li><li>cmd+f 文件内查找和替换</li><li>cmd+shift+f 多文件查找和替换</li><li>cmd+[ 对选中内容向左缩进</li><li>cmd+] 对选中中内容向右缩进</li><li>ctrl+shift+m 开关cmddown实时预览</li><li>cmd+w 关闭tab</li></ol><a id="more"></a><h2 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h2><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>岁月是一场有去无回的旅行</title>
      <link href="/blog/67c4e285.html"/>
      <url>/blog/67c4e285.html</url>
      
        <content type="html"><![CDATA[<h2 id="时间是让人猝不及防的东西"><a href="#时间是让人猝不及防的东西" class="headerlink" title="时间是让人猝不及防的东西"></a>时间是让人猝不及防的东西</h2><p>谁能想到原来在学校打着LOL,学的是ps,ai,3dmax本该做个美工的我,竟然学了一年多的Android了.</p><pre><code>岁月是一场有去无回的旅行,好的坏的都是风景</code></pre><p>坏:  </p><ol><li>遇到坏房东,人在异乡,尝到了无家可归的滋味.  </li><li>加班严重,带来很多负面影响,如身子变差,没时间陪女朋友,没时间常回家看看.  </li><li>外公去世,这世界又少了一个最疼爱我的人.  </li></ol><p>好:  </p><ol><li>跟女朋友依然相爱,并没有毕业分  </li><li>学习android虽然坎坎坷坷,但是一路坚持过来了,度过了小白的阶段   </li><li>为Android开源贡献了一点绵薄之力  </li><li>参加了杭州GDG,杭州线下聚会</li><li>认识了许许多多的良师益友,志同道合的好友  </li></ol><p>排名不分先后:<br>教父,凯哥,Ail,晓峰,代码家,马琳,医生,刚哥,百万,梁飞,Asha,老穆,泡在网上的日子,蛤蟆,T大,Simple,lightsky,笔记,凯子哥,信,邓子,黑燕,Nick,MrFu,杨辉,轻微,小龙,启超,菲菲,小黑屋<br>干货群,github交流群,艺术探索群等群友,当然还有自己KeepGrowing的群友,不一一列举了</p><pre><code>走过的那些曲折,原来留下的都是真的</code></pre><p>感谢我女朋友的陪伴,感谢各路朋友的支持,2016有很多很多想做的事情,希望我能够顺利达成心愿.</p>]]></content>
      
      
      <categories>
          
          <category> 人生路上 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2015总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令之Tag</title>
      <link href="/blog/2cc62eec.html"/>
      <url>/blog/2cc62eec.html</url>
      
        <content type="html"><![CDATA[<h2 id="标签-tag"><a href="#标签-tag" class="headerlink" title="标签 tag"></a>标签 tag</h2><p>标签的作用不言而喻,一般当我们release一个版本的时候打个tag.</p><h3 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h3><ul><li>查看已有标签<br><code>git tag</code></li><li>特定的搜索模式列出符合条件的标签<br><code>git tag -l &#39;v1.4.2.*&#39;</code></li><li>查看指定tag<br><code>git show [tagname]</code></li></ul><h3 id="新建tag"><a href="#新建tag" class="headerlink" title="新建tag"></a>新建tag</h3><p>Git 使用的标签有两种类型：<strong>轻量级的（lightweight）</strong>和<strong>含附注的（annotated）</strong></p><p>一般用包含信息的<code>-a</code>:</p><p><code>$ git tag -a v1.4 -m &#39;这里写些信息&#39;</code></p><h3 id="给指定的commitId-打tag"><a href="#给指定的commitId-打tag" class="headerlink" title="给指定的commitId 打tag"></a>给指定的commitId 打tag</h3><p><code>git tag -a [tagname] -m [msg] commitid</code></p><p>eg.<code>git tag -a v0.1 -m &quot;add tag v0.1&quot; 6c46c1</code></p><h3 id="push-tag"><a href="#push-tag" class="headerlink" title="push tag"></a>push tag</h3><p>tag需要单独push</p><ul><li><code>git push origin [tagname]</code></li><li><code>git push --tags</code></li></ul><p>OK,常用的tag命令就这样!</p><h2 id="资料推荐"><a href="#资料推荐" class="headerlink" title="资料推荐"></a>资料推荐</h2><p><a href="http://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5-Git-%E7%AE%80%E5%8F%B2" target="_blank" rel="noopener">Pro Git</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javadoc_generation_failed</title>
      <link href="/blog/806b4a16.html"/>
      <url>/blog/806b4a16.html</url>
      
        <content type="html"><![CDATA[<p>今天在升级Utils,把Utils升级,上传到JCenter的时候遇到了一个错误:</p><p><img src="http://ww1.sinaimg.cn/large/98900c07gw1ezgr025mh7j20oh04rmy2.jpg" alt="Javadoc_generation_failed"></p><p>搜索后发现原因是代码里<strong>包含了Html格式的代码</strong>,我表示很疑惑,因为我并没有写过Html格式的代码呀,我写的是Java,怎么会有这个错误呢?  </p><p>然后百般寻找,发现格式化代码的时候,AS自动生成了一个<code>&lt;/p&gt;</code>的标签,删除后就可以了!!!  </p><p>又长见识了!~~  </p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><pre><code>http://stackoverflow.com/questions/26552279/gradle-build-fails-with-javadoc-nullpointerexception</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jcenter </tag>
            
            <tag> javadoc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推特分享后续</title>
      <link href="/blog/731849c3.html"/>
      <url>/blog/731849c3.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前写过一篇做Twitter登录与分享功能的,那时候分享是通过调用客户端的,然而现在需要改成调用Twitter的API实现分享,诶,相当于之前做的都白做了,心里万头草泥马奔腾啊.<br><a id="more"></a></p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://dev.twitter.com/rest/reference/post/media/upload" target="_blank" rel="noopener">media/upload</a><br><a href="https://dev.twitter.com/rest/reference/post/statuses/update" target="_blank" rel="noopener">statuses/update</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> todo </tag>
            
            <tag> Twitter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Glide</title>
      <link href="/blog/264ef024.html"/>
      <url>/blog/264ef024.html</url>
      
        <content type="html"><![CDATA[<h2 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a><a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">Glide</a></h2><pre><code>An image loading and caching library for Android focused on smooth scrolling</code></pre><p>Glide专注于顺畅滑动的一个图片加载缓存库.  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'com.github.bumptech.glide:glide:3.6.1'</span></span><br><span class="line"><span class="keyword">compile</span> <span class="string">'com.android.support:support-v4:19.1.0'</span></span><br></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>与UIL的使用方式不同,Glide的API与Picasso类似,链式调用,非常舒服.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(myFragment)</span><br><span class="line">        .load(url)</span><br><span class="line">        .centerCrop()</span><br><span class="line">        .placeholder(R.drawable.loading_spinner)</span><br><span class="line">        .crossFade()</span><br><span class="line">        .into(myImageView);</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><h2 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-keep public <span class="class"><span class="keyword">class</span> * <span class="title">implements</span> <span class="title">com</span>.<span class="title">bumptech</span>.<span class="title">glide</span>.<span class="title">module</span>.<span class="title">GlideModule</span></span></span><br><span class="line">-keep public <span class="class"><span class="keyword">enum</span> <span class="title">com</span>.<span class="title">bumptech</span>.<span class="title">glide</span>.<span class="title">load</span>.<span class="title">resource</span>.<span class="title">bitmap</span>.<span class="title">ImageHeaderParser</span>$** &#123;</span></span><br><span class="line">    **[] $VALUES;</span><br><span class="line">    public *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一句是自定义<code>GlideModule</code>添加的混淆,具体可以看<a href="https://github.com/bumptech/glide/wiki/Configuration" target="_blank" rel="noopener">这里</a></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>任何一款框架都有自己的优缺点,Glide也不例外.  </p><p><strong>优点:</strong>    </p><ul><li>功能强大,能获取解析并显示<strong>视频预览图片</strong>(video stills?),图片,<strong>GIF</strong>.  </li><li>灵活、易用的API</li><li>自带淡入淡出动画,比较美观</li><li>可以与<code>OKHttp</code> <code>Volley</code>结合</li><li>一般使用无需配置,立即上手</li><li><strong>响应Activity以及Fragment的生命周期</strong>,在stop时停止加载(<em>已经启动的任务不能停止</em>),onStart时继续加载</li><li><strong>Item重用时会自动取消图片加载(所以滑动的时候才那么流畅)</strong></li><li>解决列表加载图片错乱问题</li></ul><p><strong>缺点:</strong>     </p><ul><li>2882个方法相比较与UIL(1202)来说多了好多  </li><li>配置项少,而且配置麻烦,不像UIL那么多而方便  </li><li><code>setTag</code>方法被占用  </li></ul><p><strong>小结:</strong><br>正如Glide的口号所说,Glide对列表滑动做了很多优化,所以使得Glide在列表滑动的时候表现非常优秀.</p><h2 id="推荐资料"><a href="#推荐资料" class="headerlink" title="推荐资料"></a>推荐资料</h2><p><a href="https://github.com/bboyfeiyu/android-tech-frontier/tree/master/others/Google%E6%8E%A8%E8%8D%90%E7%9A%84%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93Glide%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">Google推荐的图片加载库Glide介绍</a><br><a href="http://blog.csdn.net/fandong12388/article/details/46372255" target="_blank" rel="noopener">android学习之路(一)–Glide学习</a><br><a href="http://www.fanxu.me/post/2015-10-10?utm_source=tuicool" target="_blank" rel="noopener">Glide的图片内存优化</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Glide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ContentProvider的authorities属性</title>
      <link href="/blog/5d97569d.html"/>
      <url>/blog/5d97569d.html</url>
      
        <content type="html"><![CDATA[<h2 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h2><h2 id="authorities属性的唯一性"><a href="#authorities属性的唯一性" class="headerlink" title="authorities属性的唯一性"></a>authorities属性的唯一性</h2><p>关于ContentProvider,一直都了解不多,最近遇到个问题.<br>我们两个App都用了一个第三方库,当我想同时安装我们的App时,遇到了一个错误:<code>INSTALL FAILED CONFLICTING PROVIDER</code>,一直安装失败.  </p><p>搜索了一遍后在SF上找到了<a href="http://stackoverflow.com/questions/16267785/install-shows-error-in-console-install-failed-conflicting-provider" target="_blank" rel="noopener">答案</a></p><p>原来<code>android:authorities</code> must be unique.</p><pre><code>To avoid conflicts, authority names should use a Java-style naming convention (such ascom.example.provider.cartoonprovider). Typically, it&apos;s the name     of the ContentProvider subclass that implements the provider</code></pre><p>在xml里配置<code>authorities</code>属性必须唯一,所以当我们两个app配置得一样时,就会失败,于是修改一下这个属性即可.</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="http://developer.android.com/intl/zh-cn/guide/topics/manifest/provider-element.html#auth" target="_blank" rel="noopener">manifest/provider-element.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ContentProvider </tag>
            
            <tag> authorities </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度</title>
      <link href="/blog/4b6d6bc1.html"/>
      <url>/blog/4b6d6bc1.html</url>
      
        <content type="html"><![CDATA[<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>看了<a href="http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=420893082&amp;idx=1&amp;sn=a89faf1e77b3501dd107dd2a28a41c20&amp;scene=0" target="_blank" rel="noopener">时间复杂度的故事</a>做了点摘抄.</p><h3 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h3><p>如果它处理 N 个元素求和所花的时间是 T，那么它处理 N   2 个元素的和所花的时间就是 T  2。<strong>所以随着 N 变大，时间 T 的变大是与 N 呈「线性」关系的。</strong></p><p>在时间复杂度中，<strong>我们用 O(N) 表示这种「线性」时间复杂度。</strong></p><h3 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h3><p>对于类似二分法来说,输入的元素个数虽然翻倍，但是程序运行所花的时间却只增加了 1，<strong>我们把这种时间复杂度要叫「对数」时间复杂度，用 O(logN) 来表示</strong>。</p><h3 id="其他复杂度"><a href="#其他复杂度" class="headerlink" title="其他复杂度"></a>其他复杂度</h3><a id="more"></a><p><strong>「常数」时间复杂度</strong>，例如返回一个有序数组中的最小数，这个数因为始终在第一个位置，所以就不会受到数组大小的影响，无论数组多大，我们都可以在一个固定的时间返回结果。</p><p><strong>「线性对数」时间复杂度，即 O(N*logN)</strong> ，这个复杂度比较常见，因为常见的高效的排序算法，都是这个时间复杂度，比如 <strong>快速排序，堆排序，归并排序</strong>等。</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=420893082&amp;idx=1&amp;sn=a89faf1e77b3501dd107dd2a28a41c20&amp;scene=0" target="_blank" rel="noopener">时间复杂度的故事</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android中的IPC机制</title>
      <link href="/blog/ed5672a2.html"/>
      <url>/blog/ed5672a2.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><a id="more"></a><h3 id="关于ShareUID的疑问"><a href="#关于ShareUID的疑问" class="headerlink" title="关于ShareUID的疑问"></a>关于ShareUID的疑问</h3><p>在Android的清单文件里可以给app配置<code>sharedUserId</code>属性</p><ul><li><p><code>android:sharedUserId</code></p><p>  The name of a Linux user ID that will be shared with other     applications. By default, Android assigns each application     its own unique user ID. However, if this attribute is set to     the same value for two or more applications, they will all     share the same ID — provided that they are also signed by the     same certificate. Application with the same user ID can     access each other’s data and, if desired, run in the same     process.</p></li></ul><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="http://developer.android.com/intl/zh-cn/guide/topics/manifest/manifest-element.html" target="_blank" rel="noopener">manifest-shareuid</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android开发艺术探索 </tag>
            
            <tag> IPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADP视频学习笔记</title>
      <link href="/blog/81f8067c.html"/>
      <url>/blog/81f8067c.html</url>
      
        <content type="html"><![CDATA[<h2 id="ADP"><a href="#ADP" class="headerlink" title="ADP"></a>ADP</h2><p>ADP全称 <em>Android Development Patterns</em>,google出的视频,口号是<strong>Build better apps</strong><br>本文记录我该系列的学习笔记.<br><a id="more"></a></p><h2 id="Protecting-Implicit-Intents-with-Runtime-Checks-01"><a href="#Protecting-Implicit-Intents-with-Runtime-Checks-01" class="headerlink" title="Protecting Implicit Intents with Runtime Checks 01"></a><a href="https://www.youtube.com/watch?v=HGElAW224dE" target="_blank" rel="noopener">Protecting Implicit Intents with Runtime Checks 01</a></h2><p>问题:当使用隐式Intent去启动activity时,如果没有匹配到符合条件的Activity会crash.  </p><p>解决:我们需要使用Intent的<code>resolveActivity</code>去判断是否匹配到了Activity,匹配到才去start:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (intent.resolveActivity(getPackageManager()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的例子可以看看以前写的<a href="http://www.jianshu.com/p/eaae783b931f" target="_blank" rel="noopener">Android调用手机浏览器的正确方式</a>,方法是一样的.</p><h2 id="Using-NotificationCompat-for-Beautiful-Notifications-02"><a href="#Using-NotificationCompat-for-Beautiful-Notifications-02" class="headerlink" title="Using NotificationCompat for Beautiful Notifications 02"></a><a href="https://www.youtube.com/watch?v=-iog_fmm6mE" target="_blank" rel="noopener">Using NotificationCompat for Beautiful Notifications 02</a></h2><h3 id="使用-NotificationCompat-来构建通知"><a href="#使用-NotificationCompat-来构建通知" class="headerlink" title="使用 NotificationCompat 来构建通知"></a>使用 <code>NotificationCompat</code> 来构建通知</h3><p>有一些小差别,注意最后的<code>from</code><br><img src="http://ww1.sinaimg.cn/large/98900c07gw1ez091buqs2j20dy0blq4j.jpg" alt="build"></p><h3 id="增加辨识度"><a href="#增加辨识度" class="headerlink" title="增加辨识度"></a>增加辨识度</h3><p><img src="http://ww2.sinaimg.cn/large/98900c07gw1ez092w0hcdj20e80bz3zh.jpg" alt="recognizable"></p><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><p><img src="http://ww2.sinaimg.cn/large/98900c07gw1ez09neixbzj20ds0bodh5.jpg" alt="style"></p><h3 id="扩展通知"><a href="#扩展通知" class="headerlink" title="扩展通知"></a>扩展通知</h3><p><img src="http://ww2.sinaimg.cn/large/98900c07gw1ez09qp4qq2j20dx0b8q44.jpg" alt="expand"></p><p>接下去是一些Wear auto car的了</p><h3 id="WearableExtender"><a href="#WearableExtender" class="headerlink" title="WearableExtender"></a>WearableExtender</h3><p><img src="http://ww4.sinaimg.cn/large/98900c07gw1ez09s5nm0qj20cz08vdgw.jpg" alt="wearable"></p><h3 id="Wear-your-best"><a href="#Wear-your-best" class="headerlink" title="Wear your best"></a>Wear your best</h3><p><img src="http://ww1.sinaimg.cn/large/98900c07gw1ez09t1r4jpj20e50bhdgw.jpg" alt="wear_best"></p><h3 id="AndroidAuto-amp-CarExtender"><a href="#AndroidAuto-amp-CarExtender" class="headerlink" title="AndroidAuto&amp;CarExtender"></a>AndroidAuto&amp;CarExtender</h3><p><img src="http://ww2.sinaimg.cn/large/98900c07gw1ez09urt62tj20cl0bkjse.jpg" alt="auto_car"></p><h2 id="Runtime-Permissions-in-Android-6-0-Marshmallow"><a href="#Runtime-Permissions-in-Android-6-0-Marshmallow" class="headerlink" title="Runtime Permissions in Android 6.0 Marshmallow"></a><a href="https://www.youtube.com/watch?v=C8lUdPVSzDk" target="_blank" rel="noopener">Runtime Permissions in Android 6.0 Marshmallow</a></h2><p>6.0新增的运行时权限流程:<br><img src="http://ww4.sinaimg.cn/large/98900c07gw1ez0a1665jnj20h403074h.jpg" alt="flow"></p><p>在实际开发中,我们需要先判断是否是6.0,如果是就需要去检测是否有这个权限,如果没有,则去请求权限.<br>另外如果被拒绝过,还可以选择向用户展示我们为什么需要权限,再次请求等等~  </p><p>这边讲得有些多了,其实看6.0的官网资料即可.</p><h3 id="check-the-platform"><a href="#check-the-platform" class="headerlink" title="check the platform"></a>check the platform</h3><p><img src="http://ww1.sinaimg.cn/large/98900c07gw1ez0a6af8etj20hv09pt9j.jpg" alt="check"></p><h3 id="check-the-permission"><a href="#check-the-permission" class="headerlink" title="check the permission"></a>check the permission</h3><p><img src="http://ww4.sinaimg.cn/large/98900c07gw1ez0a85fuuzj20lj09bjt9.jpg" alt=""></p><h2 id="ADP018-Navigation-Drawers"><a href="#ADP018-Navigation-Drawers" class="headerlink" title="ADP018 Navigation Drawers"></a><a href="https://www.youtube.com/watch?v=ASO5gWb9Mhg&amp;list=TL4Nfdz2LFocQyOTExMjAxNQ" target="_blank" rel="noopener">ADP018 Navigation Drawers</a></h2><h3 id="Open-and-Close-Events"><a href="#Open-and-Close-Events" class="headerlink" title="Open and Close Events"></a>Open and Close Events</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">onDrawerClose</span>(View view)&#123;</span><br><span class="line"><span class="selector-tag">super</span><span class="selector-class">.onDrawerClosed</span>(view);</span><br><span class="line"><span class="selector-tag">getActionBar</span><span class="selector-class">.setTitle</span>(mTitle);</span><br><span class="line"><span class="selector-tag">invalidateOptionsMenu</span>();<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">onDrawerOpened</span>(View view)&#123;</span><br><span class="line"><span class="selector-tag">super</span><span class="selector-class">.onDrawerOpened</span>(view);</span><br><span class="line"><span class="selector-tag">getActionBar</span>()<span class="selector-class">.setTitle</span>(mDrawerTitle);</span><br><span class="line"><span class="selector-tag">invalidateOptionsMenu</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="http://www.youku.com/playlist_show/id_26099421.html" target="_blank" rel="noopener">优酷</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mou备忘</title>
      <link href="/blog/ff4f3bca.html"/>
      <url>/blog/ff4f3bca.html</url>
      
        <content type="html"><![CDATA[<h1 id="Mou"><a href="#Mou" class="headerlink" title="Mou"></a>Mou</h1><p>Mou作为一款免费的md编辑器优秀得让人难以置信,用它来写笔记写文章速度感人~<br>可以说它已经融入我的生活.  </p><p>在此记录一下Mou的md语法,作为备忘<br><img src="http://25.io/mou/Mou_128.png" alt="Mou icon"></p><a id="more"></a><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><strong>Mou</strong>, the missing Markdown editor for <em>web developers</em>.</p><h3 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h3><h4 id="Strong-and-Emphasize"><a href="#Strong-and-Emphasize" class="headerlink" title="Strong and Emphasize"></a>Strong and Emphasize</h4><p><strong>strong</strong> or <strong>strong</strong> ( Cmd + B )</p><p><em>emphasize</em> or <em>emphasize</em> ( Cmd + I )</p><p><strong>Sometimes I want a lot of text to be bold.<br>Like, seriously, a <em>LOT</em> of text</strong></p><h4 id="Blockquotes"><a href="#Blockquotes" class="headerlink" title="Blockquotes"></a>Blockquotes</h4><blockquote><p>Right angle brackets &gt; are used for block quotes.</p></blockquote><h4 id="Links-and-Email"><a href="#Links-and-Email" class="headerlink" title="Links and Email"></a>Links and Email</h4><p>An email <a href="mailto:&#x65;&#x78;&#97;&#x6d;&#x70;&#x6c;&#101;&#x40;&#x65;&#x78;&#97;&#109;&#x70;&#108;&#x65;&#46;&#x63;&#x6f;&#109;" target="_blank" rel="noopener">&#x65;&#x78;&#97;&#x6d;&#x70;&#x6c;&#101;&#x40;&#x65;&#x78;&#97;&#109;&#x70;&#108;&#x65;&#46;&#x63;&#x6f;&#109;</a> link.</p><p>Simple inline link <a href="http://chenluois.com" target="_blank" rel="noopener">http://chenluois.com</a>, another inline link <a href="http://25.io/smaller/" target="_blank" rel="noopener">Smaller</a>, one more inline link with title <a href="http://resizesafari.com" title="a Safari extension" target="_blank" rel="noopener">Resize</a>.</p><p>A <a href="http://25.io/mou/" title="Markdown editor on Mac OS X" target="_blank" rel="noopener">reference style</a> link. Input id, then anywhere in the doc, define the link with corresponding id:</p><p>Titles ( or called tool tips ) in the links are optional.</p><h4 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h4><p>An inline image <img src="http://25.io/smaller/favicon.ico" alt="Smaller icon" title="Title here">, title is optional.</p><p>A <img src="http://resizesafari.com/favicon.ico" alt="Resize icon" title="Title"> reference style image.</p><h4 id="Inline-code-and-Block-code"><a href="#Inline-code-and-Block-code" class="headerlink" title="Inline code and Block code"></a>Inline code and Block code</h4><p>Inline code are surround by <code>backtick</code> key. To create a block code:</p><pre><code>Indent each line by at least 1 tab, or 4 spaces.var Mou = exactlyTheAppIwant;</code></pre><h4 id="Ordered-Lists"><a href="#Ordered-Lists" class="headerlink" title="Ordered Lists"></a>Ordered Lists</h4><p>Ordered lists are created using “1.” + Space:</p><ol><li>Ordered list item</li><li>Ordered list item</li><li>Ordered list item</li></ol><h4 id="Unordered-Lists"><a href="#Unordered-Lists" class="headerlink" title="Unordered Lists"></a>Unordered Lists</h4><p>Unordered list are created using “*” + Space:</p><ul><li>Unordered list item</li><li>Unordered list item</li><li>Unordered list item</li></ul><p>Or using “-“ + Space:</p><ul><li>Unordered list item</li><li>Unordered list item</li><li>Unordered list item</li></ul><h4 id="Hard-Linebreak"><a href="#Hard-Linebreak" class="headerlink" title="Hard Linebreak"></a>Hard Linebreak</h4><p>End a line with two or more spaces will create a hard linebreak, called <code>&lt;br /&gt;</code> in HTML. ( Control + Return )<br>Above line ended with 2 spaces.</p><h4 id="Horizontal-Rules"><a href="#Horizontal-Rules" class="headerlink" title="Horizontal Rules"></a>Horizontal Rules</h4><p>Three or more asterisks or dashes:</p><hr><hr><hr><h4 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h4><p>Setext-style:</p><h1 id="This-is-H1"><a href="#This-is-H1" class="headerlink" title="This is H1"></a>This is H1</h1><h2 id="This-is-H2"><a href="#This-is-H2" class="headerlink" title="This is H2"></a>This is H2</h2><p>atx-style:</p><h1 id="This-is-H1-1"><a href="#This-is-H1-1" class="headerlink" title="This is H1"></a>This is H1</h1><h2 id="This-is-H2-1"><a href="#This-is-H2-1" class="headerlink" title="This is H2"></a>This is H2</h2><h3 id="This-is-H3"><a href="#This-is-H3" class="headerlink" title="This is H3"></a>This is H3</h3><h4 id="This-is-H4"><a href="#This-is-H4" class="headerlink" title="This is H4"></a>This is H4</h4><h5 id="This-is-H5"><a href="#This-is-H5" class="headerlink" title="This is H5"></a>This is H5</h5><h6 id="This-is-H6"><a href="#This-is-H6" class="headerlink" title="This is H6"></a>This is H6</h6><h3 id="Extra-Syntax"><a href="#Extra-Syntax" class="headerlink" title="Extra Syntax"></a>Extra Syntax</h3><h4 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h4><p>Footnotes work mostly like reference-style links. A footnote is made of two things: a marker in the text that will become a superscript number; a footnote definition that will be placed in a list of footnotes at the end of the document. A footnote looks like this:</p><p>That’s some text with a footnote.[^1]</p><p>[^1]: And that’s the footnote.</p><h4 id="Strikethrough"><a href="#Strikethrough" class="headerlink" title="Strikethrough"></a>Strikethrough</h4><p>Wrap with 2 tilde characters:</p><p><del>Strikethrough</del></p><h4 id="Fenced-Code-Blocks"><a href="#Fenced-Code-Blocks" class="headerlink" title="Fenced Code Blocks"></a>Fenced Code Blocks</h4><p>Start with a line containing 3 or more backticks, and ends with the first line with the same number of backticks:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Fenced</span> <span class="meta">code</span> <span class="keyword">blocks </span>are like Stardard <span class="keyword">Markdown’s </span>regular <span class="meta">code</span></span><br><span class="line"><span class="keyword">blocks, </span>except that they’re not indented <span class="keyword">and </span>instead rely on</span><br><span class="line">a start <span class="keyword">and </span><span class="meta">end</span> fence lines to delimit the <span class="meta">code</span> <span class="keyword">block.</span></span><br></pre></td></tr></table></figure><h4 id="Tables"><a href="#Tables" class="headerlink" title="Tables"></a>Tables</h4><p>A simple table looks like this:</p><table><thead><tr><th>First Header</th><th>Second Header</th><th>Third Header</th></tr></thead><tbody><tr><td>Content Cell</td><td>Content Cell</td><td>Content Cell</td></tr><tr><td>Content Cell</td><td>Content Cell</td><td>Content Cell</td></tr></tbody></table><p>If you wish, you can add a leading and tailing pipe to each line of the table:</p><table><thead><tr><th>First Header</th><th>Second Header</th><th>Third Header</th></tr></thead><tbody><tr><td>Content Cell</td><td>Content Cell</td><td>Content Cell</td></tr><tr><td>Content Cell</td><td>Content Cell</td><td>Content Cell</td></tr></tbody></table><p>Specify alignment for each column by adding colons to separator lines:</p><table><thead><tr><th style="text-align:left">First Header</th><th style="text-align:center">Second Header</th><th style="text-align:right">Third Header</th></tr></thead><tbody><tr><td style="text-align:left">Left</td><td style="text-align:center">Center</td><td style="text-align:right">Right</td></tr><tr><td style="text-align:left">Left</td><td style="text-align:center">Center</td><td style="text-align:right">Right</td></tr></tbody></table><p>#</p><h3 id="Shortcuts"><a href="#Shortcuts" class="headerlink" title="Shortcuts"></a>Shortcuts</h3><h4 id="View"><a href="#View" class="headerlink" title="View"></a>View</h4><ul><li>Toggle live preview: Shift + Cmd + I</li><li>Toggle Words Counter: Shift + Cmd + W</li><li>Toggle Transparent: Shift + Cmd + T</li><li>Toggle Floating: Shift + Cmd + F</li><li>Left/Right = 1/1: Cmd + 0</li><li>Left/Right = 3/1: Cmd + +</li><li>Left/Right = 1/3: Cmd + -</li><li>Toggle Writing orientation: Cmd + L</li><li>Toggle fullscreen: Control + Cmd + F</li></ul><h4 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h4><ul><li>Copy HTML: Option + Cmd + C</li><li>Strong: Select text, Cmd + B</li><li>Emphasize: Select text, Cmd + I</li><li>Inline Code: Select text, Cmd + K</li><li>Strikethrough: Select text, Cmd + U</li><li>Link: Select text, Control + Shift + L</li><li>Image: Select text, Control + Shift + I</li><li>Select Word: Control + Option + W</li><li>Select Line: Shift + Cmd + L</li><li>Select All: Cmd + A</li><li>Deselect All: Cmd + D</li><li>Convert to Uppercase: Select text, Control + U</li><li>Convert to Lowercase: Select text, Control + Shift + U</li><li>Convert to Titlecase: Select text, Control + Option + U</li><li>Convert to List: Select lines, Control + L</li><li>Convert to Blockquote: Select lines, Control + Q</li><li>Convert to H1: Cmd + 1</li><li>Convert to H2: Cmd + 2</li><li>Convert to H3: Cmd + 3</li><li>Convert to H4: Cmd + 4</li><li>Convert to H5: Cmd + 5</li><li>Convert to H6: Cmd + 6</li><li>Convert Spaces to Tabs: Control + [</li><li>Convert Tabs to Spaces: Control + ]</li><li>Insert Current Date: Control + Shift + 1</li><li>Insert Current Time: Control + Shift + 2</li><li>Insert entity &lt;: Control + Shift + ,</li><li>Insert entity &gt;: Control + Shift + .</li><li>Insert entity &amp;: Control + Shift + 7</li><li>Insert entity Space: Control + Shift + Space</li><li>Insert Scriptogr.am Header: Control + Shift + G</li><li>Shift Line Left: Select lines, Cmd + [</li><li>Shift Line Right: Select lines, Cmd + ]</li><li>New Line: Cmd + Return</li><li>Comment: Cmd + /</li><li>Hard Linebreak: Control + Return</li></ul><h4 id="Editors"><a href="#Editors" class="headerlink" title="Editors"></a>Editors</h4><ul><li>Auto complete current word: Esc</li><li>Find: Cmd + F</li><li>Close find bar: Esc</li></ul><h4 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h4><ul><li>Post on Scriptogr.am: Control + Shift + S</li><li>Post on Tumblr: Control + Shift + T</li></ul><h4 id="Export"><a href="#Export" class="headerlink" title="Export"></a>Export</h4><ul><li>Export HTML: Option + Cmd + E</li><li>Export PDF:  Option + Cmd + P</li></ul><h3 id="And-more"><a href="#And-more" class="headerlink" title="And more?"></a>And more?</h3><p>Don’t forget to check Preferences, lots of useful options are there.</p><p>Follow <a href="https://twitter.com/mou" target="_blank" rel="noopener">@Mou</a> on Twitter for the latest news.</p><p>For feedback, use the menu <code>Help</code> - <code>Send Feedback</code></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OkHttp和Retrofit2学习笔记</title>
      <link href="/blog/dd3030c2.html"/>
      <url>/blog/dd3030c2.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><a id="more"></a><h2 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a><a href="http://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp</a></h2><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ol><li><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">github</a></li><li><a href="https://github.com/square/okhttp/wiki/Calls" target="_blank" rel="noopener">wiki</a></li><li><a href="http://blog.csdn.net/lmj623565791/article/details/47911083" target="_blank" rel="noopener">OkHttp-完全解析</a></li><li><a href="http://blog.csdn.net/lmj623565791/article/details/48129405" target="_blank" rel="noopener">OkHttp-Https</a></li></ol><h2 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a><a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">Retrofit</a></h2><h3 id="添加日志"><a href="#添加日志" class="headerlink" title="添加日志"></a>添加日志</h3><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpLoggingInterceptor</span> logging = <span class="function"><span class="keyword">new</span> <span class="title">HttpLoggingInterceptor</span>();  </span></span><br><span class="line"><span class="function"><span class="comment">// set your desired log level</span></span></span><br><span class="line"><span class="function"><span class="title">logging</span>.<span class="title">setLevel</span>(<span class="type">Level</span>.<span class="type">BODY</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">OkHttpClient</span> <span class="title">httpClient</span> = <span class="title">new</span> <span class="title">OkHttpClient</span>();  </span></span><br><span class="line"><span class="function"><span class="comment">// add your other interceptors …</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// add logging as last interceptor</span></span></span><br><span class="line"><span class="function"><span class="title">httpClient</span>.<span class="title">interceptors</span>().<span class="title">add</span>(logging);  <span class="comment">// &lt;-- this is the important line!</span></span></span><br></pre></td></tr></table></figure><p>参考自<a href="https://futurestud.io/blog/retrofit-2-log-requests-and-responses" target="_blank" rel="noopener">这里</a></p><h2 id="资料-1"><a href="#资料-1" class="headerlink" title="资料"></a>资料</h2><p><a href="https://realm.io/cn/news/droidcon-jake-wharton-simple-http-retrofit-2/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">用 Retrofit 2 简化 HTTP 请求</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0915/3460.html" target="_blank" rel="noopener">Retrofit 2.0：有史以来最大的改进</a><br><a href="https://futurestud.io/blog/retrofit-2-upgrade-guide-from-1-9/" target="_blank" rel="noopener">Retrofit 2 — Upgrade Guide from 1.9</a><br><a href="https://futurestud.io/blog/retrofit-2-log-requests-and-responses" target="_blank" rel="noopener">Retrofit 2 — Log Requests and Responses</a><br><a href="https://futurestud.io/books/retrofit" target="_blank" rel="noopener">Love-working-with-APIS-on-Android</a><br><a href="http://www.jianshu.com/p/c1a3a881a144" target="_blank" rel="noopener">Retrofit2 源码解析</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Retrofit </tag>
            
            <tag> OkHttp </tag>
            
            <tag> 开源项目使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android给apk签名那点事</title>
      <link href="/blog/e62fcbff.html"/>
      <url>/blog/e62fcbff.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  前几天老大的6p一打开应用就奔溃,于是与让我给应用适配6.0.后来最后发布内测版本后,发现又是打开立即奔溃,在确定我代码push之后,找了一下原因,最终发现是梆梆加固搞的鬼.<br>  然后老大又让我去尝试其他加固方案,又因为加固后又需要重新加固,所以就有了这篇笔记.<br><a id="more"></a></p><h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><h3 id="签名是为了什么"><a href="#签名是为了什么" class="headerlink" title="签名是为了什么"></a>签名是为了什么</h3><p>简单来说,签名可以保证我们的应用可以正常升级,并且不被别人覆盖.<br>算是一个标识.</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li>keytool 是个密钥和证书管理工具,可以用来生成证书.  </li><li>jarsigner 工具利用密钥仓库中的信息来产生或校验 Java 存档 (JAR) 文件的数字签名  </li></ul><p>使用keytool生成证书:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -keystore test.keystore  -alias test -keyalg RSA -validity 10000</span><br></pre></td></tr></table></figure></p><p>参数解释:    </p><ol><li>-genkey     产生证书文件    </li><li>-keystore   指定密钥库的.keystore文件中   </li><li>-keyalg     指定密钥的算法,这里指定为RSA(非对称密钥算法)  </li><li>-validity   为证书有效天数，这里我们写的是10000天   </li><li>-alias      产生别名   </li></ol><p><img src="http://ww1.sinaimg.cn/large/98900c07gw1ey7j7gp4sfj20l80ayjth.jpg" alt="效果图"></p><p><strong><em>网上搜索到的生成证书的方法都尼玛是错的,都是误导人的,具体请看后续!!!</em></strong></p><p>另外keytool还能查看信息:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">test  </span>keytool -list -keystore test.keystore</span><br></pre></td></tr></table></figure><p>结果:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="selector-tag">test</span>  <span class="selector-tag">keytool</span> <span class="selector-tag">-list</span> <span class="selector-tag">-keystore</span> <span class="selector-tag">test</span><span class="selector-class">.keystore</span></span><br><span class="line">输入密钥库口令:</span><br><span class="line"></span><br><span class="line">密钥库类型: <span class="selector-tag">JKS</span></span><br><span class="line">密钥库提供方: <span class="selector-tag">SUN</span></span><br><span class="line"></span><br><span class="line">您的密钥库包含 1 个条目</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">test</span><span class="selector-class">.keystore</span>, 2015<span class="selector-tag">-11-20</span>, <span class="selector-tag">PrivateKeyEntry</span>,</span><br><span class="line">证书指纹 (<span class="selector-tag">SHA1</span>): 21<span class="selector-pseudo">:94</span><span class="selector-pseudo">:9F</span><span class="selector-pseudo">:48</span><span class="selector-pseudo">:7D</span><span class="selector-pseudo">:38</span><span class="selector-pseudo">:EE</span><span class="selector-pseudo">:5A</span><span class="selector-pseudo">:63</span><span class="selector-pseudo">:16</span><span class="selector-pseudo">:8F</span><span class="selector-pseudo">:46</span><span class="selector-pseudo">:1B</span><span class="selector-pseudo">:6E</span><span class="selector-pseudo">:73</span><span class="selector-pseudo">:89</span><span class="selector-pseudo">:53</span><span class="selector-pseudo">:7D</span><span class="selector-pseudo">:7B</span><span class="selector-pseudo">:5C</span></span><br></pre></td></tr></table></figure></p><h3 id="签名-1"><a href="#签名-1" class="headerlink" title="签名"></a>签名</h3><p>可以使用jarsigner 来签名,例子如下:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jarsigner -verbose -keystore test<span class="selector-class">.keystore</span> -signedjar -signed<span class="selector-class">.apk</span> unsigned<span class="selector-class">.apk</span> <span class="string">'test.keystore'</span></span><br></pre></td></tr></table></figure><p>参数说明:</p><ol><li>-verbose：指定生成详细输出  </li><li>-keystore：指定数字证书存储路径  </li><li>-signedjar：该选项的三个参数为  签名后的apk包  未签名的apk包  数字证书别名<strong>(注意顺序)</strong></li></ol><p><img src="http://ww2.sinaimg.cn/large/98900c07gw1ey7kh4jhlej20la04c404.jpg" alt="效果"><br>(原来用的t.apk,发现不利于理解,于是后面改名了)</p><p>遇到坑了,找不到xxx证书链什么鬼!<br>后来搜索了很久之后才看到了一句<em>要跟别名一样</em>,我就在想我原来用的代码是这样的:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -keystore test<span class="selector-class">.keystore</span>  -alias test<span class="selector-class">.keystore</span> -keyalg RSA -validity <span class="number">10000</span></span><br></pre></td></tr></table></figure></p><p>诶?好像没问题啊,test.keystore的别名test.keystore,是一样的啊,后来想想不对啊,test.keystore的后缀不应该加入上去吧,于是去掉keystore后再次重新生成一遍<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -keystore test.keystore  -<span class="built_in">alias</span> <span class="built_in">test</span> -keyalg RSA -validity 10000</span><br></pre></td></tr></table></figure></p><p>然后再次执行签名:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jarsigner -verbose -keystore test<span class="selector-class">.keystore</span> -signedjar signed<span class="selector-class">.apk</span> t<span class="selector-class">.apk</span> <span class="string">'test'</span></span><br></pre></td></tr></table></figure></p><p>成功了!~So happy!!~~<br><img src="http://ww4.sinaimg.cn/large/98900c07gw1ey7kwykdo9j2046042gls.jpg" alt="最终效果"></p><p>不过其实后面还顺带了一个警告:<br><code>未提供 -tsa 或 -tsacert, 此 jar 没有时间戳。如果没有时间戳, 则在签名者证书的到期日期 (2043-04-07) 或以后的任何撤销日期之后, 用户可能无法验证此 jar。</code><br>想来似乎没什么,就没管了.  </p><p>吐个槽:<strong>国内的有些文章真的很坑人,几篇错误的文章尼玛到处复制黏贴,到处都是,真是给跪了</strong></p><h2 id="debug-keystore的故事"><a href="#debug-keystore的故事" class="headerlink" title="debug.keystore的故事"></a>debug.keystore的故事</h2><p>说点小插曲,小知识:  </p><ol><li>AndroidStudio会自动生成一个默认的<code>debug.keystore</code>,它存放在<code>~/.android/</code>目录下.</li><li>如果一不小心删了(其实我是rm了它),只要重新run一遍debug版应(不指定signingConfig),AS会再次自动创建</li><li>它默认密码为 android</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>一个加固导致崩溃引发的血案~<br>最终让我学会了如何用cmd来签名APK,来装逼,哦哈哈~~~<br>新技能get!~</p><h2 id="后续–如何查看APK的签名呢"><a href="#后续–如何查看APK的签名呢" class="headerlink" title="后续–如何查看APK的签名呢?"></a>后续–如何查看APK的签名呢?</h2><blockquote><p>update 2016-01-13</p></blockquote><p> 将APK改成zip文件(其实APK就是带有签名的zip文件),然后解压,签名放在<code>META-INF</code>目录下名为<code>CERT.RSA</code>的文件里,通过命令行可以获取:</p> <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -printcert -<span class="built_in">file</span> CERT.RSA</span><br></pre></td></tr></table></figure><p>可以获得到信息如下:</p><p><img src="http://ww2.sinaimg.cn/large/98900c07gw1ezy269lh6xj20k705c3zu.jpg" alt="CERT.RSA-效果图"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> APK加固 </tag>
            
            <tag> 签名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Activity的生命周期和启动模式</title>
      <link href="/blog/6271b127.html"/>
      <url>/blog/6271b127.html</url>
      
        <content type="html"><![CDATA[<h2 id="Android开发艺术探索笔记"><a href="#Android开发艺术探索笔记" class="headerlink" title="Android开发艺术探索笔记"></a>Android开发艺术探索笔记</h2><p><a href="http://blog.csdn.net/singwhatiwanna/article/details/48439621#reply" target="_blank" rel="noopener">任玉刚</a>所写,<a href="http://blog.csdn.net/singwhatiwanna/article/details/48439621#reply" target="_blank" rel="noopener">勘误</a></p><p>记录一些笔记<br><a id="more"></a></p><h2 id="第1章Activity的生命周期和启动模式"><a href="#第1章Activity的生命周期和启动模式" class="headerlink" title="第1章Activity的生命周期和启动模式"></a>第1章Activity的生命周期和启动模式</h2><h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><h3 id="标准模式"><a href="#标准模式" class="headerlink" title="标准模式"></a>标准模式</h3><p>每次启动都会重新创建一个新的Activity</p><h3 id="SingleTop"><a href="#SingleTop" class="headerlink" title="SingleTop"></a>SingleTop</h3><p>栈顶复用模式,如果当前任务栈的栈顶有该类型的Activity,那么不重新创建,该Activity的onNewIntent被调用.</p><h3 id="SingleTask"><a href="#SingleTask" class="headerlink" title="SingleTask"></a>SingleTask</h3><p>SingleTask是个特殊的SingleTop,它是栈复用,即栈内有该Activity就不会重新创建,同样的回调onNewIntent,并且它还有一个特性,那便是将在它顶部的所有Activity都pop掉.例如在同一个栈内ABCD,在D启动B–&gt;AB(CD被pop掉了)</p><p>注意:<strong>启动页面的launchMode不能设置为singleTask,不然打开应用后,按Home键回到桌面,再从桌面点击图标进入,应用会重新打开.</strong>  </p><h3 id="SingleInstance"><a href="#SingleInstance" class="headerlink" title="SingleInstance"></a>SingleInstance</h3><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android开发艺术探索 </tag>
            
            <tag> 读书笔记 </tag>
            
            <tag> todo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我也开始面试人了</title>
      <link href="/blog/1c188ce5.html"/>
      <url>/blog/1c188ce5.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天老大让我去面试,呵呵,入行1年多了,以前只有被别人面试的份,第一次面试,还是小紧张的.</p><p>第一个,两年的经验.<br>一看两年的经验,比我多,怎么办?<br>我尽量地往深入的地方问,但是结果答得非常模糊,快到了问什么什么不知道的境界.<br>然后,开始问他的工作经历,几个问题下来,感觉他平时工作的态度就是遇到问题就百度,解决了就万幸,也不深入去了解.<br>而且对新的知识一点都不了解,AndroidDesign,MaterialDesign什么都不了解.</p><p>反正,给我的感觉是:两年经验,就这水平?</p><a id="more"></a><p>第二个,一年,跟我同一届.<br>原来在河南工作,技术不太行,感觉那边的技术比较落后,他说希望有大牛带,感觉看到我以前的样子了.<br>人不错,但是基础太差,如果招进来,我会很累吧..</p><p>第三个,1年半,原来是在北京,薪资10K,期望10-11K<br>这个是我面第二个的时候老大面的,我半途进去旁听的,后来老大让我问一些技术类问题.<br>看了简历,写了很多熟悉,比如什么面向对象思想啦,handler啦什么的<br>想来基础应该是有的,<br>但是当我问得稍微深入点的时候就不行了,要么不知道要么说不清楚,感觉还是不太够..</p><h2 id="面试收获"><a href="#面试收获" class="headerlink" title="面试收获"></a>面试收获</h2><p>暗爽了一把.<br>但是老大说面试时要从他们那获取信息,学习自己不会的,而不是一味的问一些东西.</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>厦门旅游计划</title>
      <link href="/blog/10c2aaa8.html"/>
      <url>/blog/10c2aaa8.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>初步计划:</p><p>2015.11.4-11.8日</p><a id="more"></a><h2 id="11-4号-11-5号白天"><a href="#11-4号-11-5号白天" class="headerlink" title="11.4号+11.5号白天"></a>11.4号+11.5号白天</h2><h3 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h3><ul><li>古荡-&gt;萧山机场</li></ul><p>打的-&gt;<strong>武林门民航售票处(公交站)</strong> 15分一班</p><p>厦门高崎飞机场-&gt;码头  </p><p>最优选择: <strong>t4候机楼站上车(空港快线)–&gt;邮轮中心码头</strong>  </p><p>其他全部:<br><img src="http://ww2.sinaimg.cn/large/98900c07gw1exmwsx830wj20dp09ogmx.jpg" alt="飞机"></p><p>码头-&gt;鼓浪屿  </p><p>船票 35元/人,<strong>往返都要检票!!</strong></p><h3 id="景点"><a href="#景点" class="headerlink" title="景点"></a>景点</h3><p>鼓浪屿,<strong>日光岩</strong>、菽庄花园、皓月园、郑成功纪念馆,西式别墅建筑群</p><p>PS: <strong>可先买一份地图,需要买景点联票 100元/人</strong></p><p>联票包括:  </p><ol><li>日光岩  </li><li>菽庄花园(含钢琴博物馆)  </li><li>皓月园  </li><li>风琴博物馆  </li><li>国际刻字艺术馆  </li></ol><p><strong>PS:免费音乐 晚上7点30,鼓浪屿音乐厅免费音乐</strong></p><h3 id="吃"><a href="#吃" class="headerlink" title="吃"></a>吃</h3><h4 id="特产"><a href="#特产" class="headerlink" title="特产"></a>特产</h4><ol><li>馅饼   </li><li>猪肉铺  </li></ol><h2 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h2><p><img src="http://ww3.sinaimg.cn/large/98900c07gw1exmx8btne7j20cm0jagov.jpg" alt="推荐路线"></p><p>攻略推荐的店：鼓浪屿海怪先生（龙头路266号）、林记鱼丸（泉州路54号）、黄胜记黄金香肉松店、龙头海蛎煎</p><p>十大别墅：八卦楼（俗称小白宫：鼓新路43号）、皇家花园（曾经的中国第一别墅：晃岩路25号）、海天堂构（厦门新天地：福建路38号）、<br>黄荣远堂（一场赌博便易了主：福建路32号）、荣谷别墅（鼓浪屿别墅之王：旗山路5号）、杨家园（欧式建筑群：安海路4号）、林氏府<br>（遭实验烧毁后重建：鹿礁路13号到15号）、金瓜楼（子孙满堂，后人遍布二十多地：泉州路99号）、番婆楼（尽人子之孝的典范：安海路36号）、<br>汇丰银行公馆（行长住在悬崖之上：鼓新路57号）</p><p><img src="http://ww3.sinaimg.cn/large/98900c07gw1exmx2x2vzgj207j05bglt.jpg" alt="实用信息"></p><p><strong>5号,凌晨看日出</strong></p><p>住宿:  </p><p><strong>记得到店有返现,66元!</strong></p><p>联系方式:</p><h2 id="11-5-下午-夜晚"><a href="#11-5-下午-夜晚" class="headerlink" title="11.5 下午-夜晚"></a>11.5 下午-夜晚</h2><p>景点: 中山路,中华城步行街    </p><p>攻略推荐的店：佳味再添小吃店、月华沙茶面（镇邦路78号）、大中路里脊肉串（大中路，南中广场对面）、大佳香姜母鸭  </p><p>住宿: <a href="http://touch.qunar.com/h5/group/GroupDetail?id=3649776" target="_blank" rel="noopener">厦门家和快捷酒店</a><br>地址: 思明区厦禾路244号<br>联系方式: 0592-2022177  </p><h2 id="11-6"><a href="#11-6" class="headerlink" title="11.6"></a>11.6</h2><p>景点: 厦大,南普陀寺,炮台</p><p>推荐:厦大建筑群、芙蓉隧道、厦大高尔夫球场、厦大情人谷、厦大芙蓉湖畔咖啡厅  </p><p>地点：厦门南普陀<br>用时：2小时</p><p>地点：顶澳仔猫街（厦门大学西门）<br>用时：2小时</p><p>地点：沙坡尾避风坞<br>用时：1小时  </p><p>攻略推荐的店：多吉甜甜圈（厦门市思明区沙坡大学路113号）、晴天见（特色冰淇淋）、喂道餐车（西式糕点）</p><h2 id="11-7号"><a href="#11-7号" class="headerlink" title="11.7号"></a>11.7号</h2><p>景点: 环岛南路,</p><p>住宿:曾厝垵 <a href="网址: http://gongyu.qunar.com/roomType/t/info?hotelNo=5833453&amp;roomTypeNo=xiamen5128305910">苏林故事客栈豪华大床房</a>  </p><p>地址:厦门思明区曾厝垵56号<br>房东联系方式: 18150107212  </p><p>公交,到曾厝垵站下,4 5 分钟就可以到</p><p>交通:<br><strong>鼓浪屿/中山路/轮渡：乘坐29路→曾厝垵站下；</strong>  </p><p><strong>厦大/南普陀寺：厦大西村站→29/47/857路→曾厝垵站下</strong></p><h2 id="费用"><a href="#费用" class="headerlink" title="费用"></a>费用</h2><ul><li>交通: 来回机票 1506</li><li><p>住宿: 318+97+236 = 651;</p></li><li><p>其他:<br>渡船 70?</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 人生路上 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fragment学习笔记备忘</title>
      <link href="/blog/f6a45193.html"/>
      <url>/blog/f6a45193.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>// todo<br><a id="more"></a></p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><a href="http://www.codeceo.com/article/android-fragment-circle.html" target="_blank" rel="noopener">http://www.codeceo.com/article/android-fragment-circle.html</a></p><p>##</p><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>场景前提:Fragment里有个ViewPager,vp里有三个Fragment的情况.<br>我需要的情况是,第一次加载的时候就第一页去请求数据,而其他两页不去请求直到滑动到该界面.</p><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ol><li><code>public void setUserVisibleHint(boolean isVisibleToUser)</code> isVisibleToUser代表fragment是否可见.</li></ol><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>动手,先研究一下它在什么时候调用的</p><h4 id="第一次加载"><a href="#第一次加载" class="headerlink" title="第一次加载"></a>第一次加载</h4><p>即app刚启动,刚到这个界面<br>PS:LiveFragment在第一个位置.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">D/ChildFragment: <span class="function">LiveFragment  <span class="title">setUserVisibleHint</span><span class="params">()</span> called with: isVisibleToUser </span>= [<span class="keyword">false</span>]</span><br><span class="line">D/ChildFragment: <span class="function">FollowFragment  <span class="title">setUserVisibleHint</span><span class="params">()</span> called with: isVisibleToUser </span>= [<span class="keyword">false</span>]</span><br><span class="line">D/ChildFragment: <span class="function">FansFragment  <span class="title">setUserVisibleHint</span><span class="params">()</span> called with: isVisibleToUser </span>= [<span class="keyword">false</span>]</span><br><span class="line">D/ChildFragment: LiveFragment onAttach:</span><br><span class="line">D/ChildFragment: <span class="function">LiveFragment  <span class="title">setUserVisibleHint</span><span class="params">()</span> called with: isVisibleToUser </span>= [<span class="keyword">true</span>]</span><br><span class="line">D/ChildFragment: LiveFragment onCreateView:</span><br><span class="line">D/ChildFragment: LiveFragment onResume:</span><br><span class="line">D/ChildFragment: FollowFragment onAttach:</span><br><span class="line">D/ChildFragment: FollowFragment onCreateView:</span><br><span class="line">D/ChildFragment: FansFragment onAttach:</span><br><span class="line">D/ChildFragment: FansFragment onCreateView:</span><br><span class="line">D/ChildFragment: FollowFragment onResume:</span><br><span class="line">D/ChildFragment: FansFragment onResume:</span><br></pre></td></tr></table></figure></p><p>可以看到,方法的调用顺序:<br>setUserVisibleHint-&gt;onAttach-&gt;(setUserVisibleHint如果可见)/onCreateView(不可见)-&gt;onResume</p><p>需要注意,第一次调用的时候连onCreateView都没执行,即view都没有初始化.</p><p>另外,每个Fragment在一开始,都先调用了setUserVisibleHint()并且传入了false,即还是不可见状态.</p><h4 id="第二次and-more"><a href="#第二次and-more" class="headerlink" title="第二次and more"></a>第二次and more</h4><p>而后,滑动viewpager或者点击tab则会导致<code>相关</code>的fragment调用<code>setUserVisibleHint</code>(这里的相关指的是,即将不可见的fragment与即将可见的fragment,也即可见性会发生变化的fragment)  </p><p>通过日志也可以看到true,false,成对出现,每次也只有两个相关fragment出现在日志里:  </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">D/<span class="string">ChildFragment:</span> FansFragment  setUserVisibleHint() called <span class="string">with:</span> isVisibleToUser = [<span class="literal">false</span>]</span><br><span class="line">D/<span class="string">ChildFragment:</span> FollowFragment  setUserVisibleHint() called <span class="string">with:</span> isVisibleToUser = [<span class="literal">true</span>]</span><br><span class="line">D/<span class="string">ChildFragment:</span> FollowFragment  setUserVisibleHint() called <span class="string">with:</span> isVisibleToUser = [<span class="literal">false</span>]</span><br><span class="line">D/<span class="string">ChildFragment:</span> LiveFragment  setUserVisibleHint() called <span class="string">with:</span> isVisibleToUser = [<span class="literal">true</span>]</span><br><span class="line">D/<span class="string">ChildFragment:</span> LiveFragment <span class="string">onResume:</span></span><br><span class="line">D/<span class="string">ChildFragment:</span> FollowFragment <span class="string">onResume:</span></span><br><span class="line">D/<span class="string">ChildFragment:</span> FansFragment <span class="string">onResume:</span></span><br><span class="line">D/<span class="string">ChildFragment:</span> LiveFragment  setUserVisibleHint() called <span class="string">with:</span> isVisibleToUser = [<span class="literal">false</span>]</span><br><span class="line">D/<span class="string">ChildFragment:</span> FansFragment  setUserVisibleHint() called <span class="string">with:</span> isVisibleToUser = [<span class="literal">true</span>]</span><br><span class="line">D/<span class="string">ChildFragment:</span> FansFragment  setUserVisibleHint() called <span class="string">with:</span> isVisibleToUser = [<span class="literal">false</span>]</span><br><span class="line">D/<span class="string">ChildFragment:</span> FollowFragment  setUserVisibleHint() called <span class="string">with:</span> isVisibleToUser = [<span class="literal">true</span>]</span><br></pre></td></tr></table></figure><h4 id="封装使用"><a href="#封装使用" class="headerlink" title="封装使用"></a>封装使用</h4><p>大致的流程在这里,可以根据自己调用Fragment的生命周期需求可以适当修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否可见</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> isVisiable;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否已经调用onCreatView</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> isViewCreated;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先于onCreateView</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isVisibleToUser</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserVisibleHint</span><span class="params">(<span class="keyword">boolean</span> isVisibleToUser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setUserVisibleHint(isVisibleToUser);</span><br><span class="line">        isVisiable = isVisibleToUser;</span><br><span class="line">        <span class="comment">//可以根据需要修改</span></span><br><span class="line">        <span class="keyword">if</span> (isVisiable) &#123;</span><br><span class="line">            onVisible();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            onInvisible();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(View view, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line">        isViewCreated = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 懒加载 在可见的状态下会被调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lazyload</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isViewCreated &amp;&amp; isVisiable) &#123;</span><br><span class="line">            lazyload();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onInvisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用,以<code>LiveFragment</code>为例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//为了不重复加载数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isDataLoadedOnce;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    TLLogger.trace(<span class="string">"ChildFragment"</span>, <span class="string">"LiveFragment onCreateView: "</span>);</span><br><span class="line">    mRootView = inflater.inflate(R.layout.fragment_life, container, <span class="keyword">false</span>);</span><br><span class="line">    EventBus.getDefault().register(<span class="keyword">this</span>);</span><br><span class="line">    initData();</span><br><span class="line">    findViews();</span><br><span class="line">    <span class="keyword">return</span> mRootView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    TLLogger.trace(<span class="string">"ChildFragment"</span>, <span class="string">"LiveFragment onResume: "</span>);</span><br><span class="line">    lazyload();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">lazyload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果加载过数据 或者不可见,则不再请求</span></span><br><span class="line">    <span class="comment">//防止不可见的情况去加载数据,也避免加载多次数据</span></span><br><span class="line">    <span class="keyword">if</span> (!isDataLoadedOnce&amp;&amp;isVisiable) &#123;</span><br><span class="line">        isDataLoadedOnce = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//dosth</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h3><ol><li>第一次调用<code>setUserVisibleHint</code>的时候它比<code>onCreateView</code>之前,这时候控件都没有初始化,需要小心.</li><li>onResume的时候,三个fragment都会调用onResume,但是<code>setUserVisibleHint</code>只涉及到可见性改变的fragment</li><li>滑动vp或者点击tab都会触发setUserVisibleHint</li><li>需要根据需要处理<code>onResume</code>和<code>lazyload</code></li></ol><h2 id="Fragment重叠问题"><a href="#Fragment重叠问题" class="headerlink" title="Fragment重叠问题"></a>Fragment重叠问题</h2><p>使用add hide show来控制显示fragment,但是一旦activity被回收,那些被hide的Fragment，也全部处于可见状态,并且无法操控,即出现fragment重叠问题.</p><p>原因:<strong>fragment被回收,然后 变透明了</strong></p><p>解决办法<br>重写activity的<code>onSaveInstanceState</code>并且不调用super<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/android-cn/android-discuss/issues/256" target="_blank" rel="noopener">关于Activity被回收，Fragment还在的问题</a><br><a href="http://www.yrom.net/blog/2013/03/10/fragment-switch-not-restart/" target="_blank" rel="noopener">让多个Fragment 切换时不重新实例化</a></p><h2 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h2><p>记录我遇到的坑</p><h3 id="remove-null-commit"><a href="#remove-null-commit" class="headerlink" title="remove(null).commit()"></a>remove(null).commit()</h3><p>当我试图在解决<strong>fragment被回收后出现重叠的状况</strong>的时候,我试着去移除原先老的fragment,但是发现如果被回收两次,olds虽然有size,但是它所包含的数据都是null!,导致remove(null).commit()报错!</p><p>报错日志:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">java<span class="selector-class">.lang</span><span class="selector-class">.NullPointerException</span></span><br><span class="line">    at android<span class="selector-class">.support</span><span class="selector-class">.v4</span><span class="selector-class">.app</span><span class="selector-class">.BackStackRecord</span><span class="selector-class">.run</span>(BackStackRecord<span class="selector-class">.java</span>:<span class="number">707</span>)</span><br><span class="line">    at android<span class="selector-class">.support</span><span class="selector-class">.v4</span><span class="selector-class">.app</span><span class="selector-class">.FragmentManagerImpl</span><span class="selector-class">.execPendingActions</span>(FragmentManag</span><br><span class="line">    at android<span class="selector-class">.support</span><span class="selector-class">.v4</span><span class="selector-class">.app</span><span class="selector-class">.FragmentController</span><span class="selector-class">.execPendingActions</span>(FragmentContro</span><br><span class="line">    at android<span class="selector-class">.support</span><span class="selector-class">.v4</span><span class="selector-class">.app</span><span class="selector-class">.FragmentActivity</span><span class="selector-class">.onStart</span>(FragmentActivity<span class="selector-class">.java</span>:<span class="number">511</span>)</span><br><span class="line">    at android<span class="selector-class">.app</span><span class="selector-class">.Instrumentation</span><span class="selector-class">.callActivityOnStart</span>(Instrumentation<span class="selector-class">.java</span>:<span class="number">1174</span>)</span><br><span class="line">    at android<span class="selector-class">.app</span><span class="selector-class">.Activity</span><span class="selector-class">.performStart</span>(Activity<span class="selector-class">.java</span>:<span class="number">5203</span>)</span><br><span class="line">    at android<span class="selector-class">.app</span><span class="selector-class">.ActivityThread</span><span class="selector-class">.performLaunchActivity</span>(ActivityThread<span class="selector-class">.java</span>:<span class="number">2198</span>)</span><br><span class="line">    at android<span class="selector-class">.app</span><span class="selector-class">.ActivityThread</span><span class="selector-class">.handleLaunchActivity</span>(ActivityThread<span class="selector-class">.java</span>:<span class="number">2286</span>)</span><br><span class="line">    at android<span class="selector-class">.app</span><span class="selector-class">.ActivityThread</span><span class="selector-class">.access</span>$<span class="number">600</span>(ActivityThread<span class="selector-class">.java</span>:<span class="number">144</span>)</span><br><span class="line">    at android<span class="selector-class">.app</span><span class="selector-class">.ActivityThread</span><span class="variable">$H</span>.handleMessage(ActivityThread<span class="selector-class">.java</span>:<span class="number">1259</span>)</span><br><span class="line">    at android<span class="selector-class">.os</span><span class="selector-class">.Handler</span><span class="selector-class">.dispatchMessage</span>(Handler<span class="selector-class">.java</span>:<span class="number">99</span>)</span><br><span class="line">    at android<span class="selector-class">.os</span><span class="selector-class">.Looper</span><span class="selector-class">.loop</span>(Looper<span class="selector-class">.java</span>:<span class="number">137</span>)</span><br><span class="line">    at android<span class="selector-class">.app</span><span class="selector-class">.ActivityThread</span><span class="selector-class">.main</span>(ActivityThread<span class="selector-class">.java</span>:<span class="number">5166</span>)</span><br><span class="line">    at java<span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.Method</span><span class="selector-class">.invokeNative</span>(Native Method)</span><br><span class="line">    at java<span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.Method</span><span class="selector-class">.invoke</span>(Method<span class="selector-class">.java</span>:<span class="number">525</span>)</span><br><span class="line">    at com<span class="selector-class">.android</span><span class="selector-class">.internal</span><span class="selector-class">.os</span><span class="selector-class">.ZygoteInit</span><span class="variable">$MethodAndArgsCaller</span>.run(ZygoteInit<span class="selector-class">.java</span>:</span><br><span class="line">    at com<span class="selector-class">.android</span><span class="selector-class">.internal</span><span class="selector-class">.os</span><span class="selector-class">.ZygoteInit</span><span class="selector-class">.main</span>(ZygoteInit<span class="selector-class">.java</span>:<span class="number">584</span>)</span><br><span class="line">    at dalvik<span class="selector-class">.system</span><span class="selector-class">.NativeStart</span><span class="selector-class">.main</span>(Native Method)</span><br></pre></td></tr></table></figure></p><p>场景:activity里有两个fragment,一个fragment里有viewpager+3个fragment</p><p>Activity的<code>onCreate</code> 部分源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (savedInstanceState == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//.....dosth</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//移除原来的fragment避免重叠</span></span><br><span class="line">    FragmentManager manager = getSupportFragmentManager();</span><br><span class="line">    List&lt;Fragment&gt; olds = manager.getFragments();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != olds) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = olds.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Fragment old = olds.get(i);</span><br><span class="line">            <span class="comment">//但是这里的old可能为null</span></span><br><span class="line">            manager.beginTransaction().remove(old).commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取回收之前的存储的当前显示页数,再把它显示出来</span></span><br><span class="line">    <span class="keyword">int</span> index = savedInstanceState.getInt(KEY_CURR_INDEX);</span><br><span class="line">    showOrHideFragment(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以需要再加一层判断:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != old) &#123;</span><br><span class="line">    manager.beginTransaction().remove(old).commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>完美!~</p><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><p><a href="http://stackoverflow.com/questions/13393693/android-fragmentmanager-backstackrecord-run-throwing-nullpointerexception" target="_blank" rel="noopener">android-fragmentmanager-backstackrecord-run-throwing-nullpointerexception</a></p><h3 id="activity被回收-fragment的onActivityCreated调用两次"><a href="#activity被回收-fragment的onActivityCreated调用两次" class="headerlink" title="activity被回收,fragment的onActivityCreated调用两次"></a>activity被回收,fragment的<code>onActivityCreated</code>调用两次</h3><p>场景:<br>Activity里有两个Fragment,其中一个里有viewpager+3个fagment.</p><p>当activity被回收,fragment的onActivityCreated被调用了两次(另外一个fragment也不例外):</p><ul><li>第一次 savedInstanceState 不为null 保存的数据还在</li><li>第二次 savedInstanceState 为null   丢失了</li></ul><p>这导致我在该fragment的onSaveInstanceState(Bundle outState)里保存的数据失效了</p><p>日志如:<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">onActivityCreated:</span> TLToplistFragment&#123;<span class="number">43</span>ceb940 <span class="meta">#1 id=0x7f0f0077 top&#125;</span></span><br><span class="line"><span class="symbol">onActivityCreated:</span> TLToplistFragment&#123;<span class="number">43</span>cf7048 <span class="meta">#1 id=0x7f0f0077 top&#125;</span></span><br></pre></td></tr></table></figure></p><p>找了很久,但是并没有找到原因以及解决办法,原本是用来保存数据的,现在没办法了,<br>最后通过在activity的<code>onSaveInstanceState</code>里获取fragment的数据,然后再在重新创建的时候通过<code>setArguments</code>传入的方式替代.  </p><p>这个坑的原因还不知道,暂时用其他方法给解决了需求.  </p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://stackoverflow.com/questions/12453710/lazy-load-data-for-viewpager-items" target="_blank" rel="noopener">http://stackoverflow.com/questions/12453710/lazy-load-data-for-viewpager-items</a><br><a href="http://blog.csdn.net/myatlantis/article/details/42643733" target="_blank" rel="noopener">http://blog.csdn.net/myatlantis/article/details/42643733</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fragment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Touch事件分发</title>
      <link href="/blog/a6a26d2.html"/>
      <url>/blog/a6a26d2.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>touch事件分发乃自定义View必学技能~<br><a id="more"></a></p><h2 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h2><ul><li><code>dispatchTouchEvent(MotionEvent ev)</code> 事件来了,第一个被调用,比较特殊,后面再说.</li><li><p><code>onTouchEvent(MotionEvent event)</code> true消费事件,false向上层回传</p><p><strong>以上两个方法Activity,ViewGroup,View</strong> 都有,而ViewGroup还多一个方法:  </p></li><li><p><code>onInterceptTouchEvent(MotionEvent ev)</code>  true为拦截事件,给自己的<code>onTouch</code></p></li></ul><h3 id="dispatchTouchEvent"><a href="#dispatchTouchEvent" class="headerlink" title="dispatchTouchEvent"></a>dispatchTouchEvent</h3><p>dispatchTouchEvent 比较特殊,一般看到的文章都不怎么提这个,但是我想看看,它有什么用.  </p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**  </span><br><span class="line"> * Called <span class="keyword">to</span> process touch screen events.  You can override this <span class="keyword">to</span></span><br><span class="line"> * intercept all touch screen events before they are dispatched <span class="keyword">to</span> the</span><br><span class="line"> * window.  Be sure <span class="keyword">to</span> <span class="keyword">call</span> this implementation <span class="keyword">for</span> touch screen events</span><br><span class="line"> * that should be handled normally.</span><br><span class="line"> *</span><br><span class="line"> * @param ev The touch screen <span class="keyword">event</span>.</span><br><span class="line"> *  如果<span class="literal">true</span>则消费这个事件</span><br><span class="line"> * @<span class="keyword">return</span> <span class="built_in">boolean</span> <span class="keyword">Return</span> <span class="literal">true</span> <span class="keyword">if</span> this <span class="keyword">event</span> was consumed.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>TouchActivity的<code>dispatchTouchEvent</code>返回true<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D/<span class="string">Touch:</span>  TouchActivity  dispatchTouchEvent() called <span class="string">with:</span> ev = [  action_down]</span><br><span class="line">D/<span class="string">Touch:</span>  TouchActivity  dispatchTouchEvent() called <span class="string">with:</span> ev = [  action_move]</span><br><span class="line">D/<span class="string">Touch:</span>  TouchActivity  dispatchTouchEvent() called <span class="string">with:</span> ev = [  action_up]</span><br></pre></td></tr></table></figure></p><p>TouchActivity的 false ,TopViewGroup 的 dispatchTouchEvent返回true<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Touch:</span>  <span class="string">TouchActivity</span>  <span class="string">dispatchTouchEvent()</span> <span class="string">called</span> <span class="attr">with:</span> <span class="string">ev</span> <span class="string">=</span> <span class="string">[</span>  <span class="string">action_down]</span></span><br><span class="line"><span class="attr">Touch:</span> <span class="string">TopViewGroup</span> <span class="string">dispatchTouchEvent()</span> <span class="literal">true</span>  <span class="string">called</span> <span class="attr">with:</span> <span class="string">ev</span> <span class="string">=</span> <span class="string">[</span>  <span class="string">action_down]</span></span><br><span class="line"><span class="attr">Touch:</span>  <span class="string">TouchActivity</span>  <span class="string">dispatchTouchEvent()</span> <span class="string">called</span> <span class="attr">with:</span> <span class="string">ev</span> <span class="string">=</span> <span class="string">[</span>  <span class="string">action_move]</span></span><br><span class="line"><span class="attr">Touch:</span> <span class="string">TopViewGroup</span> <span class="string">dispatchTouchEvent()</span> <span class="literal">true</span>  <span class="string">called</span> <span class="attr">with:</span> <span class="string">ev</span> <span class="string">=</span> <span class="string">[</span>  <span class="string">action_move]</span></span><br><span class="line"><span class="attr">Touch:</span>  <span class="string">TouchActivity</span>  <span class="string">dispatchTouchEvent()</span> <span class="string">called</span> <span class="attr">with:</span> <span class="string">ev</span> <span class="string">=</span> <span class="string">[</span>  <span class="string">action_up]</span></span><br><span class="line"><span class="attr">Touch:</span> <span class="string">TopViewGroup</span> <span class="string">dispatchTouchEvent()</span> <span class="literal">true</span>  <span class="string">called</span> <span class="attr">with:</span> <span class="string">ev</span> <span class="string">=</span> <span class="string">[</span>  <span class="string">action_up]</span></span><br></pre></td></tr></table></figure></p><p>返回值影响:</p><ul><li>false 分发给自己的<code>onInterceptTouchEvent</code>或者其他的<code>dispatchTouchEvent</code>.  </li><li>true 则消费掉这个事件,返回给上层,不再往下层分发该事件.  </li></ul><h4 id="Activity的表现"><a href="#Activity的表现" class="headerlink" title="Activity的表现"></a>Activity的表现</h4><p>需要注意的是Activity对<code>dispatchTouchEvent</code>的接受消费机制有所不同</p><ul><li><p>返回false/true 那么事件只会传递到Activity不会传递给contentview,也不会传递给Activity的<code>onTouchEvent</code>, 另外与View不同的是,当事件为Down的时候,<code>dispatchTouchEvent</code>返回false,Activity <strong>依然可以接受后续的MOVE,UP事件!!!</strong>,或者说所有事件都是首先经过Activity的?</p></li><li><p>返回 <code>super.dispatchTouchEvent(ev);</code> 事件才会继续分发,而它的值一般为<code>true</code>!</p></li></ul><p>日志如下<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TouchActivity  dispatchTouchEvent() called <span class="keyword">with</span>: <span class="attr">ev</span> = [  action_down]</span><br><span class="line">TouchActivity  dispatchTouchEvent() called <span class="keyword">with</span>: <span class="attr">ev</span> = [  action_move]</span><br><span class="line">TouchActivity  dispatchTouchEvent() called <span class="keyword">with</span>: <span class="attr">ev</span> = [  action_move]</span><br><span class="line">TouchActivity  dispatchTouchEvent() called <span class="keyword">with</span>: <span class="attr">ev</span> = [  action_up]</span><br></pre></td></tr></table></figure></p><h3 id="重写touch相关事件-并打印"><a href="#重写touch相关事件-并打印" class="headerlink" title="重写touch相关事件,并打印"></a>重写touch相关事件,并打印</h3><p>布局<br>重写它们各自拥有的方法,并打印log,看看流程,这是最最方便快捷的方法.</p><h4 id="默认情况"><a href="#默认情况" class="headerlink" title="默认情况"></a>默认情况</h4><p>都返回默认值false:<br>点击SimpleView后的日志:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Touch:</span>  <span class="string">TouchActivity</span>  <span class="string">dispatchTouchEvent()</span> <span class="string">called</span> <span class="attr">with:</span> <span class="string">ev</span> <span class="string">=</span> <span class="string">[</span>  <span class="string">action_down]</span></span><br><span class="line"><span class="attr">Touch:</span> <span class="string">TopViewGroup</span> <span class="string">dispatchTouchEvent()</span> <span class="literal">false</span>  <span class="string">called</span> <span class="attr">with:</span> <span class="string">ev</span> <span class="string">=</span> <span class="string">[</span>  <span class="string">action_down]</span></span><br><span class="line"><span class="attr">Touch:</span> <span class="string">TopViewGroup</span> <span class="string">onInterceptTouchEvent()</span> <span class="literal">false</span>  <span class="string">called</span> <span class="attr">with:</span> <span class="string">ev</span> <span class="string">=</span> <span class="string">[</span>  <span class="string">action_down]</span></span><br><span class="line"><span class="attr">Touch:</span> <span class="string">MiddleViewGroup</span> <span class="string">dispatchTouchEvent()</span> <span class="literal">false</span>  <span class="string">called</span> <span class="attr">with:</span> <span class="string">ev</span> <span class="string">=</span> <span class="string">[</span>  <span class="string">action_down]</span></span><br><span class="line"><span class="attr">Touch:</span> <span class="string">MiddleViewGroup</span> <span class="string">onInterceptTouchEvent()</span> <span class="literal">false</span> <span class="string">called</span> <span class="attr">with:</span> <span class="string">ev</span> <span class="string">=</span> <span class="string">[</span>  <span class="string">action_down]</span></span><br><span class="line"><span class="attr">Touch:</span> <span class="string">SimpleView</span> <span class="string">dispatchTouchEvent()</span> <span class="literal">false</span>  <span class="string">called</span> <span class="attr">with:</span> <span class="string">ev</span> <span class="string">=</span> <span class="string">[</span>  <span class="string">action_down]</span></span><br><span class="line"><span class="attr">Touch:</span> <span class="string">SimpleView</span> <span class="string">onTouchEvent()</span> <span class="literal">false</span>  <span class="string">called</span> <span class="attr">with:</span> <span class="string">ev</span> <span class="string">=</span> <span class="string">[</span>  <span class="string">action_down]</span></span><br><span class="line"><span class="attr">Touch:</span> <span class="string">MiddleViewGroup</span> <span class="string">onTouchEvent()</span> <span class="literal">false</span>  <span class="string">called</span> <span class="attr">with:</span> <span class="string">ev</span> <span class="string">=</span> <span class="string">[</span>  <span class="string">action_down]</span></span><br><span class="line"><span class="attr">Touch:</span> <span class="string">TopViewGroup</span> <span class="string">onTouchEvent()</span> <span class="literal">false</span>  <span class="string">called</span> <span class="attr">with:</span> <span class="string">ev</span> <span class="string">=</span> <span class="string">[</span>  <span class="string">action_down]</span></span><br><span class="line"><span class="attr">Touch:</span>  <span class="string">TouchActivity</span>  <span class="string">onTouchEvent()</span> <span class="string">called</span> <span class="attr">with:</span> <span class="string">event</span> <span class="string">=</span> <span class="string">[</span>  <span class="string">action_down]</span></span><br><span class="line"><span class="attr">Touch:</span>  <span class="string">TouchActivity</span>  <span class="string">dispatchTouchEvent()</span> <span class="string">called</span> <span class="attr">with:</span> <span class="string">ev</span> <span class="string">=</span> <span class="string">[</span>  <span class="string">action_up]</span></span><br><span class="line"><span class="attr">Touch:</span>  <span class="string">TouchActivity</span>  <span class="string">onTouchEvent()</span> <span class="string">called</span> <span class="attr">with:</span> <span class="string">event</span> <span class="string">=</span> <span class="string">[</span>  <span class="string">action_up]</span></span><br></pre></td></tr></table></figure></p><p>可以看到事件的分发的大致流程如下:  </p><ul><li>事件流程: 事件从上层传递到下层,即Activity-&gt;ViewGroup-&gt;ViewGroup…-&gt;View</li><li>方法流程: <code>dispatchTouchEvent</code>-&gt;<code>onInterceptTouchEvent</code>-&gt;<code>onTouchEvent</code>,事件不消费则再往上层传递.  </li></ul><p>action_down事件从activity-&gt;TopViewGroup-&gt;MiddleViewGroup-&gt;SimpleView,再从底层view传递到activity.<br>并且<strong>action_up</strong>只传递给了activity.  </p><p>知识点:</p><ol><li>对事件的反馈会被记录,如果对上个事件返回false(不包括dispatchTouchEvent),则下个接着的事件不会再有回调. (比如不处理down,那么move也不会下发回来)</li></ol><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IntentService教给我什么</title>
      <link href="/blog/d5a070bd.html"/>
      <url>/blog/d5a070bd.html</url>
      
        <content type="html"><![CDATA[<h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a><a href="http://developer.android.com/intl/zh-cn/reference/android/app/IntentService.html" target="_blank" rel="noopener">IntentService</a></h2><p>前几天学习了Service,是时候来学习一下IntentService了.  </p><p>一如既往,先看下官网介绍:  </p><blockquote><p>IntentService is a base class for Services that handle asynchronous requests (expressed as Intents) on demand. Clients send requests through startService(Intent) calls; the service is started as needed, handles each Intent in turn using a worker thread, and stops itself when it runs out of work.<br>This “work queue processor” pattern is commonly used to offload tasks from an application’s main thread. The IntentService class exists to simplify this pattern and take care of the mechanics. To use it, extend IntentService and implement onHandleIntent(Intent). IntentService will receive the Intents, launch a worker thread, and stop the service as appropriate.<br>All requests are handled on a single worker thread – they may take as long as necessary (and will not block the application’s main loop), but only one request will be processed at a time.</p></blockquote><p>简单总结一下:<br>service的子类,用于处理异步请求,并且在工作线程按顺序处理请求,工作完后自己停止.<br>使用也很简单,继承IntentService,实现<code>onHandleIntent(Intent)</code>方法即可.<br>特点:</p><ol><li>与Service不同,IntentService是起线程处理任务的</li><li>自带队列,每个请求都会排队</li><li>任务完成自己会调用<code>stopSelf</code>结束,无需我们操心<a id="more"></a></li></ol><h2 id="一探究竟"><a href="#一探究竟" class="headerlink" title="一探究竟"></a>一探究竟</h2><p>IntentService源码不多,截取了部分:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Looper mServiceLooper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ServiceHandler mServiceHandler;</span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mRedelivery;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">          <span class="comment">//调用onHandleIntent</span></span><br><span class="line">            onHandleIntent((Intent)msg.obj);</span><br><span class="line">            <span class="comment">// 处理完自己停止</span></span><br><span class="line">            stopSelf(msg.arg1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntentService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        mName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntentRedelivery</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">        mRedelivery = enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        <span class="comment">//开启个新的线程</span></span><br><span class="line">        HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">//getLooper 来获取thread的looper</span></span><br><span class="line">        mServiceLooper = thread.getLooper();</span><br><span class="line">        <span class="comment">//拿looper实例化 handler</span></span><br><span class="line">        mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = startId;</span><br><span class="line">        msg.obj = intent;</span><br><span class="line">        <span class="comment">//封装intent的请求 用handler发送</span></span><br><span class="line">        mServiceHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        onStart(intent, startId);</span><br><span class="line">        <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//退出循环</span></span><br><span class="line">        mServiceLooper.quit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>成员变量不多,一个looper,一个handler,接下来分析一下:<br>在onCreate里,实例化一个HandlerThread(继承自Thread,HandlerThread后面再说)并且启动线程,并且利用该HandlerThread线程的looper实例化handler.<br>onStart里接受的intent,封装成Message用handler发送,并在<code>handleMessage</code>中调用<code>onHandleIntent((Intent)msg.obj);</code>,再stopSelf.<br>另外在<code>onDestroy</code>里调用了looper.quit();退出looper.</p><p>这样intentService的机制原理也差不多看完了,其实不难,但是也能学到不少东西:  </p><ol><li><code>HandlerThread</code>类–&gt;<a href="http://developer.android.com/intl/zh-cn/reference/android/os/HandlerThread.html" target="_blank" rel="noopener">官方资料</a></li></ol><blockquote><p>Handy class for starting a new thread that has a looper. The looper can then be used to create handler classes. Note that start() must still be called.</p></blockquote><p>方便我们创建一个拥有looper的线程,可以用来创建handler.注意: start() 必须被调用!  </p><p>以前也不知道这个类,这次索性来看看HandlerThread的源码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mPriority;</span><br><span class="line">    <span class="keyword">int</span> mTid = -<span class="number">1</span>;</span><br><span class="line">    Looper mLooper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method returns the Looper associated with this thread. If this thread not been started</span></span><br><span class="line"><span class="comment">     * or for any reason is isAlive() returns false, this method will return null. If this thread</span></span><br><span class="line"><span class="comment">     * has been started, this method will block until the looper has been initialized.  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The looper.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            looper.quit();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            looper.quitSafely();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getThreadId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mTid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们都知道在线程里实例化handler要调用<code>Looper.prepare();</code>和<code>Looper.loop();</code>,其实就是因为Looper<br>而HandlerThread有个成员变量mLooper,并且在run里面实例化了它,并且已经为我们封装好了Looper相关的方法~</p><p>注意<code>getLooper</code>方法,当mLooper为null时会一直wait,直到<code>run</code>方法里实例化mLooper并<code>notifyAll</code>,可以学习一下.</p><p>用法就拿一下IntentService里的代码吧:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</span><br><span class="line">thread.start();</span><br><span class="line">mServiceLooper = thread.getLooper();</span><br><span class="line">mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br></pre></td></tr></table></figure></p><ol start="2"><li>Handler类的<code>handleMessage</code>方法所在的线程决定于它的Looper所在的线程,这个以前一直没留意.</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主要学习到了:</p><ol><li>可以利用Handler去维护一个队列,很简单</li><li>HandlerThread类</li><li>Handler的<code>handleMessage</code>方法所在的线程决定于它的Looper所在的线程</li></ol><p>IntentService代码虽少,但是非常好.<br>另外,Android还有很多很好的类需要我去发现,去学习!~<br>又学了一招,哈哈!~  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntentService </tag>
            
            <tag> RTFSC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Service学习笔记</title>
      <link href="/blog/b8879fa0.html"/>
      <url>/blog/b8879fa0.html</url>
      
        <content type="html"><![CDATA[<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a><a href="http://developer.android.com/intl/zh-cn/guide/components/services.html" target="_blank" rel="noopener">Service</a></h2><p>Service,四大组件之一,是一个可以在后台执行长时间运行操作而不使用用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。</p><p>但是必须要提的是,虽然说是后台,但是<strong>Service运行在主线程</strong>!<br>PS:Service的官方文档有中文翻译了!!真是个大好的消息!</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>跟Activity类似,service也有自己的生命周期,但是简单了一些.<br><img src="http://ww1.sinaimg.cn/large/98900c07gw1exausnlz6xj20at0e3tan.jpg" alt="service_lifecycle"></p><h2 id="Service的基本使用"><a href="#Service的基本使用" class="headerlink" title="Service的基本使用"></a>Service的基本使用</h2><p>上面的生命周期已经提示到了,使用Service有两种方式,启动/停止,绑定/解绑,一一对应:  </p><ol><li>startService stopService(启动)</li><li>bindService unbindService(绑定)</li><li>还有一种就是即调用start,又调用bind(又启动又绑定)</li></ol><p>这几个方式都有什么区别呢?<br>不急,咱慢慢来,一一解答.    </p><a id="more"></a><p>咱先写个MyService,继承service,重写他的各种方法,并加入打印日志(这是我学习最常用的办法).<br>写几个按钮调用不同方法,再加个<code>ServiceConnection</code>,代码就不给全了,没难度,不过要注意<em>Service要在xml里配置</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".service.MyService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解释一下xml的属性:  </p><ol><li>enabled:  是否能被系统实例化,false就用不了了</li><li>exported: 其他应用的组件是否能跟它交互,false表示私有只能自己应用使用,true表示可以被其他应用调起</li></ol><p>对于xml的配置,官方有些建议:</p><ol><li>为了确保应用的安全性，请始终使用显式 Intent 启动或绑定 Service，且不要为服务声明 Intent 过滤器。</li><li>添加 android:exported 属性并将其设置为 “false”，确保服务仅适用于您的应用。这可以有效阻止其他应用启动您的服务，即便在使用显式 Intent 时也如此。</li></ol><p>点击事件:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnClick</span>(&#123;R.id.start_service, R.id.stop_service, R.id.bind_service, R.id.unbind_service&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(ServiceActivity.<span class="keyword">this</span>,MyService.class);</span><br><span class="line">    <span class="keyword">switch</span> (view.getId()) &#123;</span><br><span class="line">        <span class="keyword">case</span> R.id.start_service:</span><br><span class="line">            startService(intent);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.stop_service:</span><br><span class="line">            stopService(intent);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.bind_service:</span><br><span class="line">            bindService(intent,con, Service.BIND_AUTO_CREATE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.unbind_service:</span><br><span class="line">            unbindService(con);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bindservice 需要</span></span><br><span class="line">ServiceConnection con = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onServiceConnected() called with: "</span> + <span class="string">"name = ["</span> + name + <span class="string">"], service = ["</span> + service + <span class="string">"]"</span>);</span><br><span class="line">        ((MyService.MyBinder)service).dosth();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onServiceDisconnected() called with: "</span> + <span class="string">"name = ["</span> + name + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>PS:bindService的参数BIND_AUTO_CREATE表示在Activity和Service建立关联后自动创建Service，这会使得MyService中的onCreate()方法得到执行，但onStartCommand()方法不会执行。(来自guolin的博客)</p><h3 id="startService-amp-stopService"><a href="#startService-amp-stopService" class="headerlink" title="startService&amp;stopService"></a>startService&amp;stopService</h3><h4 id="startService"><a href="#startService" class="headerlink" title="startService"></a>startService</h4><p>使用startService启动service:<br>第一次启动service会调用<code>onCreate</code>,<code>onStartCommand</code>,而后面的则不会再调用<code>onCreate</code>而是<code>onStartCommand</code>,并且每次startId不同.</p><p>注意是<code>启动</code>,启动后,这样在手机设置-正在运行界面会显示有<code>MyService</code>存在.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D/<span class="string">MyService:</span> <span class="string">onCreate:</span></span><br><span class="line">D/<span class="string">MyService:</span> onStartCommand()</span><br><span class="line"><span class="comment">//第二次startService</span></span><br><span class="line">D/<span class="string">MyService:</span> onStartCommand()</span><br></pre></td></tr></table></figure></p><h4 id="stopService"><a href="#stopService" class="headerlink" title="stopService"></a>stopService</h4><p>调用stopService,情况如下:</p><ol><li>如果service已经通过startService启动,则<code>onDestroy</code></li><li>如果service没启动,则没什么效果<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D/<span class="string">MyService:</span> <span class="string">onDestroy:</span></span><br></pre></td></tr></table></figure></li></ol><p>stopService之后,正在运行界面不会有MyService存在了.</p><p>PS:如果不调用stop,直接关掉Activity对Service没影响,即两者的生命周期没有关联.</p><h3 id="bindService-amp-unbindService"><a href="#bindService-amp-unbindService" class="headerlink" title="bindService&amp;unbindService"></a>bindService&amp;unbindService</h3><p>用到bind跟之前的startService不同,我们还需要重写onBind,添加Bind类:  </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">public <span class="type">IBinder</span> onBind(<span class="type">Intent</span> intent) &#123;</span><br><span class="line">    <span class="type">Log</span>.d(<span class="type">TAG</span>, <span class="string">"onBind: "</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">MyBinder</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    public void dosth()&#123;</span><br><span class="line">        <span class="type">Log</span>.d(<span class="type">TAG</span>, <span class="string">"dosth: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bindService"><a href="#bindService" class="headerlink" title="bindService"></a>bindService</h4><p>bindService作用是跟service进行绑定.<br>文档介绍:<br>绑定服务是客户端-服务器接口中的服务器。<br>绑定服务可让组件（例如 Activity）绑定到服务、发送请求、接收响应，甚至执行进程间通信 (IPC)。<br>绑定服务通常只在为其他应用组件服务时处于活动状态，不会无限期在后台运行。  </p><p>点击bind按钮,发现MyService调用了<code>onCreate</code>和<code>onBind</code>,并且之前的<code>ServiceConnection</code>里的<code>onServiceConnected</code>也被调用了.<br><strong>注意:</strong></p><ol><li>跟startService不同的是,多次调用bindService没有效果,不会再多调用onBind**   </li><li>如果<code>onBind</code>里我们返回<code>null</code>那么<code>onServiceConnected</code>不会被调用</li><li>不同于startService,bind调用后,设置-正在运行里是看不到有Service运行着的.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D/<span class="string">MyService:</span> <span class="string">onCreate:</span></span><br><span class="line">D/<span class="string">MyService:</span> <span class="string">onBind:</span></span><br><span class="line">D/<span class="string">MyService:</span> onServiceConnected()</span><br><span class="line">D/<span class="string">MyService:</span> <span class="string">dosth:</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="http://ww2.sinaimg.cn/large/98900c07gw1ex9ypz1wz6j20bf0500su.jpg" alt=""></p><h4 id="unbindService"><a href="#unbindService" class="headerlink" title="unbindService"></a>unbindService</h4><p>unbindService是用于解绑,取消关联</p><ol><li><p>如果没用bindService启动过service(注意:<strong>即使是startService启动的也不行</strong>),直接调用<code>unbindService</code>,则会崩溃:  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException:<span class="built_in"> Service </span><span class="keyword">not</span> registered: yifeiyuan.practice.practicedemos.service.ServiceActivity<span class="variable">$1</span>@535f696c</span><br></pre></td></tr></table></figure></li><li><p>如果已经用bindService启动过,则会停止service  </p></li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D/<span class="string">MyService:</span> <span class="string">onUnbind:</span></span><br><span class="line">D/<span class="string">MyService:</span> <span class="string">onDestroy:</span></span><br></pre></td></tr></table></figure><p>PS:如果不调用onUnbind,直接关掉Activity,跟unBind效果一样,也就是说两者生命周期相同,共存亡.</p><p>看到这里,我发现很奇怪的是,我们<code>ServiceConnection</code>里的<code>onServiceDisconnected</code>方法并没有被调用.<br>于是跟踪了一下方法的说明:<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Called when <span class="keyword">a</span> connection <span class="keyword">to</span> the Service <span class="built_in">has</span> been lost.  This typically</span><br><span class="line">happens when the process hosting the service <span class="built_in">has</span> crashed <span class="built_in">or</span> been killed.</span><br><span class="line">This does <span class="symbol">&lt;em&gt;</span>not&lt;/<span class="keyword">em</span>&gt; <span class="built_in">remove</span> the ServiceConnection itself -- this</span><br><span class="line">binding <span class="keyword">to</span> the service will remain active, <span class="built_in">and</span> you will receive <span class="keyword">a</span> <span class="keyword">call</span></span><br><span class="line"><span class="keyword">to</span> &#123;@link #onServiceConnected&#125; when the Service <span class="keyword">is</span> <span class="keyword">next</span> running.</span><br></pre></td></tr></table></figure></p><p>官方文档中也有提到:<br>Android 系统会在与服务的连接意外中断时（例如当服务崩溃或被终止时）调用该方法。当客户端取消绑定时，系统“绝对不会”调用该方法。</p><p><em>自己尝试去设置界面停止服务,强杀应用,也没发现它调用!.</em></p><h3 id="startService和bindService组合启动"><a href="#startService和bindService组合启动" class="headerlink" title="startService和bindService组合启动"></a>startService和bindService组合启动</h3><p>先start后bind:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D/<span class="string">MyService:</span> <span class="string">onCreate:</span></span><br><span class="line">D/<span class="string">MyService:</span> <span class="string">onStartCommand:</span></span><br><span class="line">D/<span class="string">MyService:</span> <span class="string">onBind:</span></span><br><span class="line">D/<span class="string">MyService:</span> onServiceConnected()</span><br><span class="line">D/<span class="string">MyService:</span> <span class="string">dosth:</span></span><br></pre></td></tr></table></figure></p><p>尝试结束解绑service:</p><ol><li>先stop     效果: Service停止了(运行界面看不到Service),但是没有onDestory的日志,即没销毁  </li><li><p>再unbind   效果: 输出<code>onUnbind</code>和<code>onDestroy</code>,并销毁  </p></li><li><p>先unbind  效果:输出日志<code>onUnbind</code>,没销毁</p></li><li>后stop    效果:输出日志<code>onDestroy</code> Service停止了,并销毁</li></ol><p>结果: unbind后出现<code>onUnbind</code>,stop后出现<code>onDestroy</code>.  </p><p>那这个是为什么呢?<br>因为:<strong>服务有两种状态,一种<code>已启动</code>,另外一种<code>已绑定</code>,并且当且仅当服务没有状态时才会销毁.</strong>  </p><h3 id="start和bind的区别"><a href="#start和bind的区别" class="headerlink" title="start和bind的区别"></a>start和bind的区别</h3><ol><li>start启动的service与组件生命周期无关,bind的service与组件的生命周期绑定,共存亡</li><li>start给service一种已启动的状态,bind给的是绑定状态</li><li>广播不能绑定service,但能启动service</li></ol><h3 id="另外一些回调"><a href="#另外一些回调" class="headerlink" title="另外一些回调"></a>另外一些回调</h3><p>我按Home回桌面的时候,回调了<code>onTrimMemory</code>,其他暂时不知.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D/<span class="string">MyService:</span> <span class="string">onCreate:</span></span><br><span class="line">D/<span class="string">MyService:</span> <span class="string">onBind:</span></span><br><span class="line">D/<span class="string">MyService:</span> onServiceConnected()</span><br><span class="line">D/<span class="string">MyService:</span> <span class="string">dosth:</span></span><br><span class="line">D/<span class="string">MyService:</span> <span class="string">onTrimMemory:</span></span><br></pre></td></tr></table></figure></p><h2 id="在前台运行服务"><a href="#在前台运行服务" class="headerlink" title="在前台运行服务"></a>在前台运行服务</h2><p>前面说到service是后台,所以呢service可能会被杀死.<br>前台服务被认为是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。<br>前台服务必须为状态栏提供通知!</p><p>这种非常常见,比如网易云音乐播放音乐的时候就会有通知在通知栏~</p><p>通过<code>startForeground</code>来让服务运行于前台:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Notification notification = <span class="keyword">new</span> Notification(R.drawable.icon, getText(R.string.ticker_text),System.currentTimeMillis());</span><br><span class="line">Intent notificationIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, ExampleActivity.class);</span><br><span class="line">PendingIntent pendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, notificationIntent, <span class="number">0</span>);</span><br><span class="line">notification.setLatestEventInfo(<span class="keyword">this</span>, getText(R.string.notification_title),getText(R.string.notification_message), pendingIntent);</span><br><span class="line">startForeground(ONGOING_NOTIFICATION_ID, notification);</span><br></pre></td></tr></table></figure></p><p>可以通过<code>stopForeground(boolean removeNotification)</code>来停止.<br><code>removeNotification</code>代表 <em>是否也删除状态栏通知</em>。<br>需要注意的是: 此方法绝对不会停止服务。 但是，如果您在服务正在前台运行时将其停止，则通知也会被删除。</p><h2 id="Service通信"><a href="#Service通信" class="headerlink" title="Service通信"></a>Service通信</h2><p>Service与Activity通信的除了之前所说的bind进行绑定之外,还可以选择:</p><ol><li>发送广播</li><li>使用EventBus/Otto等事件订阅发送框架(推荐这个,更加方便)</li></ol><p>跨进程通信(IPC):</p><ol><li><a href="http://developer.android.com/intl/zh-cn/guide/components/aidl.html" target="_blank" rel="noopener">AIDL</a></li><li><a href="http://developer.android.com/intl/zh-cn/reference/android/os/Messenger.html" target="_blank" rel="noopener">Messenger</a></li></ol><p>官方资料:<br>使用Messenger是执行进程间通信 (IPC) 的最简单方法,因为 Messenger 会在单一线程中创建包含所有请求的队列，这样您就不必对服务进行线程安全设计。</p><p>这些AIDL跟Messenger的例子官网都有,就不写了,官方的资料总是最好的~  </p><blockquote><p>PS: Android Interface Definition Language (AIDL)</p></blockquote><h2 id="处理Service的onStartCommand返回值"><a href="#处理Service的onStartCommand返回值" class="headerlink" title="处理Service的onStartCommand返回值"></a>处理Service的onStartCommand返回值</h2><p>来源于官方文档:<br>onStartCommand() 方法必须返回整型数,用于描述系统应该<strong>如何在服务终止的情况下继续运行服务</strong>.</p><p>从 onStartCommand() 返回的值必须是以下常量之一：</p><ul><li>START_NOT_STICKY<br>如果系统在 onStartCommand() 返回后终止服务，则除非有挂起 Intent 要传递，否则系统 <strong>不会重建服务</strong>。<br>这是最安全的选项,可以 <em>避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务</em>。</li><li>START_STICKY<br>如果系统在 onStartCommand() 返回后终止服务，则会 <em>重建服务并调用 onStartCommand()</em>,<strong>但绝对不会重新传递最后一个 Intent</strong>.<br>相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过 <strong>空Intent</strong> 调用 onStartCommand()。<br>这适用于 <em>不执行命令、但无限期运行并等待作业的媒体播放器(或类似服务)</em>。   </li><li>START_REDELIVER_INTENT<br>如果系统在 onStartCommand() 返回后终止服务，则会 <em>重建服务</em>，并通过 <em>传递给服务的最后一个 Intent 调用 onStartCommand()</em>。<br>任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。</li></ul><p>小结:</p><ol><li>START_STICKY,START_REDELIVER_INTENT 会重启服务</li><li>START_STICKY 会传递null的intent</li><li>START_REDELIVER_INTENT 会传递最后一个intent</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>诶,学android一年了才来学习Service也真是给跪了,平时也不怎么用到service就用来下载文件.<br>之前说到service是主线程运行的,还需要自己开线程,而且多线程不安全,很坑,还好我们还有<strong>IntentService</strong>.<br>接下去就学习IntentService去~</p><h2 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h2><ol><li><a href="http://developer.android.com/intl/zh-cn/guide/components/bound-services.html" target="_blank" rel="noopener">绑定服务</a></li><li><a href="http://developer.android.com/intl/zh-cn/guide/components/aidl.html" target="_blank" rel="noopener">Android Interface Definition Language(AIDL)</a></li><li><a href="http://blog.csdn.net/guolin_blog/article/details/11952435" target="_blank" rel="noopener">http://blog.csdn.net/guolin_blog/article/details/11952435</a></li><li><a href="http://blog.csdn.net/guolin_blog/article/details/9797169" target="_blank" rel="noopener">http://blog.csdn.net/guolin_blog/article/details/9797169</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Service </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android群英传笔记</title>
      <link href="/blog/eb637bf0.html"/>
      <url>/blog/eb637bf0.html</url>
      
        <content type="html"><![CDATA[<h2 id="Android群英传"><a href="#Android群英传" class="headerlink" title="Android群英传"></a>Android群英传</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>医生写的,适合进阶,不适合初学者,在这里记录一下自己所学到的知识点.  </p><p>本人是奔着自定义的相关知识点来的,所以对这方面的知识点有所侧重.  </p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><ol><li>整个界面的控件形成一个控件树,上层控件负责下层子控件的测量与绘制,并传递事件,并且每个控件树的顶点都有一个ViewParent对象,所有交互事件都由它控制</li><li>findViewById在控件树中已深度优先遍历来查找对应元素.</li><li>每个Activity都包含一个Window对象(通常是PhoneWindow),它将DecorView设为整个应用窗口的根View</li><li>requestWindowFeature()方法一定要在调用setContentView之前才有效.</li><li>onResume之后,系统才将DecorView添加到PhoneWindow并显示.</li><li>MeasureSpec,一个32位的int值,高2位为测量的模式,低30位为测量的大小(位运算提高并优化效率)</li><li>EXACTLY 精确模式, 具体值/match_parent</li><li>AT_MOST,最大值模式—wrap_content,表示子控件不允许超过该大小</li><li>UNSPECIFIED,想多大多大,通常用于自定义View</li><li>View默认的onMeasure只支持Exactly,可以响应具体值和match_parent,所以自定义View如果要支持wrap_content则需要重写onMeasure</li><li>通过MeasureSpec.getMode和getSize方法获取测量模式与大小.</li><li>最终要setMeasuredDimension(width,height)完成测量</li><li>Canvas的bitmap与canvas是紧紧联系在一起的,这过程成为装载画布</li><li>该bitmap存储所有绘制在Canvas上的像素信息(即canvas.drawXXX()都发生在该bitmap上)</li><li>mTouchSlop = ViewConfiguration.getScaledTouchSlop()</li></ol><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><ol><li>使用viewholder提高效率</li><li>设置显示第几项<code>setSelection(int n)</code>,<code>smoothScrollBy(distance,duration)</code>,<code>smoothScrollByOffset(offset)</code>,<code>smoothScrollToPosition(index)</code></li><li><code>listview.setEmptyView(view)</code>处理空数据</li><li>弹性ListView实现方法:重写<code>overScrollBy(..int maxOverScrollY)</code>,重新赋值参数maxOverScrollY即可</li></ol><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><ol><li><p>屏幕最左上角顶点作为Android坐标系的原点</p></li><li><p>getLocationOnScreen(int location[])获取在Android坐标系中的位置</p></li><li><p>ViewGroup.MarginLayoutParams更方便</p></li><li><p>通过getLayoutParams可获取LayoutParams对象</p></li><li><p>ViewDragHelper.smoothSlideViewTo(view,x,y)</p></li><li><p>ViewCompat.postInvalidateOnAnimation(view)</p></li></ol><h2 id="第六章-todo"><a href="#第六章-todo" class="headerlink" title="第六章(todo)"></a>第六章(todo)</h2><ol><li>canvas.save()保存画布,canvas.restore()将我们在save之后绘制的所有图像与save之前的图像进行合并(似PS中的合并图层)</li><li>canvas.translate(x,y)将原点(0,0)移动到(x,y)并以新的点作为原点</li><li>canvas.saveLayer(),saveLayerAlpha()将一个图层入栈,并且后面的操作都发生在这个图层</li><li>restore(),restoreToCount()将一个图层出栈,把图层上的图像绘制到上层Canvas上</li><li>ColorMatrix,一个4X5的数字矩阵,处理色彩效果.</li><li><code>ColorMatrix.setRotate(int rgb,int value)</code>设置色调,0,1,2分别对应RGB</li><li>饱和度(饱和度为0时,图像就变成灰度图像了)<code>colorMatrix.setSaturation(float sat)</code></li><li>亮度(亮度为0时,图像就全黑了)<code>colorMatrix.setScale(float rScale, float gScale, float bScale,float aScale)</code></li><li>矩阵的乘法(将矩阵的作用效果混合,从而叠加处理效果):<code>postContact</code></li><li>使用ColorMatrix,<code>paint.setColorFilter(new ColorMatrixColorFilter(colorMatrix))</code>接着<code>canvas.drawxx(...,paint)</code></li></ol><h3 id="6-6-Android图像处理之图形特效处理"><a href="#6-6-Android图像处理之图形特效处理" class="headerlink" title="6.6 Android图像处理之图形特效处理"></a>6.6 Android图像处理之图形特效处理</h3><ol start="10"><li>变形矩阵Matrix,一个3X3的矩阵,<br>|A B C|<br>|D E F|<br>|0 0 1|<br>初始为:<br>|1,0,0|<br>|0,1,0|<br>|0,0,1|</li><li>Matrix的四类变换:</li></ol><ul><li>平移 set.translate 由CF控制</li><li>旋转 set.rotate    由ABCD共同控制</li><li>缩放 set.scale     由AE控制</li><li>错切 set.skew      由BD控制</li></ul><ol start="12"><li><code>pre()</code>和<code>post()</code>提供矩阵的前乘和后乘运算,两者不相同(因此,矩阵不满足乘法交换律)</li><li>drawBitmapMesh(P144)</li></ol><h3 id="6-7画笔特效处理"><a href="#6-7画笔特效处理" class="headerlink" title="6.7画笔特效处理"></a>6.7画笔特效处理</h3><ol><li><p>PoterDuffXfermode 最好关闭硬件加速</p></li><li><p>Shader着色器,渲染器,用来实现一些列的渐变,渲染效果</p></li></ol><ul><li>BitmapShader   位图Shader</li><li>LinearGradient 线性</li><li>RadialGradient 光束</li><li>SweepGradient  梯度</li><li>ComposeShader  混合</li></ul><ol start="3"><li>SurfaceView 适用于频繁更新或刷新时数据处理量比较大</li><li><code>lockCanvas()</code>获取Canvas,但是需要drawColor清屏</li><li><code>unlockCanvasAndPost(mCanvas)</code>提交canvas的内容(最好放在finally代码块中)   </li></ol><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><ol><li>视图动画,优点:简单,缺点:不具备交互性</li></ol><ul><li>AlphaAnimation</li><li>RotateAnimation</li><li>TranslateAnimation</li><li>ScaleAnimation</li><li>AnimationSet<br> ​</li></ul><ol start="2"><li>属性动画</li></ol><ul><li>ObjectAnimator 单一属性</li><li>PropertyValuesHolder 多个属性结合</li><li>ValueAnimator</li><li>AnimatorSet<br> ​</li></ul><h2 id="Q-amp-A-todo"><a href="#Q-amp-A-todo" class="headerlink" title="Q&amp;A(todo)"></a>Q&amp;A(todo)</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void methodA()&#123;</span><br><span class="line"><span class="type">Object</span> <span class="class"><span class="keyword">object</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">object</span> </span>= <span class="keyword">new</span> <span class="type">Object</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void methodB()&#123;</span><br><span class="line"><span class="type">Object</span> <span class="class"><span class="keyword">object</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">object</span> </span>= <span class="keyword">new</span> <span class="type">Object</span>();</span><br><span class="line"><span class="class"><span class="keyword">object</span> </span>= <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Q:methodB 中的最后一行是否会让object的堆内存回收掉?还是说依然要等GC?</p><p>A:要等gc的,gc的时候 会去找对象是否还有ref 如果没有的话 才清除  你=null只是清除了ref</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android群英传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thread相关知识点整理</title>
      <link href="/blog/2d0f0f65.html"/>
      <url>/blog/2d0f0f65.html</url>
      
        <content type="html"><![CDATA[<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>多线程,举足轻重,记录整理部分相关的重要的知识点,后续应该还需要再学习一下Runnable,线程池.  </p><p>后面有提到<code>monitor</code>,翻译为 <em>监视器</em>  </p><p>线程的状态图/生命周期图:<br><img src="http://ww3.sinaimg.cn/large/98900c07gw1exchm7aydej20lm0erdhk.jpg" alt="Thread-LifeCycle"></p><a id="more"></a><h2 id="Thread-sleep"><a href="#Thread-sleep" class="headerlink" title="Thread.sleep()"></a>Thread.sleep()</h2><p>静态方法,即作用于当前线程</p><p>睡眠,睡眠当前线程,睡眠后回到<strong>可执行状态</strong>,所以并不一定睡眠过会立马执行后面的代码,或许休眠这词更好.  </p><pre><code>PS:sleep,锁并没有被释放</code></pre><h2 id="Thread-yield"><a href="#Thread-yield" class="headerlink" title="Thread.yield();"></a>Thread.yield();</h2><p>yield()是个静态方法.<br><em>Thinking in java</em> 的解释如下:<br>对 <em>线程调度器</em> 的一种建议,它在声明:”我已经执行完生命周期中最重要的部分了,此刻正是切换给其他任务执行一段时间的大好时机”<br>    <em>线程调度器</em>(Java线程机制的一部分,可以将CPU从一个线程转移给另一个线程)</p><p>其他理解:<br>让当前线程回到可执行状态,以便让具有相同优先级的线程进入执行状态,但不是绝对的。因为虚拟机可能会让该线程重新进入执行状态。</p><p>简单理解就是我重要的事干完了,我可以让出cpu给其他线程(相同优先级).</p><blockquote><p>补充:锁也没有被释放  </p></blockquote><h2 id="wait"><a href="#wait" class="headerlink" title="wait)"></a><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#wait(" target="_blank" rel="noopener">wait</a>)</h2><p>看下Java文档怎么说:  </p><blockquote><p>Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object.<br> In other words, this method behaves exactly as if it simply performs the call wait(0).</p></blockquote><blockquote><p>The current thread must own this object’s monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object’s monitor to wake up either through a call to the notify method or the notifyAll method.</p></blockquote><blockquote><p>The thread then waits until it can re-obtain ownership of the monitor and resumes execution.<br>As in the one argument version, interrupts and spurious wakeups are possible, and this method should always be used in a loop:<br>This method should only be called by a thread that is the owner of this object’s monitor.</p></blockquote><ol><li>当前线程必须拥有这个对象的<code>monitor</code>,当前线程会释放该<code>monitor</code>的拥有权,并且等到别的线程(正在等待这个对象的<code>monitor</code>)调用notify或者notifyAll来唤醒它.  </li><li>wait方法应该被用于一个循环里.</li><li>必须拥有该对象的<code>monitor</code>,否则会报错–IllegalMonitorStateException</li></ol><blockquote><p>补充: wait会释放锁</p></blockquote><p>实例,HandlerThread:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mLooper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>IllegalMonitorStateException例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> open = <span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">//这样会报错</span></span><br><span class="line">        <span class="keyword">while</span> (!open) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>报错日志:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"Thread-0"</span> java<span class="selector-class">.lang</span><span class="selector-class">.IllegalMonitorStateException</span></span><br><span class="line">at java<span class="selector-class">.lang</span><span class="selector-class">.Object</span><span class="selector-class">.wait</span>(Native Method)</span><br><span class="line">at java<span class="selector-class">.lang</span><span class="selector-class">.Object</span><span class="selector-class">.wait</span>(Object<span class="selector-class">.java</span>:<span class="number">502</span>)</span><br><span class="line">at com<span class="selector-class">.example</span><span class="selector-class">.concurrent</span><span class="selector-class">.WaitNotify</span><span class="selector-class">.test</span>(WaitNotify<span class="selector-class">.java</span>:<span class="number">64</span>)</span><br><span class="line">at com<span class="selector-class">.example</span><span class="selector-class">.concurrent</span><span class="selector-class">.WaitNotify</span>$<span class="number">1</span>.run(WaitNotify<span class="selector-class">.java</span>:<span class="number">81</span>)</span><br><span class="line">at java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread<span class="selector-class">.java</span>:<span class="number">745</span>)</span><br></pre></td></tr></table></figure></p><h2 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify,notifyAll"></a>notify,notifyAll</h2><h3 id="notify"><a href="#notify" class="headerlink" title="notify)"></a><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#notify(" target="_blank" rel="noopener">notify</a>)</h3><blockquote><p>Wakes up a single thread that is waiting on this object’s monitor.<br>If any threads are waiting on this object, one of them is chosen to be awakened.<br>The choice is arbitrary and occurs at the discretion of the implementation.<br>A thread waits on an object’s monitor by calling one of the wait methods.<br>The awakened thread will not be able to proceed until the current thread relinquishes the lock on this object.<br>The awakened thread will compete in the usual manner with any other threads that might be actively competing to synchronize on this object;<br>for example, the awakened thread enjoys no reliable privilege or disadvantage in being the next thread to lock this object.</p></blockquote><p>This method should only be called by a thread that is the owner of this object’s monitor. A thread becomes the owner of the object’s monitor in one of three ways:</p><ol><li>By executing a synchronized instance method of that object.</li><li>By executing the body of a synchronized statement that synchronizes on the object.</li><li>For objects of type Class, by executing a synchronized static method of that class.</li></ol><p>Only one thread at a time can own an object’s monitor.</p><p>理解:</p><ol><li>唤醒一个等待这个对象的<code>monitor</code>的线程</li><li>这个选择是随意的</li><li>这个被唤醒的线程不能执行直到当前线程交出对象锁</li><li>这个机会是需要线程去争取的</li><li>这个方法跟前面的wait一样,也需要拥有这个对象的<code>monitor</code></li></ol><p>一个线程可以有三种方法拿到对象的<code>monitor</code>:</p><ol><li>正在执行该对象的同步方法</li><li>正在执行锁住该<em>对象</em>的同步块(synchronized 代码块)</li><li>正在执行锁住该<em>类</em>的静态方法</li></ol><h3 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll"></a>notifyAll</h3><p>跟notify作用一样,当时notify唤醒的只是一个线程,而notifyAll唤醒的是所有.</p><h3 id="Android中线程的比较"><a href="#Android中线程的比较" class="headerlink" title="Android中线程的比较:"></a>Android中线程的比较:</h3><p><img src="http://ww3.sinaimg.cn/large/98900c07gw1ezfbdx79onj20fh0l80vb.jpg" alt="对比"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>线程除了用户线程外还有一种叫做<code>守护线程</code>,可以通过<code>setDaemon(boolean isDaemon)</code>来设置</p><p>守护线程和用户线程的区别在于：<br><strong>守护线程依赖于创建它的线程，而用户线程则不依赖</strong>  </p><p>举个简单的例子:<br>如果在main线程中创建了一个守护线程,当main方法运行完毕之后,守护线程也会随着消亡,而用户线程则不会,用户线程会一直运行直到其运行完毕。<br>不过一般我们也不会用到守护线程.  </p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ol><li>Thinking in Java</li><li><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a></li><li><a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html" target="_blank" rel="noopener">Thread</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava操作符续</title>
      <link href="/blog/b70fedec.html"/>
      <url>/blog/b70fedec.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RxJava处理数据主要还是靠不同的操作符,在这里对RxJava比较常用的操作符做必要的介绍,附加一些自己的理解.  </p><p>操作符有难有易,部分操作符非常简单容易理解,只记录些许文字<br>部分操作符复杂,可能会配有弹珠图,它十分有助于对操作符的理解,而理解弹珠图,前提是知道每个元素的意义,特给出下图:</p><p><img src="http://ww4.sinaimg.cn/large/98900c07gw1ez2pk9gxwhj20xm0fugrr.jpg" alt="一定要理解">  </p><p>OK,准备就绪,开启RxJava操作符之旅吧!  </p><a id="more"></a><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>这里指的是Observable的创建</p><h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><pre><code>使用一个函数从头创建一个Observable</code></pre><p>从头创建意味着<code>onNext</code> <code>onCompleted</code> <code>onError</code>都需要我们自己调用.</p><p>定制度最高,也最麻烦,需要时刻判断<code>observer.isUnsubscribed()</code>来判断是否继续处理发射数据.  </p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><pre><code>只有当订阅者订阅才创建Observable；为每个订阅创建一个新的Observable</code></pre><p>当被订阅时,为每个订阅创建一个新的Observable,所以defer可以确保Observable包含最新的数据。</p><h3 id="from"><a href="#from" class="headerlink" title="from"></a>from</h3><pre><code>将一个Iterable, 一个Future, 或者一个数组转换成一个Observable</code></pre><p>from操作符可以转换Future、Iterable和数组。对于Iterable和数组，产生的Observable会发射Iterable或数组的每一项数据</p><p>相对于<code>create</code>,<code>defer</code>,from生成Observable非常方便,加上iterable和数组在Java中的使用率,使得from出场的频率非常高!</p><h3 id="just"><a href="#just" class="headerlink" title="just"></a>just</h3><p>  将一个或多个对象转换成发射这个或这些对象的一个Observable,很方便</p><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>  创建一个发射指定范围的整数序列的Observable</p><ul><li>range(int start,int count)</li><li>range(int,int,Scheduler)</li></ul><p><code>range(3,10)</code>表示从3开始,发射10个数字,即3,4,5….12</p><h3 id="interval"><a href="#interval" class="headerlink" title="interval"></a>interval</h3><p>  创建一个按照给定的时间间隔发射整数序列的Observable</p><ul><li><code>interval(long,TimeUnit)</code></li><li><code>interval(long,TimeUnit,Scheduler)</code></li></ul><p>默认在<code>computation</code>调度器上</p><h3 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h3><p>  创建一个在给定的延时之后发射单个数据的Observable</p><h3 id="empty-never-throw"><a href="#empty-never-throw" class="headerlink" title="empty/never/throw"></a>empty/never/throw</h3><ul><li>empty 创建一个什么都不做直接通知完成的Observable</li><li>throw  创建一个什么都不做直接通知错误的Observable</li><li><p>never 创建一个不发射任何数据的Observable</p><p>暂时没有用到过</p></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>就创建Observable而言,<code>from</code>,<code>just</code>,<code>defer</code>,<code>create</code>用得多一些,一般来讲掌握这几个即可.</p><h2 id="变换操作"><a href="#变换操作" class="headerlink" title="变换操作"></a>变换操作</h2><p>变换是RxJava处理数据最强大的部分,一定要理解,要活用  </p><h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><ul><li><code>buffer(int count)</code></li><li><code>buffer(int count,int skip)</code></li></ul><p>buffer是将数据缓存成一个List,再发送</p><ul><li>count 集合数量的的大小</li><li>skip 每次发射后扔掉数据的个数(看后面例子好理解一些)</li></ul><p>举例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>).buffer(<span class="number">3</span>).subscribe(subscriber);</span><br></pre></td></tr></table></figure></p><p>其实buffer(count)调用的是buffer(count,count)!,所以默认不填,skip=count</p><p>结果:<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span>Next:[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">on</span>Next:[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">on</span>Next:[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">on</span>Next:[<span class="number">10</span>]</span><br><span class="line"><span class="keyword">on</span>Completed</span><br></pre></td></tr></table></figure></p><p>skip值为1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>).buffer(<span class="number">3</span>,<span class="number">1</span>).subscribe(subscriber);</span><br></pre></td></tr></table></figure><p>结果:<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span>Next:[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">on</span>Next:[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">on</span>Next:[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">on</span>Next:[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">on</span>Next:[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">on</span>Next:[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">on</span>Next:[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">on</span>Next:[<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">on</span>Next:[<span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">on</span>Next:[<span class="number">10</span>]</span><br><span class="line"><span class="keyword">on</span>Completed</span><br></pre></td></tr></table></figure></p><p>解释:<br>每次缓存了3个,再skip掉第1个,再等凑够3个,再发送,再skip掉1个,如此循环,直至结束.</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>过滤,过滤掉不需要的数据</p><h3 id="single"><a href="#single" class="headerlink" title="single"></a><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Single.html" target="_blank" rel="noopener">single</a></h3><p>Single类似于Observable，不同的是，它总是只发射一个值，或者一个错误通知，而不是发射一系列的值。<br>因此，不同于Observable需要三个方法onNext, onError, onCompleted，订阅Single只需要两个方法：</p><ul><li>onSuccess - Single发射单个的值到这个方法</li><li>onError - 如果无法发射需要的值，Single发射一个Throwable对象到这个方法  </li></ul><p>Single只会调用这两个方法中的一个，而且只会调用一次，调用了任何一个方法之后，订阅关系终止。</p><p>single 和 filter差不多，但如果为0会报错进入onError</p><h3 id="first"><a href="#first" class="headerlink" title="first"></a>first</h3><h3 id="tosortlist"><a href="#tosortlist" class="headerlink" title="tosortlist"></a>tosortlist</h3><h3 id="defer-1"><a href="#defer-1" class="headerlink" title="defer"></a>defer</h3><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><h3 id="throttleFirst"><a href="#throttleFirst" class="headerlink" title="throttleFirst"></a>throttleFirst</h3><p>放抖动</p><h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p>去重</p><h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><h3 id="doOnNext"><a href="#doOnNext" class="headerlink" title="doOnNext"></a>doOnNext</h3><h3 id="finallyDo"><a href="#finallyDo" class="headerlink" title="finallyDo"></a>finallyDo</h3><h3 id="contact"><a href="#contact" class="headerlink" title="contact"></a>contact</h3><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>了解“热”和“冷”的Observable</p><h2 id="资料-推荐"><a href="#资料-推荐" class="headerlink" title="资料/推荐"></a>资料/推荐</h2><p><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/" target="_blank" rel="noopener">RxDocs-content</a><br><a href="https://github.com/mcxiaoke/RxDocs" target="_blank" rel="noopener">RxDocs</a><br><a href="http://blog.csdn.net/lzyzsd/article/details/50120801#0-tsina-1-39222-397232819ff9a47a7b7e80a40613cfe1" target="_blank" rel="noopener">RxJava使用场景小结</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RxJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Twitter相关功能集成</title>
      <link href="/blog/ab3e3f9e.html"/>
      <url>/blog/ab3e3f9e.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>app 未来可能有要往国外推的需求,需要做<a href="https://developers.facebook.com/" target="_blank" rel="noopener">Facebook</a>,Twitter登录,FB用umeng搞定了部分,剩下Twitter需要自己做.</p><h2 id="Create-App"><a href="#Create-App" class="headerlink" title="Create-App"></a><a href="https://apps.twitter.com/app/new" target="_blank" rel="noopener">Create-App</a></h2><p>前提是你有账号,去注册<a href="https://twitter.com/" target="_blank" rel="noopener">Twitter</a><br>Twitter<a href="https://dev.twitter.com" target="_blank" rel="noopener">开发者平台</a>创建开发者账号    </p><p>这里有个很难搞的坑,就是创建应用需要添加手机号,否则你会得到以下错误:  </p><blockquote><p>Error<br>You must add your mobile phone to your Twitter profile before creating an application. Please read <a href="https://support.twitter.com/articles/110250-adding-your-mobile-number-to-your-account-via-web" target="_blank" rel="noopener">https://support.twitter.com/articles/110250-adding-your-mobile-number-to-your-account-via-web</a> for more information.</p></blockquote><p>但是令人发指的是,Twitter又不支持中国大陆+86的手机,遇到这个问题后瞬间整个人就不好了…<br>但是还是得完成啊,于是百般搜索,寻找解决方案,无果.<br>最后给twitter support(<a href="mailto:support@twitter.com" target="_blank" rel="noopener">support@twitter.com</a>)发了邮件,最终,人家给我开通了时间有限的权限.<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thank you <span class="keyword">for</span> reaching out. We’re aware that you are <span class="keyword">not</span> able <span class="keyword">to</span> register a mobile phone number <span class="keyword">to</span> your account. We have enabled access <span class="keyword">for</span> you <span class="keyword">to</span> create an app without doing so. Please<span class="built_in"> note </span>that this access will expire 7 days <span class="keyword">from</span> the date of this email, so you must create your app within this time frame.</span><br><span class="line"></span><br><span class="line"><span class="keyword">While</span> developing your application, please review our Developer Agreement <span class="keyword">and</span><span class="built_in"> Policy </span><span class="keyword">to</span> ensure that your application is compliant with our Rules.</span><br><span class="line"></span><br><span class="line">Regards,</span><br><span class="line">ElliotSamuelson</span><br><span class="line">Twitter Platform Operations</span><br></pre></td></tr></table></figure></p><p>finally,我可以创建应用了.</p><a id="more"></a><h2 id="Fabric"><a href="#Fabric" class="headerlink" title="Fabric"></a><a href="https://get.fabric.io/twitter-login?locale=zh-cn" target="_blank" rel="noopener">Fabric</a></h2><p>Twitter弄了个叫Fabric的插件,AS可用.<br>它会帮忙设置项目,帮忙生成很多必要的代码文件,挺繁琐的,这里省略了,因为已经弄完了,不想再搞了.</p><p>大致记录一些,不全,具体看我Github.<br>build.gradle文件:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span>(<span class="string">'com.twitter.sdk.android:twitter:1.8.0@aar'</span>) &#123;</span><br><span class="line">    transitive = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">compile</span>(<span class="string">'com.twitter.sdk.android:tweet-composer:0.9.0@aar'</span>) &#123;</span><br><span class="line">    transitive = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        maven &#123; url <span class="string">'https://maven.fabric.io/public'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">'io.fabric.tools:gradle:1.+'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line">apply plugin: <span class="string">'io.fabric'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    maven &#123; url <span class="string">'https://maven.fabric.io/public'</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>APP:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: Your consumer key and secret should be obfuscated in your source code before shipping.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TWITTER_KEY = <span class="string">"RJjbqTVS5kIseg9q4jsRecf7u"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TWITTER_SECRET = <span class="string">"dbBgVZYA4oBkmSr5jKaInMzijO2mt3uB82SHviTJ1tgK2Z5P8E"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        TwitterAuthConfig authConfig = <span class="keyword">new</span> TwitterAuthConfig(TWITTER_KEY, TWITTER_SECRET);</span><br><span class="line"><span class="comment">//        Fabric.with(this, new TwitterCore(authConfig), new Digits());</span></span><br><span class="line">        Fabric.with(<span class="keyword">this</span>, <span class="keyword">new</span> TwitterCore(authConfig),<span class="keyword">new</span> TweetComposer());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>集成完后,开始写代码.<br>    PS:个人非常讨厌Twitter这种方式,而且搞的AS编译时间非常非常久,夸张的时候1个小时都没成功,不知道什么坑.</p><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><h3 id="最简单的方式"><a href="#最简单的方式" class="headerlink" title="最简单的方式"></a>最简单的方式</h3><p>使用推特提供的<code>TwitterLoginButton</code>,自带UI效果</p><ol><li>配置xml<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.twitter.sdk.android.core.identity.TwitterLoginButton</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/btn_twitter"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="http://ww2.sinaimg.cn/large/98900c07gw1ex1w34v2tjj208701lwed.jpg" alt="效果"></p><ol start="2"><li><p>代码里设置监听回调<br>调用<code>TwitterLoginButton.setCallback</code>即可监听,不需要设置点击事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUpTwitterButton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mBtnTwitter.setCallback(<span class="keyword">new</span> Callback&lt;TwitterSession&gt;() &#123;<span class="comment">//userName alancheen06   secret  4H6cMSpc59EbLSlcQ5QI0SzAUXAAZnxDZ40KUqQkJkl7s  token 3313987080-L3UPicTGjEZrNjpjsobeDQRCbWGFyczUCV2O408</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(Result&lt;TwitterSession&gt; result)</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"Twitter"</span>, <span class="string">"success() called with: "</span> + <span class="string">"result = ["</span> + result + <span class="string">"]++++data"</span> + result.data);</span><br><span class="line"></span><br><span class="line">            String name = result.data.getUserName();</span><br><span class="line">            <span class="keyword">long</span> userId = result.data.getUserId();<span class="comment">//3313987080</span></span><br><span class="line">            <span class="keyword">long</span> id = result.data.getId();</span><br><span class="line">            TwitterAuthToken token = result.data.getAuthToken();</span><br><span class="line">            String secret = token.secret;</span><br><span class="line">            String strToken = token.token;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failure</span><span class="params">(TwitterException exception)</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"Twitter"</span>, <span class="string">"failure() called with: "</span> + <span class="string">"exception = ["</span> + exception.getMessage() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>处理<code>onActivityResult</code></p></li></ol><p>如果有fragment则需要用fragment来处理,否则Activity处理<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mBtnTwitter</span>.onActivityResult(requestCode, resultCode, <span class="class"><span class="keyword">data</span>);//140 requestCode</span></span><br></pre></td></tr></table></figure></p><p><img src="http://ww4.sinaimg.cn/large/98900c07gw1ex1w5a4h04j20be09z0tc.jpg" alt="点击后效果"></p><h4 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h4><p>当手机安装了推特客户端,那么以上代码都没有问题,但是如果没有安装,那么就不能授权!<br>解决办法是去推特开发者后台,把app的setting下的callback url设置一下,不论什么,可以访问即可!</p><p>相关资料–&gt;<a href="https://twittercommunity.com/t/failed-to-connect-to-twitter-api-using-twitterkit-on-android/29182/5" target="_blank" rel="noopener">戳这里</a></p><h3 id="自定义UI"><a href="#自定义UI" class="headerlink" title="自定义UI"></a>自定义UI</h3><p>但是我的需求不能使用推特提供的UI,不过貌似没看到哪里文档有提,不过幸好自己摸索出了如下方法.</p><p>其实说白了就是掰了一些<code>TwitterLoginButton</code>里的源码<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mTvCustom.setOnClickListener(v -&gt; &#123;</span><br><span class="line">    <span class="keyword">new</span> TwitterAuthClient().authorize(TwitterActivity.<span class="keyword">this</span>, <span class="keyword">new</span> Callback&lt;TwitterSession&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">success</span><span class="params">(Result&lt;TwitterSession&gt; result)</span> </span>&#123;</span><br><span class="line">            String name = result.data.getUserName();</span><br><span class="line">            <span class="keyword">long</span> userId = result.data.getUserId();<span class="comment">//3313987080</span></span><br><span class="line">            <span class="keyword">long</span> id = result.data.getId();</span><br><span class="line">            TwitterAuthToken token = result.data.getAuthToken();</span><br><span class="line">            String secret = token.secret;</span><br><span class="line">            String strToken = token.token;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">failure</span><span class="params">(TwitterException e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="获取更多信息"><a href="#获取更多信息" class="headerlink" title="获取更多信息"></a>获取更多信息</h2><p>从上文也能看出来,我们只能获取一个<code>name</code>严格来说是<code>screen_name</code>,另外一个是<code>userId</code>,而我还需要头像等信息.<br>于是,还得接下去搞.<br>其实过程异常痛苦,因为推特并没有给出详细的例子,自己也没有弄清楚<code>oauth</code>,找了老半天也没有详细的文档,不过最后还是被我弄出来了.  </p><p>这里直接给代码了,无非就是拿<code>token</code>去获取数据:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">  * &#123;"id":3313987080,"id_str":"3313987080","name":"\u7a0b\u5e8f\u4ea6\u975e\u733fAlan","screen_name":"alancheen06","location":"","profile_location":null,"description":"An android developer from China.","url":null,"entities":&#123;"description":&#123;"urls":[]&#125;&#125;,"protected":false,"followers_count":1,"friends_count":34,"listed_count":0,"created_at":"Thu Aug 13 05:29:54 +0000 2015","favourites_count":2,"utc_offset":-25200,"time_zone":"Pacific Time (US &amp; Canada)","geo_enabled":false,"verified":false,"statuses_count":13,"lang":"en","status":&#123;"created_at":"Mon Oct 12 04:23:09 +0000 2015","id":653425648577286144,"id_str":"653425648577286144","text":"<span class="doctag">@Support</span> How to add phone num?Thanks a lot!","source":"\u003ca href=\"http:\/\/twitter.com\" rel=\"nofollow\"\u003eTwitter Web Client\u003c\/a\u003e","truncated":false,"in_reply_to_status_id":null,"in_reply_to_status_id_str":null,"in_reply_to_user_id":17874544,"in_reply_to_user_id_str":"17874544","in_reply_to_screen_name":"Support","geo":null,"coordinates":null,"place":null,"contributors":null,"retweet_count":0,"favorite_count":1,"entities":&#123;"hashtags":[],"symbols":[],"user_mentions":[&#123;"screen_name":"Support","name":"Twitter Support","id":17874544,"id_str":"17874544","indices":[0,8]&#125;],"urls":[]&#125;,"favorited":false,"retweeted":false,"lang":"en"&#125;,"contributors_enabled":false,"is_translator":false,"is_translation_enabled":false,"profile_background_color":"C0DEED","profile_background_image_url":"http:\/\/abs.twimg.com\/images\/themes\/theme1\/bg.png","profile_background_image_url_https":"https:\/\/abs.twimg.com\/images\/themes\/theme1\/bg.png","profile_background_tile":false,"profile_image_url":"http:\/\/pbs.twimg.com\/profile_images\/631699830872498176\/yThxaLUe_normal.jpg","profile_image_url_https":"https:\/\/pbs.twimg.com\/profile_images\/631699830872498176\/yThxaLUe_normal.jpg","profile_link_color":"0084B4","profile_sidebar_border_color":"C0DEED","profile_sidebar_fill_color":"DDEEF6","profile_text_color":"333333","profile_use_background_image":true,"has_extended_profile":false,"default_profile":true,"default_profile_image":false,"following":false,"follow_request_sent":false,"notifications":false&#125;</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">(<span class="keyword">final</span> TwitterAuthToken token)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             TwitterAuthConfig authConfig = TwitterCore.getInstance().getAuthConfig();</span><br><span class="line">             OAuthSigning oauthSigning = <span class="keyword">new</span> OAuthSigning(authConfig, token);</span><br><span class="line">             Map&lt;String, String&gt; authHeaders = oauthSigning.getOAuthEchoHeadersForVerifyCredentials();</span><br><span class="line">             URL url = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                    url = new URL("https://api.twitter.com/1.1/users/show.json?");</span></span><br><span class="line">                 url = <span class="keyword">new</span> URL(<span class="string">"https://api.twitter.com/1.1/users/show.json?screen_name=alancheen06&amp;user_id=3313987080"</span>);</span><br><span class="line"><span class="comment">//                    url = new URL("http://api.yourbackend.com/check_credentials.json");</span></span><br><span class="line">                 HttpURLConnection conn = (HttpsURLConnection) url.openConnection();</span><br><span class="line">                 conn.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line"><span class="comment">//                    for (Map.Entry&lt;String, String&gt; entry : authHeaders.entrySet()) &#123;</span></span><br><span class="line"><span class="comment">//                        connection.setRequestProperty(entry.getKey(), entry.getValue());</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                    connection.addRequestProperty("Authorization","OAuth oauth_consumer_key=\"7Ud4sn002Jquc6hR6XFREEqds\", oauth_nonce=\"456e1966e1db379f36f1ea9551ce0ad8\", oauth_signature=\"QWGBWcurKrLd5RvtDwjzmqtasBc%3D\", oauth_signature_method=\"HMAC-SHA1\", oauth_timestamp=\"1444727699\", oauth_token=\"3313987080-h6f0ecdEc100MCQjpKyTuiNVakj6nZ0bdV2HvUw\", oauth_version=\"1.0\"");</span></span><br><span class="line"></span><br><span class="line">                 Map&lt;String, String&gt; par = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">                 par.put(<span class="string">"screen_name"</span>, <span class="string">"alancheen06"</span>);</span><br><span class="line">                 par.put(<span class="string">"user_id"</span>, <span class="string">"3313987080"</span>);</span><br><span class="line">                 OAuth1aService.signRequest(authConfig, token, conn, par);</span><br><span class="line"></span><br><span class="line">                 conn.connect();</span><br><span class="line">                 <span class="keyword">int</span> status = conn.getResponseCode();</span><br><span class="line">                 <span class="comment">//得到读取的内容(流)</span></span><br><span class="line">                 InputStreamReader in = <span class="keyword">new</span> InputStreamReader(conn.getInputStream());</span><br><span class="line">                 <span class="comment">// 为输出创建BufferedReader</span></span><br><span class="line">                 BufferedReader buffer = <span class="keyword">new</span> BufferedReader(in);</span><br><span class="line">                 String inputLine = <span class="keyword">null</span>;</span><br><span class="line">                 String resultData = <span class="string">""</span>;</span><br><span class="line">                 <span class="comment">//使用循环来读取获得的数据</span></span><br><span class="line">                 <span class="keyword">while</span> (((inputLine = buffer.readLine()) != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                     <span class="comment">//我们在每一行后面加上一个"\n"来换行</span></span><br><span class="line">                     resultData += inputLine + <span class="string">"\n"</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 JSONObject jo = <span class="keyword">new</span> JSONObject(resultData);</span><br><span class="line">                 String imgUrl = jo.getString(<span class="string">"profile_image_url"</span>);</span><br><span class="line">                 Log.d(<span class="string">"Twitter"</span>, <span class="string">"run: resultData"</span> + resultData);</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">final</span> String aa = resultData;</span><br><span class="line">                 runOnUiThread(()-&gt;mTvInfo.setText(aa));</span><br><span class="line">             &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (ProtocolException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;).start();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="Twitter分享"><a href="#Twitter分享" class="headerlink" title="Twitter分享"></a>Twitter分享</h2><p>既然登录做了,那么分享也是需要的~  </p><p>分享相对来说简单多了,只是需要注意<strong>推特分享图片只能是本地文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TweetComposer.Builder builder = <span class="keyword">new</span> TweetComposer.Builder(context)</span><br><span class="line">        .text(content)</span><br><span class="line">        .image(fileUri)</span><br><span class="line">        .url(url);</span><br><span class="line">builder.show();</span><br></pre></td></tr></table></figure><p>稍微解释一下参数:</p><ol><li>.text(String) 是发推的文本</li><li>.image(Uri imageUri) 上面提过是因为只支持本地文件一般<code>Uri.fromFile(file)</code>即可</li><li>.url(URL url)) 这个是网页链接,就是别人点击后跳转的地方,会出现在推文里.</li></ol><p><img src="http://ww2.sinaimg.cn/large/98900c07gw1ex1xprbyb7j207r0dp3zj.jpg" alt="分享效果"></p><h2 id="分享结果处理"><a href="#分享结果处理" class="headerlink" title="分享结果处理"></a>分享结果处理</h2><p>上面提供的方法接收不到推特分享的结果,看了一下TweetComposer.Builder的源码后想出来了:<br><code>builder.createIntent()</code>可以创建一个intent,然后自己调用<code>startActivityForResult</code>,重写<code>onActivityResult</code>来接受结果即可.<br>需要注意的是这样context的类型必须是activity了.  </p><p>机智如我,搞定~  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>做推特的功能大概花费了2天的时间,第一步添加手机号码的确实让我崩溃,后面也不顺利,但是幸好还是完成了功能~<br>另外也感慨一下自己的英文实在是烂,全英文的文档实在吃不消.<br>感谢Umeng集成了那么多第三方登录,分享功能,自己做真的累.    </p><p>希望能给现在有需要or未来需要的人一些参考吧,就这样.    </p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://dev.twitter.com/rest/tools/console" target="_blank" rel="noopener">API Console Tool</a><br><a href="https://docs.fabric.io/android/twitter/authentication.html" target="_blank" rel="noopener">Log in with Twitter</a><br><a href="https://docs.fabric.io/android/examples/cannonball/index.html#sign-in-with-twitter" target="_blank" rel="noopener">SignIn-with-Twitter</a><br><a href="https://docs.fabric.io/android/twitter/configure-twitter-app.html" target="_blank" rel="noopener">文档</a><br><a href="https://dev.twitter.com/rest/reference/get/statuses/lookup" target="_blank" rel="noopener">API</a><br><a href="https://github.com/twitterdev/cannonball-android" target="_blank" rel="noopener">cannonball-android</a><br><a href="https://play.google.com/store/apps/details?id=io.fabric.samples.cannonball" target="_blank" rel="noopener">示例-app</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Twitter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义View的onMeasure、onLayout</title>
      <link href="/blog/decbd35b.html"/>
      <url>/blog/decbd35b.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自定义View有几个非常重要的流程:  </p><ol><li>onFinishInflate()</li><li>onAttachedToWindow()</li><li>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</li><li>onLayout(boolean changed, int l, int t, int r, int b)</li><li>onDraw(Canvas canvas)</li><li>onDetachedFromWindow()</li></ol><p>这里来学习一下onMeasure(重点讲),onLayout(大致了解),另外这里也侧重<a href="http://developer.android.com/intl/zh-cn/reference/android/view/ViewGroup.html" target="_blank" rel="noopener">ViewGroup</a>,因为vp比较难,如果把vp弄懂了,view应该也不在话下.</p><p>先讲几个知识点:  </p><ol><li>onMeasure 负责测量大小,如果是View则测量自己,如果是ViewGroup则测量子View和自己.  </li><li>onMeasure 最终需要调用<code>setMeasuredDimension(int measuredWidth, int measuredHeight)</code>设置大小.</li><li>onMeasure后,严格来说是<code>setMeasuredDimension</code>调用后,可以通过<code>getMeasuredHeight()</code>,<code>getMeasuredWidth()</code>获得测量的宽高</li><li>onLayout 负责布局,即把子View放在哪里.  </li><li>onLayout 后可以调用<code>getWidth</code>,<code>getHeight</code>获取宽高,与之前的<code>getMeasuredXXX</code>不同,他们可能不相等.  </li><li>onMeasure onLayout 都可能执行很多次.</li></ol><a id="more"></a><h2 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a><a href="http://developer.android.com/intl/zh-cn/reference/android/view/View.MeasureSpec.html" target="_blank" rel="noopener">MeasureSpec</a></h2><p>而测量我们需要<code>MeasureSpec</code>来帮助,它字面意思就是测量规则,它包括测量模式以及大小,它是一个32位的int值,它的<code>高2位</code>是测量的模式,<code>低30位</code>是测量的大小.</p><ul><li>模式可以通过<code>MeasureSpec.getMode(int measureSpec)</code>获得</li><li>大小可以通过<code>MeasureSpec.getSize(int measureSpec)</code>获得</li></ul><h3 id="测量模式"><a href="#测量模式" class="headerlink" title="测量模式"></a>测量模式</h3><p>模式有三种:  </p><ol><li>MeasureSpec.EXACTLY</li><li>MeasureSpec.AT_MOST</li><li>MeasureSpec.UNSPECIFIED  </li></ol><h4 id="EXACTLY-精确模式"><a href="#EXACTLY-精确模式" class="headerlink" title="EXACTLY(精确模式)"></a>EXACTLY(精确模式)</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* The parent has determined an exact size <span class="keyword">for</span> <span class="keyword">the</span> child. The child <span class="keyword">is</span> going <span class="keyword">to</span> be</span><br><span class="line">* <span class="keyword">given</span> those bounds regardless <span class="keyword">of</span> how big <span class="keyword">it</span> wants <span class="keyword">to</span> be.</span><br></pre></td></tr></table></figure><p>EXACTLY值为:0  </p><p>父View告诉你,你应该多少大小.<br>当XMl里的宽高属性为<code>具体值</code>或者为<code>match_parent</code>,为EXACTLY.  </p><p>例:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:layout_width="200dp"</span><br><span class="line">android:layout_height="match_parent"</span><br></pre></td></tr></table></figure></p><h4 id="AT-MOST-至多模式"><a href="#AT-MOST-至多模式" class="headerlink" title="AT_MOST(至多模式)"></a>AT_MOST(至多模式)</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* The child can be <span class="keyword">as</span> large <span class="keyword">as</span> <span class="keyword">it</span> wants up <span class="built_in">to</span> <span class="keyword">the</span> specified size.</span><br></pre></td></tr></table></figure><p>AT_MOST值为:-2147483648</p><p>子控件大小最多为多少,在xml里配置的属性为<code>wrap_content</code>的时候.</p><p><strong>如果自定义View要支持wrap_content必须重写onMeasure,否则大小可能为0</strong></p><h4 id="UNSPECIFIED-不指定模式"><a href="#UNSPECIFIED-不指定模式" class="headerlink" title="UNSPECIFIED(不指定模式)"></a>UNSPECIFIED(不指定模式)</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* The parent has <span class="keyword">not</span> imposed <span class="keyword">any</span> constraint <span class="keyword">on</span> <span class="title">the</span> <span class="title">child</span>. <span class="title">It</span> <span class="title">can</span> <span class="title">be</span> <span class="title">whatever</span> <span class="title">size</span></span><br><span class="line">* <span class="keyword">it</span> wants.</span><br></pre></td></tr></table></figure><p>值为 1073741824<br>想多大多大,一般见不到,一般自定义View才用.</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>新建一个ViewGroup,重写onMeasure并打印日志.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewGroup</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">      logModeAndSize(widthMeasureSpec);</span><br><span class="line">      logModeAndSize(heightMeasureSpec);</span><br><span class="line">      Log.d(TAG, <span class="string">"onMeasure: height"</span>+getMeasuredHeight()+<span class="string">";width:"</span>+getMeasuredWidth());</span><br><span class="line"></span><br><span class="line">  &#125;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印测量模式和大小</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logModeAndSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (MeasureSpec.getMode(measureSpec)) &#123;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">            Log.d(TAG, <span class="string">"UNSPECIFIED: "</span>+MeasureSpec.getSize(measureSpec));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">            Log.d(TAG, <span class="string">"AT_MOST: "</span>+MeasureSpec.getSize(measureSpec));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            Log.d(TAG, <span class="string">"EXACTLY: "</span>+MeasureSpec.getSize(measureSpec));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>测试<code>match_parent</code>和<code>wrap_content</code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">yifeiyuan.practice.practicedemos.customview.MyViewGroup</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>得到日志:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D/<span class="string">MyViewGroup:</span> <span class="string">EXACTLY:</span> <span class="number">1080</span></span><br><span class="line">D/<span class="string">MyViewGroup:</span> <span class="string">AT_MOST:</span> <span class="number">1692</span></span><br><span class="line">D/<span class="string">MyViewGroup:</span> <span class="string">onMeasure:</span> height1692;<span class="string">width:</span><span class="number">1080</span></span><br></pre></td></tr></table></figure></p><p>可以看到<code>match_parent</code>对应模式是EXACTLY<br><code>wrap_content</code>对应模式是AT_MOST</p><p>顺带一提,如果是继承View,在这里的效果也是一样的.  </p><p>然而,如果继承LinearLayout,效果则不一样,可以看到测量后,高度为0了<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D/<span class="string">MyViewGroup:</span> <span class="string">EXACTLY:</span> <span class="number">1080</span></span><br><span class="line">D/<span class="string">MyViewGroup:</span> <span class="string">AT_MOST:</span> <span class="number">1692</span></span><br><span class="line">D/<span class="string">MyViewGroup:</span> <span class="string">onMeasure:</span> height0;<span class="string">width:</span><span class="number">1080</span></span><br></pre></td></tr></table></figure></p><ol start="2"><li>接下去测试具体值<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">yifeiyuan.practice.practicedemos.customview.MyViewGroup</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"400dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"#00ff00"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>log:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D/<span class="string">MyViewGroup:</span> <span class="string">EXACTLY:</span> <span class="number">1200</span></span><br><span class="line">D/<span class="string">MyViewGroup:</span> <span class="string">AT_MOST:</span> <span class="number">1692</span></span><br><span class="line">D/<span class="string">MyViewGroup:</span> <span class="string">onMeasure:</span> height1692;<span class="string">width:</span><span class="number">1200</span></span><br></pre></td></tr></table></figure></p><p>可以看到具体值对应EXACTLY模式,这里View和ViewGroup也是一样.  </p><h3 id="测量方法"><a href="#测量方法" class="headerlink" title="测量方法"></a>测量方法</h3><p>知道测量的规则后,其实可以得出比较模板化的代码:</p><ol><li><p>适用于自定义View:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">measureWidth</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> size = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> mode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">if</span> (mode == MeasureSpec.EXACTLY)&#123;</span><br><span class="line">        result = size;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = <span class="number">100</span>;<span class="comment">// 实际上需要自己计算</span></span><br><span class="line">        <span class="keyword">if</span> (mode==MeasureSpec.AT_MOST)&#123;</span><br><span class="line">            <span class="comment">//至多模式,别超过了</span></span><br><span class="line">            result = Math.min(result, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ViewGroup<br>如果是自定义ViewGroup,那就各有不同了,每个ViewGroup都不一样,不过大致流程也差不多,就是测量子View再决定自己的大小.  </p></li></ol><p>简单的例子如下,把所有子View的高度之和当做自己的高度:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> childcount = getChildCount();</span><br><span class="line"><span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childcount; i++) &#123;</span><br><span class="line">    View child = getChildAt(i);</span><br><span class="line">    child.measure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    height += child.getMeasuredHeight();</span><br><span class="line">&#125;</span><br><span class="line">setMeasuredDimension(MeasureSpec.getSize(widthMeasureSpec), height);</span><br></pre></td></tr></table></figure></p><p>OK,差不多该知道的知识点也知道了,实践一下</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>实现一个类似垂直的LinearLayout.  </p><h3 id="配置xml"><a href="#配置xml" class="headerlink" title="配置xml"></a>配置xml</h3><p>在xml里引用之前自定义的ViewGroup,并添加几个宽度高度背景色都不一样的View<br>包括<code>wrap_content</code>,<code>match_parent</code>,<code>xxxdp</code>,可见,不可见各种情况.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">yifeiyuan.practice.practicedemos.customview.MyViewGroup</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"300dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"#0000ff"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/tv1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"60dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#88ff33"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"我只是个TextView"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"#ffffff"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"20sp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:background</span>=<span class="string">"#333333"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/tv2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#ff0000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Hello,ViewGroup"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"#ffffff"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"20sp"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/tv3"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"200dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#ee00ee"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Hello,MatchParent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"#ffffff"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"20sp"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/tv4"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#44ff33"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Hello,MatchParent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"#ffffff"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"20sp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:visibility</span>=<span class="string">"gone"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#ff00ff"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Hello,MatchParent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"#ffffff"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"20sp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:visibility</span>=<span class="string">"invisible"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"50dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"20dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#000000"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">yifeiyuan.practice.practicedemos.customview.MyViewGroup</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="重写onMeasure"><a href="#重写onMeasure" class="headerlink" title="重写onMeasure"></a>重写onMeasure</h3><p>主要的思路是根据LayoutParams,给子View生成MeasureSpec规则,去测量各个子View的宽高,最终决定自己的宽高.  </p><p>需要注意的是:记得处理不可见的状态,因为<code>GONE</code>掉的View是没有宽高的,所以跳过它,提高效率.</p><p>Code:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> height = <span class="number">0</span>;<span class="comment">//group的计算高度</span></span><br><span class="line">    <span class="keyword">int</span> width = <span class="number">0</span>;<span class="comment">//宽度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> childcount = getChildCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childcount; i++) &#123;</span><br><span class="line">        View child = getChildAt(i);</span><br><span class="line">        <span class="comment">//gone 的就无视掉</span></span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() == GONE) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LayoutParams lp = child.getLayoutParams();</span><br><span class="line">        <span class="keyword">int</span> widthSpec = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> heightSpec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据LayoutParams,给子View生成MeasureSpec规则</span></span><br><span class="line">        <span class="keyword">if</span> (lp.width == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            widthSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.AT_MOST);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            widthSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其实xml里不会出现这样的情况</span></span><br><span class="line">            widthSpec = MeasureSpec.makeMeasureSpec(lp.width, MeasureSpec.EXACTLY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lp.height == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            heightSpec = MeasureSpec.makeMeasureSpec(heightSize, MeasureSpec.AT_MOST);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            heightSpec = MeasureSpec.makeMeasureSpec(heightSize, MeasureSpec.EXACTLY);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            heightSpec = MeasureSpec.makeMeasureSpec(lp.height, MeasureSpec.EXACTLY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        child.measure(widthSpec, heightSpec);</span><br><span class="line">        <span class="comment">//把所有的子View的高度加起来,就是高度</span></span><br><span class="line">        height += child.getMeasuredHeight();</span><br><span class="line">        <span class="comment">// 拿子View中的最大宽度当自己的宽度,保证所有子View能够显示全</span></span><br><span class="line">        width = Math.max(width, child.getMeasuredWidth());</span><br><span class="line">        Log.d(TAG, <span class="string">"onMeasure: i:"</span> + i + <span class="string">",width:"</span> + child.getMeasuredWidth() + <span class="string">",height:"</span> + child.getMeasuredHeight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再根据父view给自己的spec,处理自己的宽高</span></span><br><span class="line">    <span class="comment">// 这里没有显式处理Unspecified,其实已经计算了宽高,当做UNSPECIFIED的值了</span></span><br><span class="line">    <span class="keyword">if</span> (MeasureSpec.EXACTLY == widthMode) &#123;</span><br><span class="line">        width = widthSize;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (MeasureSpec.AT_MOST == widthMode) &#123;</span><br><span class="line">        width = Math.min(width, widthSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MeasureSpec.EXACTLY == heightMode) &#123;</span><br><span class="line">        height = heightSize;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (MeasureSpec.AT_MOST == heightMode) &#123;</span><br><span class="line">        height = Math.min(height, heightSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一定要记得调用</span></span><br><span class="line">    setMeasuredDimension(width, height);</span><br><span class="line"></span><br><span class="line">    Log.d(TAG, <span class="string">"onMeasure: height"</span> + getMeasuredHeight() + <span class="string">";width:"</span> + getMeasuredWidth());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意:  </p><ol><li>要牢记测量模式与xml属性的对应关系  </li><li>处理View不可见的情况  </li></ol><h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3><p>测量完毕后我们需要布局.<br>onLayout相对简单,只要记录一下总高度,挨个放就行:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childcount = getChildCount();</span><br><span class="line">    <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childcount; i++) &#123;</span><br><span class="line">        View child = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() == GONE) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        child.layout(l,t+height,l+child.getMeasuredWidth(),t+height+child.getMeasuredHeight());</span><br><span class="line">        height += child.getMeasuredHeight();</span><br><span class="line">        Log.d(TAG, <span class="string">"onLayout: i:"</span> + i + <span class="string">",width:"</span> + child.getMeasuredWidth() + <span class="string">",height:"</span> + child.getMeasuredHeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我在onMeasure,onLayout都打印了日志,来看一次循环的日志:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">D/<span class="string">MyViewGroup:</span> <span class="string">onMeasure:</span> <span class="string">i:</span><span class="number">0</span>,<span class="string">width:</span><span class="number">486</span>,<span class="string">height:</span><span class="number">180</span></span><br><span class="line">D/<span class="string">MyViewGroup:</span> <span class="string">onMeasure:</span> <span class="string">i:</span><span class="number">1</span>,<span class="string">width:</span><span class="number">300</span>,<span class="string">height:</span><span class="number">152</span></span><br><span class="line">D/<span class="string">MyViewGroup:</span> <span class="string">onMeasure:</span> <span class="string">i:</span><span class="number">2</span>,<span class="string">width:</span><span class="number">900</span>,<span class="string">height:</span><span class="number">600</span></span><br><span class="line">D/<span class="string">MyViewGroup:</span> <span class="string">onMeasure:</span> <span class="string">i:</span><span class="number">4</span>,<span class="string">width:</span><span class="number">900</span>,<span class="string">height:</span><span class="number">300</span></span><br><span class="line">D/<span class="string">MyViewGroup:</span> <span class="string">onMeasure:</span> <span class="string">i:</span><span class="number">5</span>,<span class="string">width:</span><span class="number">150</span>,<span class="string">height:</span><span class="number">60</span></span><br><span class="line">D/<span class="string">MyViewGroup:</span> <span class="string">onMeasure:</span> height1292;<span class="string">width:</span><span class="number">900</span></span><br><span class="line">D/<span class="string">MyViewGroup:</span> <span class="string">onLayout:</span> <span class="string">i:</span><span class="number">0</span>,<span class="string">width:</span><span class="number">486</span>,<span class="string">height:</span><span class="number">180</span></span><br><span class="line">D/<span class="string">MyViewGroup:</span> <span class="string">onLayout:</span> <span class="string">i:</span><span class="number">1</span>,<span class="string">width:</span><span class="number">300</span>,<span class="string">height:</span><span class="number">152</span></span><br><span class="line">D/<span class="string">MyViewGroup:</span> <span class="string">onLayout:</span> <span class="string">i:</span><span class="number">2</span>,<span class="string">width:</span><span class="number">900</span>,<span class="string">height:</span><span class="number">600</span></span><br><span class="line">D/<span class="string">MyViewGroup:</span> <span class="string">onLayout:</span> <span class="string">i:</span><span class="number">4</span>,<span class="string">width:</span><span class="number">900</span>,<span class="string">height:</span><span class="number">300</span></span><br><span class="line">D/<span class="string">MyViewGroup:</span> <span class="string">onLayout:</span> <span class="string">i:</span><span class="number">5</span>,<span class="string">width:</span><span class="number">150</span>,<span class="string">height:</span><span class="number">60</span></span><br></pre></td></tr></table></figure></p><p>可以看到测量的效果还是符合实际情况的~  </p><p>run起来看看:<br><img src="http://ww1.sinaimg.cn/large/98900c07gw1ex3eatxf2nj208f0aiwes.jpg" alt="效果图"></p><p>OK,挺好,跟预期效果一样~~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里已经讲了onMeasure,onLayout的用法,其实并不难,只是需要耐心,仔细.  </p><p>看完了,相信对大家掌握自定义ViewGroup也有所帮助.<br>虽然没有处理padding,margin值,但是相信这些你可以搞定.  </p><h2 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h2><p>Android群英传</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自定义View </tag>
            
            <tag> ViewGroup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Swiftype做搜索引擎</title>
      <link href="/blog/b58c0938.html"/>
      <url>/blog/b58c0938.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为Hexo-Next 博客配置一个搜索引擎.  </p><h2 id="Swiftype"><a href="#Swiftype" class="headerlink" title="Swiftype"></a><a href="https://swiftype.com/" target="_blank" rel="noopener">Swiftype</a></h2><p>先去注册个账号,但是先别急着创建引擎.  </p><p>在<a href="http://bluefire4545.appspot.com/swiftype.com/documentation/sitemap" target="_blank" rel="noopener">Sitemap.xml Support</a>看<strong>Installing Your Sitemap</strong>小节.</p><p>按着步骤来,在博客根目录下新建一个<code>robots.txt</code>文件,填入内容<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User-<span class="string">agent:</span> *</span><br><span class="line"><span class="string">Sitemap:</span> <span class="string">http:</span><span class="comment">//www.yourdomain.com/sitemap1.xml</span></span><br><span class="line"><span class="string">Sitemap:</span> <span class="string">http:</span><span class="comment">//www.yourdomain.com/sitemap2.xml</span></span><br></pre></td></tr></table></figure></p><p>拿我的为例:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Sitemap:</span> <span class="string">http:</span><span class="comment">//yifeiyuan.me/sitemap.xml</span></span><br></pre></td></tr></table></figure></p><p>添加完后,push到github.<br>然后创建引擎,一步一步走,拿到 swiftype_key.<br>最后,编辑站点配置文件，新增字段 swiftype_key,配置好即可.<br>:<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">Swiftype </span>Search Key</span><br><span class="line"><span class="keyword">swiftype_key: </span>xxxxxxxxx</span><br></pre></td></tr></table></figure></p><p>done.</p><blockquote><p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT-配置</a><br><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">NexT-Github</a>  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Swiftype </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Canvas绘制几何图形</title>
      <link href="/blog/c15d15e4.html"/>
      <url>/blog/c15d15e4.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是我学习自定义View系列中的使用Canvas绘制几何图形.</p><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a><a href="http://developer.android.com/intl/zh-cn/reference/android/graphics/Canvas.html" target="_blank" rel="noopener">Canvas</a></h2><blockquote><p>The Canvas class holds the “draw” calls. To draw something, you need 4 basic components: A Bitmap to hold the pixels, a Canvas to host the draw calls (writing into the bitmap), a drawing primitive (e.g. Rect, Path, text, Bitmap), and a paint (to describe the colors and styles for the drawing).</p></blockquote><blockquote><p>Developer Guides: For more information about how to use Canvas, read the Canvas and Drawables developer guide.</p></blockquote><p>可以看出要使用Canvas,我们还需要一个bitmap(画在什么上),一个原型(画什么),一个Paint(用什么笔画).<br>感觉Canvas更像是个媒介.</p><pre><code>PS:Paint不是本文重点,就不提供Paint的相关代码了(其实就换换颜色什么的).</code></pre><p>Canvas拥有各种draw方法,不过,这里我只学习记录如何绘制几何图形以及效果:</p><ol><li>点</li><li>直线</li><li>矩形(正方形)</li><li>弧形(扇形)</li><li>椭圆(圆)</li></ol><h3 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h3><p>在学习这些知识之前,先来讲讲坐标系.<br><strong>在Android中每个View都有着自己的坐标系,都是以自己的左上角的点为原点.</strong><br><em>需要注意的是Y轴正方向是向下的</em></p><p><img src="http://ww2.sinaimg.cn/large/98900c07gw1ewuy075xh4j208409lq32.jpg" alt="坐标系示意图"></p><a id="more"></a><h3 id="点-Point"><a href="#点-Point" class="headerlink" title="点(Point)"></a>点(Point)</h3><p>在Android中点除了用(x,y)坐标来表示外,还可以由Point以及PointF来表示,其实它们都封装了x,y,另外再加了一些方法便于使用.<br>顺便提一下,它们的区别在于Point的精度为int,而PointF的精度为float,仅此而已,推荐PointF.</p><p>而用canvas画点非常简单:<br><code>public void drawPoint(float x, float y,@NonNull Paint paint)</code><br>只要给定一个(x,y)坐标即可.<br>由于点很简单,效果图跟线一起给.</p><h3 id="直线-Line"><a href="#直线-Line" class="headerlink" title="直线(Line)"></a>直线(Line)</h3><p>直线即两点的连线,也很简单,只要给出起始点,结束点的坐标即可.<br><code>public void drawLine(float startX, float startY, float stopX, float stopY,@NonNull Paint paint)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 画一个点</span></span><br><span class="line">canvas.drawPoint(<span class="number">10</span>, <span class="number">10</span>, mPointPaint);</span><br><span class="line"><span class="comment">// 画两条直线</span></span><br><span class="line">canvas.drawLine(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, mLinePaint);</span><br><span class="line">canvas.drawLine(<span class="number">0</span>, <span class="number">300</span>, <span class="number">300</span>, <span class="number">300</span>, mLinePaint);</span><br></pre></td></tr></table></figure><p><img src="http://ww4.sinaimg.cn/large/98900c07gw1ewv0ri72d6j2077086747.jpg" alt="Point-Line效果图"></p><h3 id="矩形-Rectangle"><a href="#矩形-Rectangle" class="headerlink" title="矩形(Rectangle)"></a>矩形(Rectangle)</h3><p>画矩形有以下方法:</p><ol><li><code>public void drawRect(float left, float top, float right, float bottom, @NonNull Paint paint)</code></li><li><code>public void drawRect(@NonNull RectF rect, @NonNull Paint paint)</code></li><li><code>public void drawRect(@NonNull Rect r, @NonNull Paint paint)</code></li></ol><p>先不着急画,我们来看看第一个方法需要我们给定4条边的坐标值,来定位这个矩形,那么它是如何定位的呢?<br>很简单:  </p><ol><li>left,right 是距离Y轴的水平距离</li><li>top,bottom 是距离X轴的水平距离  </li></ol><p>这样给定四条边的距离后即可确定一个矩形.</p><p><img src="http://ww4.sinaimg.cn/large/98900c07gw1ewv0evb4vhj207p0a0mx7.jpg" alt="Rect-理解图"></p><p>我还有另外一种理解方式,可以把这四个点理解为矩形对角的两个点的坐标(left,top),(bottom,top),<br>确定这两个点后,平移x轴,y轴与他们相交,也可以获得该矩形.  </p><p><img src="http://ww2.sinaimg.cn/large/98900c07gw1ewv2mlx2zqj20680a7aa1.jpg" alt="另一种理解"></p><p>另外,跟前面的点类似,Android中有Rect以及RectF封装了这四个值以及一些方法,它们的区别跟Point与PointF一样,就不多说了,依然推荐RectF.</p><p>另外还有一个<code>RoundRect</code>值得一提<br><code>public void drawRoundRect(@NonNull RectF rect, float rx, float ry, @NonNull Paint paint)</code></p><p>参数rx,ry代表两个不同的半径.<br>    PS:这个有个坑:当某一个值为0时,则无效果了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">canvas.translate(<span class="number">300</span>, <span class="number">0</span>);</span><br><span class="line">canvas.drawRoundRect(mArcRectF,<span class="number">0</span>,<span class="number">20</span>,mRectFPaint);</span><br><span class="line"></span><br><span class="line">canvas.translate(<span class="number">300</span>, <span class="number">0</span>);</span><br><span class="line">canvas.drawRoundRect(mArcRectF,<span class="number">50</span>,<span class="number">70</span>,mRectFPaint);</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/98900c07gw1eww3k0z6chj208n045745.jpg" alt="效果"></p><h3 id="弧形-Arc-amp-扇形"><a href="#弧形-Arc-amp-扇形" class="headerlink" title="弧形(Arc)&amp;扇形"></a>弧形(Arc)&amp;扇形</h3><ol><li><code>public void drawArc(@NonNull RectF oval, float startAngle, float sweepAngle, boolean useCenter,@NonNull Paint paint)</code>  </li><li><code>public void drawArc(float left, float top, float right, float bottom, float startAngle,float sweepAngle, boolean useCenter, @NonNull Paint paint)</code>(API21)  </li></ol><p>之前已经提到过RectF,其实这两个方法一样,不过<em>第二个API等级为21</em>.<br>那么来理解一下参数:</p><ol><li>RectF oval 给定一个矩形,来确定一个内切圆</li><li>startAngle 弧形的起始角度</li><li>sweepAngle 弧形的角度跨度</li><li>useCenter  最后的弧形是否包括圆心(true则为扇形了)</li></ol><p>画了个简易的图,方便理解:<br><img src="http://ww2.sinaimg.cn/large/98900c07gw1eww1v3xlifj209h0bbq3a.jpg" alt="一张图理解drawArc"></p><pre><code>PS: sweepAngle&gt;=360 时则为一个内切圆,无视useCenter.  </code></pre><h3 id="椭圆-Oval-amp-圆-Circle"><a href="#椭圆-Oval-amp-圆-Circle" class="headerlink" title="椭圆(Oval)&amp;圆(Circle)"></a>椭圆(Oval)&amp;圆(Circle)</h3><p>椭圆:</p><ol><li><code>public void drawOval(@NonNull RectF oval, @NonNull Paint paint)</code></li><li><code>public void drawOval(float left, float top, float right, float bottom, @NonNull Paint paint)</code>(API21)</li></ol><p>参数理解:前面已经提过,给定一个矩形,即可获得一个内切圆,也就是这个椭圆.</p><p>圆:<br><code>public void drawCircle(float cx, float cy, float radius, @NonNull Paint paint)</code></p><p>参数理解:(cx,cy)代表圆心的坐标,radius表示半径,这样即可确定一个圆,很好理解.</p><pre><code>PS: 虽然默认提供画圆的方法只有一个,但是由于圆是个特殊的椭圆,只要画椭圆时给定一个正方形也能画圆.</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">canvas.translate(<span class="number">400</span>, <span class="number">0</span>);</span><br><span class="line">mOvalRectF.set(<span class="number">0</span>, <span class="number">30</span>, <span class="number">267</span>, <span class="number">222</span>);<span class="comment">//椭圆</span></span><br><span class="line">canvas.drawOval(mOvalRectF, mOvalPaint);</span><br><span class="line"></span><br><span class="line">canvas.translate(<span class="number">0</span>, <span class="number">300</span>);</span><br><span class="line">mOvalRectF.set(<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">200</span>);<span class="comment">//设置成正方形</span></span><br><span class="line">canvas.drawOval(mOvalRectF, mOvalPaint);</span><br><span class="line"></span><br><span class="line">canvas.translate(<span class="number">0</span>, <span class="number">300</span>);</span><br><span class="line">canvas.drawCircle(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, mOvalPaint);<span class="comment">//直接画正方形</span></span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/98900c07gw1eww3z4cj7zj205w08tt8r.jpg" alt="效果"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>好了,使用Canvas画简单的几何图形就到这里了~~<br>代码在<a href="https://github.com/AlanCheen/PracticeDemo/blob/master/PracticeDemos%2Fapp%2Fsrc%2Fmain%2Fjava%2Fyifeiyuan%2Fpractice%2Fpracticedemos%2Fcustomview%2FCanvasActivity.java" target="_blank" rel="noopener">Github</a>上.    </p><p>如果有遗漏,有错误,欢迎指导!!!!<br>PS:这个笔记写了两遍,第一遍被自己不小心给还原了,被自己笨哭了!  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自定义View </tag>
            
            <tag> Canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo奇淫技巧</title>
      <link href="/blog/2ea151b9.html"/>
      <url>/blog/2ea151b9.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>收集记录一些Hexo的奇淫技巧~</p><h3 id="自动打开刚添加的文章"><a href="#自动打开刚添加的文章" class="headerlink" title="自动打开刚添加的文章"></a>自动打开刚添加的文章</h3><ol><li>在Hexo目录下新建scripts目录(有就无视)</li><li>在scripts下新建js脚本,名字随意(例子:<code>/Users/alanchen/Documents/hexoblog/scripts/openfile.js</code>)</li><li>在刚新建的脚本输入以下内容<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">exec</span> = require(<span class="string">'child_process'</span>).<span class="built_in">exec</span>;</span><br><span class="line"><span class="comment">// Hexo 3 用户复制这段</span></span><br><span class="line">hexo.on(<span class="string">'new'</span>, <span class="function"><span class="keyword">function</span><span class="params">(data)</span>&#123;</span></span><br><span class="line">    <span class="built_in">exec</span>(<span class="string">'open -a "</span>/Applications/Atom.app<span class="string">" '</span> + data.path);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>PS:/Applications/Atom.app 为<strong>你要使用的编辑器的绝对路径!</strong></p><p>保存退出后使用<code>hexo n &quot;filename&quot;</code>命令后会用指定的app打开文章,非常方便.</p><blockquote><p>来源<br><a href="http://notes.xiamo.tk/2015-06-29-Hexo%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E6%97%B6%E8%87%AA%E5%8A%A8%E6%89%93%E5%BC%80%E7%BC%96%E8%BE%91%E5%99%A8.html" target="_blank" rel="noopener">Hexo添加文章时自动打开编辑器</a></p></blockquote><h3 id="添加网易云音乐"><a href="#添加网易云音乐" class="headerlink" title="添加网易云音乐"></a>添加网易云音乐</h3><a id="more"></a><p>去<code>http://music.163.com/</code>找到想添加的歌曲,点击<code>生成外链播放器</code>,会生成代码,加入到博客即可.<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;embed <span class="attribute">src</span>=<span class="string">"http://music.163.com/style/swf/widget.swf?sid=20657354&amp;type=2&amp;auto=1&amp;width=320&amp;height=66"</span> <span class="attribute">width</span>=<span class="string">"340"</span> <span class="attribute">height</span>=<span class="string">"86"</span>  <span class="attribute">allowNetworking</span>=<span class="string">"all"</span>&gt;&lt;/embed&gt;</span><br></pre></td></tr></table></figure></p><p>如:  </p><embed src="http://music.163.com/style/swf/widget.swf?sid=20657354&type=2&auto=1&width=320&height=66" width="340" height="86" allownetworking="all"><h3 id="自定义新菜单"><a href="#自定义新菜单" class="headerlink" title="自定义新菜单"></a>自定义新菜单</h3><p>使用Hexo的Next主题新增菜单时,菜单名称会添加前缀<code>Menu.</code>,为了解决这个问题我提了个<a href="https://github.com/iissnan/hexo-theme-next/issues/412" target="_blank" rel="noopener">Issue</a><br>最后修改了<code>zh-Hans.yml</code>文件后成功啦~</p><h3 id="置顶文章"><a href="#置顶文章" class="headerlink" title="置顶文章"></a>置顶文章</h3><p>在文章的<code>front-matter</code>里加入<code>top: true</code></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发工具汇总</title>
      <link href="/blog/93cc8683.html"/>
      <url>/blog/93cc8683.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开发Android不光用的只是AndroidStudio.<br>在这里记录好用的各种类型的工具/App.  </p><h2 id="Mac-App"><a href="#Mac-App" class="headerlink" title="Mac App"></a>Mac App</h2><h3 id="Go2Shell"><a href="#Go2Shell" class="headerlink" title="Go2Shell"></a><a href="http://zipzapmac.com/Go2Shell" target="_blank" rel="noopener">Go2Shell</a></h3><p>一个小巧而强大的工具,快速在当前位置打开Shell</p><h3 id="Dash"><a href="#Dash" class="headerlink" title="Dash"></a><a href="https://kapeli.com/dash" target="_blank" rel="noopener">Dash</a></h3><p>一个非常强大的文档工具.</p><h3 id="Iterm2"><a href="#Iterm2" class="headerlink" title="Iterm2"></a><a href="http://iterm2.com/" target="_blank" rel="noopener">Iterm2</a></h3><p>神器..</p><h3 id="Oh-my-zsh"><a href="#Oh-my-zsh" class="headerlink" title="Oh,my zsh"></a><a href="http://ohmyz.sh/" target="_blank" rel="noopener">Oh,my zsh</a></h3><p>iterm2配ohmyzsh,爽到爆.  </p><ol><li><a href="http://macshuo.com/?p=676" target="_blank" rel="noopener">终极 Shell</a></li></ol><a id="more"></a><h3 id="OptionSpace"><a href="#OptionSpace" class="headerlink" title="OptionSpace"></a><a href="https://optionspace.co/download/" target="_blank" rel="noopener">OptionSpace</a></h3><h3 id="SublimeText"><a href="#SublimeText" class="headerlink" title="SublimeText"></a><a href="http://www.sublimetext.com/" target="_blank" rel="noopener">SublimeText</a></h3><ol><li><a href="http://blog.saymagic.cn/2015/01/01/sublime_text_concise_course.html" target="_blank" rel="noopener">Sublime Text简明教程</a>  </li><li><a href="http://blog.saymagic.cn/2015/06/20/write-blog-by-sublime.html" target="_blank" rel="noopener">Sublime进阶使用</a>  </li></ol><h3 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a><a href="https://atom.io/docs" target="_blank" rel="noopener">Atom</a></h3><p>Github开发的编辑工具  </p><h3 id="Paste"><a href="#Paste" class="headerlink" title="Paste"></a><a href="http://bbs.feng.com/read-htm-tid-9943996.html" target="_blank" rel="noopener">Paste</a></h3><p>很好用的对剪贴板历史进行管理的软件:Paste</p><h3 id="Bartender"><a href="#Bartender" class="headerlink" title="Bartender"></a><a href="http://www.pc6.com/mac/114699.html" target="_blank" rel="noopener">Bartender</a></h3><p>Bartender 2.0：装机必备的菜单栏工具</p><h3 id="DaisyDisk"><a href="#DaisyDisk" class="headerlink" title="DaisyDisk"></a><a href="http://www.pc6.com/mac/114134.html" target="_blank" rel="noopener">DaisyDisk</a></h3><p>DaisyDisk Mac版是Mac OS平台上的一款Mac系统清理工具，他可以帮助你了解磁盘使用状况，并进行准确的分析</p><h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a><a href="">Vim</a></h3><p>文章:</p><ol><li><a href="http://yuez.me/jiang-ni-de-vim-da-zao-cheng-qing-qiao-qiang-da-de-ide/" target="_blank" rel="noopener"></a></li></ol><h3 id="flux"><a href="#flux" class="headerlink" title="flux"></a><a href="https://justgetflux.com/" target="_blank" rel="noopener">flux</a></h3><p>一个可以让屏幕颜色跟随时间变化而变化的神奇的软件,能让眼睛更舒服~  </p><h3 id="retinizer"><a href="#retinizer" class="headerlink" title="retinizer"></a><a href="http://retinizer.mikelpr.com/" target="_blank" rel="noopener">retinizer</a></h3><h2 id="制图工具"><a href="#制图工具" class="headerlink" title="制图工具"></a>制图工具</h2><h3 id="ProcessOn"><a href="#ProcessOn" class="headerlink" title="ProcessOn"></a><a href="https://www.processon.com/tour" target="_blank" rel="noopener">ProcessOn</a></h3><p>免费在线作图工具</p><h3 id="StarUML-2"><a href="#StarUML-2" class="headerlink" title="StarUML 2"></a><a href="http://staruml.io/" target="_blank" rel="noopener">StarUML 2</a></h3><p>一个uml图工具~  </p><h3 id="Xmind"><a href="#Xmind" class="headerlink" title="Xmind"></a><a href="http://www.xmind.net/download/mac/" target="_blank" rel="noopener">Xmind</a></h3><p>思维导图工具.  </p><h3 id="onepassword"><a href="#onepassword" class="headerlink" title="onepassword"></a><a href="https://agilebits.com/onepassword/mac" target="_blank" rel="noopener">onepassword</a></h3><p>一个app保存所有密码~  </p><h3 id="百度脑图"><a href="#百度脑图" class="headerlink" title="百度脑图"></a><a href="http://naotu.baidu.com/edit.html" target="_blank" rel="noopener">百度脑图</a></h3><h2 id="Web-Site"><a href="#Web-Site" class="headerlink" title="Web Site"></a>Web Site</h2><h3 id="dpical"><a href="#dpical" class="headerlink" title="dpical"></a><a href="http://jennift.com/dpical.html" target="_blank" rel="noopener">dpical</a></h3><h3 id="screensize"><a href="#screensize" class="headerlink" title="screensize"></a><a href="http://screensiz.es/phone" target="_blank" rel="noopener">screensize</a></h3><h3 id="RGB颜色查询对照表"><a href="#RGB颜色查询对照表" class="headerlink" title="RGB颜色查询对照表"></a><a href="http://www.114la.com/other/rgb.htm" target="_blank" rel="noopener">RGB颜色查询对照表</a></h3><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a><a href="https://regex101.com/" target="_blank" rel="noopener">正则表达式</a></h3><h3 id="MD5破解"><a href="#MD5破解" class="headerlink" title="MD5破解"></a><a href="http://md5ss.sinaapp.com/" target="_blank" rel="noopener">MD5破解</a></h3><h3 id="Codota"><a href="#Codota" class="headerlink" title="Codota"></a><a href="https://www.codota.com/" target="_blank" rel="noopener">Codota</a></h3><p>代码搜索工具   </p><h3 id="tinypng"><a href="#tinypng" class="headerlink" title="tinypng"></a><a href="https://tinypng.com/" target="_blank" rel="noopener">tinypng</a></h3><p>图片压缩,非常给力  </p><h3 id="apkleecher"><a href="#apkleecher" class="headerlink" title="apkleecher"></a><a href="http://apkleecher.com/" target="_blank" rel="noopener">apkleecher</a></h3><p>APK下载工具  </p><h3 id="Json在线解析"><a href="#Json在线解析" class="headerlink" title="Json在线解析"></a><a href="http://json.bloople.net/#_output" target="_blank" rel="noopener">Json在线解析</a></h3><p>在线解析json数据,很快很清楚  </p><h3 id="jsonformatter"><a href="#jsonformatter" class="headerlink" title="jsonformatter"></a><a href="https://jsonformatter.curiousconcept.com/" target="_blank" rel="noopener">jsonformatter</a></h3><p>与上一个不同,这个可以填写url  </p><h3 id="jsonschema2pojo"><a href="#jsonschema2pojo" class="headerlink" title="jsonschema2pojo"></a><a href="http://www.jsonschema2pojo.org/" target="_blank" rel="noopener">jsonschema2pojo</a></h3><p>填写json生成pojo  </p><h2 id="Chrome插件"><a href="#Chrome插件" class="headerlink" title="Chrome插件"></a>Chrome插件</h2><h3 id="PostMan"><a href="#PostMan" class="headerlink" title="PostMan"></a><a href="http://xiequan.info/postman-%E5%B8%AE%E5%8A%A9%E4%BD%A0%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E9%AB%98%E6%95%88%E7%9A%84http%E6%A8%A1%E6%8B%9F%E5%92%8Capi%E8%B0%83%E8%AF%95/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">PostMan</a></h3><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><h3 id="ShowJava"><a href="#ShowJava" class="headerlink" title="ShowJava"></a><a href="">ShowJava</a></h3><p>一个可以反编译App的App,很强大.</p><h2 id="发布工具"><a href="#发布工具" class="headerlink" title="发布工具"></a>发布工具</h2><h3 id="Fir"><a href="#Fir" class="headerlink" title="Fir"></a><a href="http://fir.im/plaza" target="_blank" rel="noopener">Fir</a></h3><h2 id="开源库资源"><a href="#开源库资源" class="headerlink" title="开源库资源"></a>开源库资源</h2><h3 id="android-arsenal"><a href="#android-arsenal" class="headerlink" title="android-arsenal"></a><a href="https://android-arsenal.com/" target="_blank" rel="noopener">android-arsenal</a></h3><h2 id="其他汇总资料"><a href="#其他汇总资料" class="headerlink" title="其他汇总资料"></a>其他汇总资料</h2><ol><li><a href="http://www.mobdevgroup.com/tools/frontend/" target="_blank" rel="noopener">开发工具</a>  </li><li><a href="http://wulfric.me/2015/08/zsh/" target="_blank" rel="noopener">一些命令行效率工具</a>  </li><li><a href="http://info.9iphp.com/15-chrome-extensions-for-developers/" target="_blank" rel="noopener">[必备]15个对开发人员有用的Chrome扩展插件</a>  </li><li><a href="http://toutiao.com/a6236185341524164865/?tt_from=sina&amp;utm_campain=client_share&amp;app=news_article&amp;utm_source=sinaweibo&amp;iid=3428152586&amp;utm_medium=toutiao_ios" target="_blank" rel="noopener">你不应错过的 22 款 Mac 效率工具 App</a><br>5.</li></ol>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SublimeText</title>
      <link href="/blog/2e0162a9.html"/>
      <url>/blog/2e0162a9.html</url>
      
        <content type="html"><![CDATA[<h2 id="SublimeText"><a href="#SublimeText" class="headerlink" title="SublimeText"></a><a href="">SublimeText</a></h2><h2 id="Package-Control"><a href="#Package-Control" class="headerlink" title="Package Control"></a><a href="https://packagecontrol.io/installation" target="_blank" rel="noopener">Package Control</a></h2><h2 id="subl"><a href="#subl" class="headerlink" title="subl"></a>subl</h2><p>配置环境变量使用<code>subl</code><br><code>/Applications/Sublime Text.app/Contents/SharedSupport/bin</code></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table><thead><tr><th style="text-align:center">Key</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">command+shift+p</td><td style="text-align:center">打开命令模式</td></tr></tbody></table><a id="more"></a><h2 id="使用subl画uml"><a href="#使用subl画uml" class="headerlink" title="使用subl画uml"></a><a href="http://blog.yourtion.com/use-plantuml-on-mac.html?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">使用subl画uml</a></h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.saymagic.cn/2015/01/01/sublime_text_concise_course.html" target="_blank" rel="noopener">简明教程</a><br><a href="http://blog.saymagic.cn/2015/06/20/write-blog-by-sublime.html" target="_blank" rel="noopener">进阶</a></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SublimeText </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava之Subscription</title>
      <link href="/blog/a3469d3c.html"/>
      <url>/blog/a3469d3c.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面写过RxJava类似观察者模式,但是一直没提到RxJava如何取消订阅,今天就来学习一下.</p><h2 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h2><p>RxJava中有个叫做<code>Subscription</code>的接口,可以用来取消订阅.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subscription</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Stops the receipt of notifications on the &#123;<span class="doctag">@link</span> Subscriber&#125; that was registered when this Subscription</span></span><br><span class="line"><span class="comment">     * was received.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This allows unregistering an &#123;<span class="doctag">@link</span> Subscriber&#125; before it has finished receiving all events (i.e. before</span></span><br><span class="line"><span class="comment">     * onCompleted is called).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates whether this &#123;<span class="doctag">@code</span> Subscription&#125; is currently unsubscribed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this &#123;<span class="doctag">@code</span> Subscription&#125; is currently unsubscribed, &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isUnsubscribed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面可以看到,我们只需要调用<code>unsubscribe</code>就可以取消订阅,那么如何得到一个<code>Subscription</code>对象呢?</p><a id="more"></a><p>其实很简单:<br><code>Observable.subscribe()</code>方法可以返回一个<code>Subscription</code>的对象,即我们每次订阅都会返回.<br>感觉<code>Subscription</code>就像一个订单,你下单了就会生成一个订单,而你也可以用这个订单取消订单.  </p><p>OK,内容其实不多,那么来练习一下吧.  </p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>我先写了以下代码来测试:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Subscription subscription = Observable.just(<span class="string">"Hello subscription"</span>)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">System.out.println(subscription.isUnsubscribed());</span><br><span class="line">subscription.unsubscribe();</span><br><span class="line">System.out.println(subscription.isUnsubscribed());</span><br></pre></td></tr></table></figure></p><p>在我想来输出的日志应该是这样的:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Hello</span> <span class="string">subscription</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>但是,结果出乎我的意料,我运行之后是这样的:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Hello</span> <span class="string">subscription</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>诶?不对啊,明明我没有取消订阅啊,怎么就true了呢?</p><!-- more --><p>接下去我进源码探索了一下发现:<br>在<code>Observable.subscribe()</code>里有这么一段代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(subscriber <span class="keyword">instanceof</span> SafeSubscriber)) &#123;</span><br><span class="line">    <span class="comment">// assign to `observer` so we return the protected version</span></span><br><span class="line">    subscriber = <span class="keyword">new</span> SafeSubscriber&lt;T&gt;(subscriber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它会把我们传递的<code>subscriber</code>转成<code>SafeSubscriber</code>,接下去跟进发现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            actual.onCompleted();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// we handle here instead of another method so we don't add stacks to the frame</span></span><br><span class="line">            <span class="comment">// which can prevent it from being able to handle StackOverflow</span></span><br><span class="line">            Exceptions.throwIfFatal(e);</span><br><span class="line">            <span class="comment">// handle errors if the onCompleted implementation fails, not just if the Observable fails</span></span><br><span class="line">            _onError(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// auto-unsubscribe</span></span><br><span class="line">            unsubscribe();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原来<strong>它在finally里自动取消了订阅!!</strong></p><p>那么让onCompleted晚点执行就行了:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Subscription subscription = Observable.just(<span class="string">"Hello subscription"</span>)</span><br><span class="line">        .subscribeOn(Schedulers.newThread())<span class="comment">//起线程</span></span><br><span class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;<span class="keyword">String</span>&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> call(<span class="keyword">String</span> s) &#123;</span><br><span class="line">                <span class="built_in">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);<span class="comment">//睡5秒,延迟一下</span></span><br><span class="line">                &#125; <span class="built_in">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.<span class="built_in">println</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认subscription 调用完</span></span><br><span class="line">System.out.<span class="built_in">println</span>(subscription.isUnsubscribed());</span><br><span class="line">subscription.unsubscribe();</span><br><span class="line">System.out.<span class="built_in">println</span>(subscription.isUnsubscribed());</span><br></pre></td></tr></table></figure></p><p>Log:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>注意,取消订阅了之后<code>Hello subscription</code>并不会打印,你想,你取消了订阅报纸,报社还会给你发报纸么?</p><p>好了关于<code>Subscription</code>暂时就探索到这里了.<br>接下去就是项目实战了,有兴趣的可以关注一下.</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RxJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建RESTAPI神器-JsonServer</title>
      <link href="/blog/e1e98fbc.html"/>
      <url>/blog/e1e98fbc.html</url>
      
        <content type="html"><![CDATA[<h2 id="JsonServer"><a href="#JsonServer" class="headerlink" title="JsonServer"></a><a href="https://github.com/typicode/json-server" target="_blank" rel="noopener">JsonServer</a></h2><blockquote><p>Get a full fake REST API with zero coding in less than 30 seconds (seriously)</p></blockquote><p>可以用来创建 RestApi,非常方便.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>应该还需要装NodeJs什么的,但是我已经安装过了.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo npm install -g json-server</span></span><br></pre></td></tr></table></figure></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol><li><p>找个地方新建一个db.json文件<br>写入一段json,如:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"posts"</span>: [</span><br><span class="line">    &#123; <span class="attr">"id"</span>: <span class="number">1</span>, <span class="attr">"title"</span>: <span class="string">"json-server"</span>, <span class="attr">"author"</span>: <span class="string">"typicode"</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"comments"</span>: [</span><br><span class="line">    &#123; <span class="attr">"id"</span>: <span class="number">1</span>, <span class="attr">"body"</span>: <span class="string">"some comment"</span>, <span class="attr">"postId"</span>: <span class="number">1</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"profile"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"typicode"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动server</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json-server --watch db.json</span><br></pre></td></tr></table></figure><a id="more"></a><p>启动成功后:<br><img src="http://ww2.sinaimg.cn/large/98900c07gw1ewdjux1qkyj20gv0a8abl.jpg" alt="效果"></p><p>接下去就可以访问了:  </p><p><img src="http://ww2.sinaimg.cn/large/98900c07gw1ewdjxs30yvj208z05yweq.jpg" alt="最后效果"></p><h2 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h2><p>每次都输入<code>json-server --watch</code> 太麻烦了.<br>我给它配置个别名:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">jsw</span></span><br><span class="line">alias jsw="json-server --watch"</span><br></pre></td></tr></table></figure></p><p>记得<code>source ~/.zshrc</code>,这样以后就方便了:<br><img src="http://ww4.sinaimg.cn/large/98900c07gw1ewdkd1t6e1j208403qmx8.jpg" alt="别名"></p><p>以后可以自己模拟写Api了~<br>更多功能还需去<a href="https://github.com/typicode/json-server" target="_blank" rel="noopener">Github</a>看,不过作为一个Android程序猿,这个已经够了.</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> NodeJs </tag>
            
            <tag> RestApi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac抓包工具Charles</title>
      <link href="/blog/a7e7fcfb.html"/>
      <url>/blog/a7e7fcfb.html</url>
      
        <content type="html"><![CDATA[<h2 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a><a href="http://www.charlesproxy.com/latest-release/download.do" target="_blank" rel="noopener">Charles</a></h2><p>Mac下的抓包工具,去官网下载,安装.<br>默认的Charles每天用30分后就需要再关闭再打开.<br>破解实属无奈之举,<a href="http://download.csdn.net/detail/kamouswjw/8603053" target="_blank" rel="noopener">下载破解jar</a><br>替换对应的jar就行.  </p><h2 id="手机抓包"><a href="#手机抓包" class="headerlink" title="手机抓包"></a>手机抓包</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>确保手机和电脑用的同一个Wifi!</p><h3 id="查看电脑ip"><a href="#查看电脑ip" class="headerlink" title="查看电脑ip"></a>查看电脑ip</h3><ol><li>用命令<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ifconfig</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="http://ww3.sinaimg.cn/large/98900c07gw1ewdemig8h8j20ke0b7tcb.jpg" alt="结果"></p><ol start="2"><li>网络<br>打开网络设置</li></ol><p><img src="http://ww4.sinaimg.cn/large/98900c07gw1ewdenunr0fj20il05nq3q.jpg" alt="效果"></p><a id="more"></a><h3 id="手机设代理"><a href="#手机设代理" class="headerlink" title="手机设代理"></a>手机设代理</h3><p>将手机网络代理到自己的电脑.</p><ol><li>打开使用的wifi设置,设置好代理,端口默认填写8888(可以在Charles里设置).</li><li>charles会弹个框,选择允许即可.<br><img src="http://ww3.sinaimg.cn/large/98900c07gw1ewdesd5ce6j20ea05r75e.jpg" alt="弹框"></li></ol><p>OK,可以快乐的抓包了.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://www.testwo.com/blog/6343" target="_blank" rel="noopener">http://www.testwo.com/blog/6343</a><br><a href="http://www.99css.com/1272/" target="_blank" rel="noopener">http://www.99css.com/1272/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> Charles </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCode导致Git无法使用</title>
      <link href="/blog/16ec7858.html"/>
      <url>/blog/16ec7858.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天一打开AS,发现git用不了了,想着我啥也没干呐,没Git怎么行!</p><p><img src="http://ww3.sinaimg.cn/large/98900c07gw1ewb0i5d4kxj20e201gwei.jpg" alt="AS提示"><br>点fix提示:<br><img src="http://ww2.sinaimg.cn/large/98900c07gw1ewb0j2hjd8j20bb05ndg6.jpg" alt=""></p><p>执行Git命令也得到提示:<br>提示:<code>Agreeing to the Xcode/iOS license requires admin privileges, please re-run as root via sudo.</code><br>看来确实用不了,无奈google之,发现个类似的错误.  </p><p>找到解决方法如下,记录一下:</p><a id="more"></a><h2 id="打开XCode"><a href="#打开XCode" class="headerlink" title="打开XCode:"></a>打开XCode:</h2><p><img src="http://ww3.sinaimg.cn/large/98900c07gw1ewb0gc0i8bj20dp09i76i.jpg" alt="XCode"></p><h2 id="点击agree"><a href="#点击agree" class="headerlink" title="点击agree"></a>点击agree</h2><p>会让你登录,接着它会下载点什么鬼<br><img src="http://ww2.sinaimg.cn/large/98900c07gw1ewb0mdiutbj20dl04qdg2.jpg" alt=""></p><p>等下载完毕,再回AS试试git:</p><p><img src="http://ww4.sinaimg.cn/large/98900c07gw1ewb0nj3vhtj20be045t8u.jpg" alt="Git-OK"></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>也不知道是否是XCodeGhost给影响的,真坑.  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://stackoverflow.com/questions/26197347/agreeing-to-the-xcode-ios-license-requires-admin-privileges-please-re-run-as-r" target="_blank" rel="noopener">Agreeing to the Xcode/iOS license requires admin privileges, please re-run as root via sudo.</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> XCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过包名杀死App</title>
      <link href="/blog/472b16a5.html"/>
      <url>/blog/472b16a5.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天游戏部门有个需求就是在某个情况下杀死他们App…</p><p>好血腥,好暴力的需求啊!<br>从来没有杀死过别的App啊,我的双手是否会因此沾染鲜血啊…  </p><p>记录一下:</p><p>首先要添加权限:<br><code>&lt;uses-permission android:name=&quot;android.permission.KILL_BACKGROUND_PROCESSES&quot;/&gt;</code></p><p>然后代码:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityManager manager = (ActivityManager) mContext.getSystemService(<span class="built_in">Context</span>.ACTIVITY_SERVICE)<span class="comment">;</span></span><br><span class="line">manager.killBackgroundProcesses(pkgname)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>啊,罪孽深重啊..  </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神器Vim学习</title>
      <link href="/blog/633ec960.html"/>
      <url>/blog/633ec960.html</url>
      
        <content type="html"><![CDATA[<h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><p>vim 早有耳闻,这次来稍微入个门先.</p><p><code>vim filename</code>进入vim模式.<br>输入<code>a</code>或者<code>i</code>,进入编辑模式.<br>按<code>Esc</code>退出编辑模式.<br>如果要保存,在浏览模式下输入<code>:wq</code>,保存并退出.<br>如果有所改动但是又不想保存则输入<code>:q!</code>,不然会提示有错误.</p><a id="more"></a><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><ul><li>“h” to go left,  往左</li><li>“j” to go down,  往下</li><li>“k” to go up,    往上</li><li>“l” to go right. 往下</li></ul><p>有些奇怪,不习惯</p><h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><ul><li><code>:wq&lt;Enter&gt;</code> 保存修改并退出</li><li><code>:q!&lt;Enter&gt;</code> 退出但不保存修改</li></ul><h2 id="vim-模式"><a href="#vim-模式" class="headerlink" title="vim 模式"></a>vim 模式</h2><p>在vim模式下输入<code>:help</code>可以进入help界面<br>//todo 更多技巧</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="http://www.cnblogs.com/chijianqiang/tag/vim/" target="_blank" rel="noopener">http://www.cnblogs.com/chijianqiang/tag/vim/</a></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EventBus的使用</title>
      <link href="/blog/33419f48.html"/>
      <url>/blog/33419f48.html</url>
      
        <content type="html"><![CDATA[<h2 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">EventBus</a></h2><blockquote><p>Android optimized event bus that simplifies communication between Activities, Fragments, Threads, Services, etc. Less code, better quality.</p></blockquote><p>优化的事件总线,简化app各个类之间的交互.</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p><code>compile &#39;de.greenrobot:eventbus:2.4.0&#39;</code></p><h3 id="注意混淆"><a href="#注意混淆" class="headerlink" title="注意混淆"></a>注意混淆</h3><p>使用EventBus,如果混淆的话必须要加上以下几句:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-keepclassmembers <span class="class"><span class="keyword">class</span> ** &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> onEvent*(**);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventMainThread</span><span class="params">(**)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="必备插件"><a href="#必备插件" class="headerlink" title="必备插件"></a>必备插件</h3><p>当定义的Event越来越多,我们要寻找某个Event哪里接收哪里发送会比较麻烦.<br>幸好有这么一个插件可以帮助我们:  </p><p><a href="https://github.com/kgmyshin/eventbus-intellij-plugin" target="_blank" rel="noopener">EventBus Intellij Plugin</a></p><h4 id="功能"><a href="#功能" class="headerlink" title="功能:"></a>功能:</h4><p>Provides actions which allow you quickly move around the event bus.</p><ol><li>EventBus.post to onEvent or onEventMainThread</li><li>onEvent or onEventMainThread to EventBus.post</li></ol><h4 id="效果"><a href="#效果" class="headerlink" title="效果:"></a>效果:</h4><p><img src="http://ww2.sinaimg.cn/large/98900c07gw1ew6pb2igcqj20hu020t8u.jpg" alt="onEventMainThread效果图"></p><p>点击上图的图标,会帮你找到发送的地方.<br><img src="http://ww3.sinaimg.cn/large/98900c07gw1ew6pfa2tymj20k003dwfq.jpg" alt="点击后效果"></p><p>同样,也能在发送的地方查找哪里接收.</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p><a href="http://a.codekk.com/detail/Android/Trinea/EventBus%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="noopener">EventBus-源码解析</a></p>]]></content>
      
      
      <categories>
          
          <category> 开源项目使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EventBus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用HttpUrlConnection下载文件</title>
      <link href="/blog/c7295d19.html"/>
      <url>/blog/c7295d19.html</url>
      
        <content type="html"><![CDATA[<p>记录一下使用HttpUrlConnection的<code>Get</code>方式下载文件的方法.</p><p>Show the code:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String mUrl=<span class="string">"http://download.fir.im/v2/app/install/559d229d692d791592000016?download_token=6adb9ccc081979064c9d453b1a9d7bf5"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//file:/storage/emulated/0/test.apk</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory(), <span class="string">"test.apk"</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"download: file:"</span> + file.getPath());</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(mUrl);</span><br><span class="line">        HttpURLConnection connection = (HttpURLConnection) url.openConnection();</span><br><span class="line">        connection.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line">        InputStream in = connection.getInputStream();</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(in);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> size = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((size = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fos.flush();</span><br><span class="line">        fos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">        connection.disconnect();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HttpUrlConnection </tag>
            
            <tag> 下载文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava多线程操作</title>
      <link href="/blog/7ecd0260.html"/>
      <url>/blog/7ecd0260.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://yifeiyuan.me/2015/09/12/RxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">上一次</a>学习了解了一些RxJava比较常用的操作符,这次来学习一下Rx的多线程操作.</p><h2 id="Scheduler-调度器"><a href="#Scheduler-调度器" class="headerlink" title="Scheduler-调度器"></a><a href="http://reactivex.io/documentation/scheduler.html" target="_blank" rel="noopener">Scheduler-调度器</a></h2><blockquote><p>If you want to introduce multithreading into your cascade of Observable operators, you can do so by instructing those operators (or particular Observables) to operate on particular Schedulers.</p></blockquote><p>如果你想给你的操作符链添加多线程,你可以通知这些操作符(或特定的Observables)运行在指定的调度器上.</p><p>也就是说RxJava的多线程是由Schedulers操作的,接下去去了解一下.</p><h2 id="调度器种类"><a href="#调度器种类" class="headerlink" title="调度器种类"></a>调度器种类</h2><p>RxJava中Schedulers有很多种<br>下表展示了RxJava中可用的调度器种类(RxAndroid中有多少暂时不知道)：</p><table><thead><tr><th style="text-align:left">调度器类型</th><th style="text-align:left">效果</th></tr></thead><tbody><tr><td style="text-align:left">Schedulers.computation( )</td><td style="text-align:left">用于计算任务，如事件循环或和回调处理，不要用于IO操作(IO操作请使用Schedulers.io())；默认线程数等于处理器的数量</td></tr><tr><td style="text-align:left">Schedulers.from(executor)</td><td style="text-align:left">使用指定的Executor作为调度器</td></tr><tr><td style="text-align:left">Schedulers.immediate( )</td><td style="text-align:left">在当前线程立即开始执行任务</td></tr><tr><td style="text-align:left">Schedulers.io( )</td><td style="text-align:left">用于IO密集型任务，如异步阻塞IO操作，这个调度器的线程池会根据需要增长；对于普通的计算任务，请使用Schedulers.computation()；Schedulers.io( )默认是一个CachedThreadScheduler，很像一个有线程缓存的新线程调度器  </td></tr><tr><td style="text-align:left">Schedulers.newThread( )</td><td style="text-align:left">为每个任务创建一个新线程  </td></tr><tr><td style="text-align:left">Schedulers.trampoline( )</td><td style="text-align:left">当其它排队的任务完成后，在当前线程排队开始执行</td></tr></tbody></table><p>知道了Schedulser,那么接下去就要运用了.<br>下面介绍两个操作符,对,是<strong>操作符</strong>.<br><a id="more"></a></p><h2 id="SubscribeOn"><a href="#SubscribeOn" class="headerlink" title="SubscribeOn"></a><a href="http://reactivex.io/documentation/operators/subscribeon.html" target="_blank" rel="noopener">SubscribeOn</a></h2><blockquote><p>specify the Scheduler on which an Observable will operate</p></blockquote><p>SubscribeOn 指定了Observable的调度器.</p><h2 id="ObserveOn"><a href="#ObserveOn" class="headerlink" title="ObserveOn"></a><a href="http://reactivex.io/documentation/operators/observeon.html" target="_blank" rel="noopener">ObserveOn</a></h2><blockquote><p>specify the Scheduler on which an observer will observe this Observable</p></blockquote><p>指定observer将会在哪个Scheduler观察这个Observable.</p><p>更具体的说ObserveOn指示一个Observable在一个特定的调度器上调用观察者的onNext, onError和onCompleted方法，<br>即影响的是<code>subscribe()</code>里的操作.</p><p>简单来讲:<br>使用RxJava，你可以使用subscribeOn()指定观察者代码运行的线程，使用observerOn()指定订阅者运行的线程：</p><p>可能还是不太看得懂,<br>来,show me the code:<br>–出自<a href="http://blog.csdn.net/lzyzsd/article/details/44891933" target="_blank" rel="noopener">这里</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myObservableServices.retrieveImage(url)</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(bitmap -&gt; myImageView.setImageBitmap(bitmap));</span><br></pre></td></tr></table></figure></p><p>上述代码表示,在Subscriber前面执行的代码都是在I/O线程中运行。最后，操作view的代码在主线程中运行.</p><p>PS:<code>AndroidSchedulers.mainThread()</code>是在Android中才有.</p><p>总的来说RxJava操作多线程还是比较简单方便的,而且容易控制.<br>暂时也就只会这么点,以后学习了再补充.<br>接下来应该是RxAndroid了,好开心.  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://blog.csdn.net/lzyzsd/article/details/44891933" target="_blank" rel="noopener">深入浅出RxJava三–响应式的好处</a><br><a href="https://github.com/mcxiaoke/RxDocs/blob/master/Scheduler.md" target="_blank" rel="noopener">RxDoc-Scheduler</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RxJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AndroidStudio导出Jar包</title>
      <link href="/blog/1f1e09b7.html"/>
      <url>/blog/1f1e09b7.html</url>
      
        <content type="html"><![CDATA[<p>工具版本:<br>Gradle 2.4<br>AndroidStuido 1.4Beta3</p><p>在需要打jar包的Module下的<code>build.gradle</code>下配置如下:  </p><pre><code>PS:`rename`可以配置jar名字,`into`可以配置jar输出路径</code></pre><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> clearJar(type: <span class="keyword">Delete</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="string">'build/libs/yutils.jar'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> makeJar(type: <span class="keyword">Copy</span>) &#123;</span><br><span class="line">    <span class="keyword">from</span>(<span class="string">'build/intermediates/bundles/release/'</span>)</span><br><span class="line">    <span class="keyword">into</span>(<span class="string">'build/libs/'</span>)</span><br><span class="line">    <span class="keyword">include</span>(<span class="string">'classes.jar'</span>)</span><br><span class="line">    rename (<span class="string">'classes.jar'</span>, <span class="string">'yutils.jar'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeJar.dependsOn(clearJar, build)</span><br></pre></td></tr></table></figure><p>执行命令:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew makeJar</span><br></pre></td></tr></table></figure></p><p>这样在<code>build/libs/</code>下就能出现你所需要的jar包了.</p><p><img src="http://ww2.sinaimg.cn/large/98900c07gw1ew5b02c58jj209e08ljs0.jpg" alt=""></p><p>参考</p><blockquote><p><a href="http://stackoverflow.com/questions/16763090/how-to-export-library-to-jar-in-android-studio" target="_blank" rel="noopener">how-to-export-library-to-jar-in-android-studio</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AndroidStudio </tag>
            
            <tag> Gradle </tag>
            
            <tag> Jar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AndroidStudio常用快捷键</title>
      <link href="/blog/5a580867.html"/>
      <url>/blog/5a580867.html</url>
      
        <content type="html"><![CDATA[<h2 id="常用快捷键-Mac"><a href="#常用快捷键-Mac" class="headerlink" title="常用快捷键(Mac)"></a>常用快捷键(Mac)</h2><table><thead><tr><th style="text-align:center">Name</th><th>作用</th><th style="text-align:center">快捷键</th></tr></thead><tbody><tr><td style="text-align:center">Find Actions</td><td></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">BookMarks</td><td>书签,可以留下书签,快速跳转到书签位置</td><td style="text-align:center">F3(开关书签),<code>cmd+F3</code>打开书签面板</td></tr><tr><td style="text-align:center"></td><td>查看某个类的继承关系</td><td style="text-align:center">选中要查看的类,<code>ctrl+H</code></td></tr><tr><td style="text-align:center">The Call Hierarchy Popup</td><td>查看某个方法的调用路径</td><td style="text-align:center">选中方法,<code>ctrl+alt+h</code></td></tr><tr><td style="text-align:center">Quick Definition Lookup</td><td>快速查看某个方法或者类的实现</td><td style="text-align:center">选中方法,<code>cmd+Y</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AndroidStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>专业English,让自己更专业</title>
      <link href="/blog/be4a5664.html"/>
      <url>/blog/be4a5664.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录一些专业英语,让自己更专业.</p><h2 id="常用语"><a href="#常用语" class="headerlink" title="常用语"></a>常用语</h2><p>记录常用于Github,SOF,Email的语句,如:礼貌用语.</p><table><thead><tr><th style="text-align:center">句子</th><th style="text-align:center">解释</th><th style="text-align:center">如何应用</th></tr></thead><tbody><tr><td style="text-align:center">In most cases</td><td style="text-align:center">大多数情况下</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Please, explain it a bit more.</td><td style="text-align:center">请再多解释一些</td><td style="text-align:center"></td></tr></tbody></table><h2 id="短语"><a href="#短语" class="headerlink" title="短语"></a>短语</h2><table><thead><tr><th style="text-align:center">短语</th><th style="text-align:center">解释</th><th style="text-align:center">例句/备注</th></tr></thead><tbody><tr><td style="text-align:center">In most cases</td><td style="text-align:center">大多数情况下</td><td style="text-align:center"></td></tr></tbody></table><a id="more"></a><h2 id="专业词汇"><a href="#专业词汇" class="headerlink" title="专业词汇"></a>专业词汇</h2><p>记录一些专业名词,让自己更专业.</p><table><thead><tr><th style="text-align:center">词汇</th><th style="text-align:center">解释</th><th style="text-align:center">例句</th></tr></thead><tbody><tr><td style="text-align:center">encapsulation</td><td style="text-align:center">封装</td><td style="text-align:center">Encapsulation is the packing of data and functions into a single component.</td></tr><tr><td style="text-align:center">inheritance</td><td style="text-align:center">继承</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">High Cohesion</td><td style="text-align:center">高内聚</td><td style="text-align:center">ISP is one of the five SOLID principles of Object-Oriented Design, similar to the High Cohesion Principle of GRASP.[3]</td></tr><tr><td style="text-align:center">decouple</td><td style="text-align:center">解耦</td><td style="text-align:center">ISP is intended to keep a system decoupled and thus easier to refactor, change, and redeploy.</td></tr><tr><td style="text-align:center">concurrency</td><td style="text-align:center">并发</td><td style="text-align:center"></td></tr></tbody></table><h2 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h2><table><thead><tr><th style="text-align:center">缩写</th><th style="text-align:center">全拼</th><th style="text-align:center">概念</th></tr></thead><tbody><tr><td style="text-align:center">OOP</td><td style="text-align:center">Object Oriented Programming</td><td style="text-align:center">面向对象编程</td></tr><tr><td style="text-align:center">AOP</td><td style="text-align:center">Aspect Oriented Programming</td><td style="text-align:center">面向切面编程</td></tr><tr><td style="text-align:center">POJO</td><td style="text-align:center">Plain Old Java Object</td><td style="text-align:center">表示普通的Java对象，不是JavaBean, EntityBean 或者 SessionBean</td></tr><tr><td style="text-align:center">FRP</td><td style="text-align:center">Functional Reactive Programming</td><td style="text-align:center">函数响应式编程</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>一些不太专业的,但是最好知道的.</p><table><thead><tr><th style="text-align:center">词汇</th><th style="text-align:center">解释</th><th style="text-align:center">例句</th></tr></thead><tbody><tr><td style="text-align:center">microseconds</td><td style="text-align:center">微妙</td><td style="text-align:center">in miroseconds</td></tr><tr><td style="text-align:center">data stream</td><td style="text-align:center">流量</td><td style="text-align:center"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pidcat让你的Logcat更美更高效</title>
      <link href="/blog/d519f4ed.html"/>
      <url>/blog/d519f4ed.html</url>
      
        <content type="html"><![CDATA[<h2 id="Pidcat"><a href="#Pidcat" class="headerlink" title="Pidcat"></a><a href="https://github.com/JakeWharton/pidcat" target="_blank" rel="noopener">Pidcat</a></h2><p>JakeWharton大神的logcat辅助工具,只显示你要看的进程,更加美观,体验更好.  </p><p>用法很简单:<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pidcat packagename</span></span><br></pre></td></tr></table></figure></p><p>比如我要看网易云音乐的日志:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidcat com.netease.cloudmusic</span><br></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/98900c07gw1ew2xfcmr5oj20xx0awq8m.jpg" alt="效果图"></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>监听应用安装&amp;卸载&amp;升级</title>
      <link href="/blog/a793d2be.html"/>
      <url>/blog/a793d2be.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为公司有多个App,所以有下载其他app,并监听其安装卸载的功能需求.  </p><p>主要是利用系统广播来实现,简单记录一下.</p><h2 id="定义IntentFilter"><a href="#定义IntentFilter" class="headerlink" title="定义IntentFilter"></a>定义IntentFilter</h2><h3 id="代码定义"><a href="#代码定义" class="headerlink" title="代码定义"></a>代码定义</h3><p>注意要加一个为”package”的<code>scheme</code>!<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">intentFilter.addAction(Intent.ACTION_PACKAGE_ADDED);<span class="comment">//监听应用安装</span></span><br><span class="line">intentFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);<span class="comment">//监听应用卸载</span></span><br><span class="line">intentFilter.addAction(Intent.ACTION_PACKAGE_REPLACED);<span class="comment">//监听应用升级</span></span><br><span class="line">intentFilter.addAction(Intent.ACTION_MY_PACKAGE_REPLACED);<span class="comment">//自己的应用升级</span></span><br><span class="line">intentFilter.addDataScheme(<span class="string">"package"</span>);  <span class="comment">// 必须要</span></span><br><span class="line"><span class="keyword">return</span> intentFilter;</span><br></pre></td></tr></table></figure></p><h3 id="Xml配置"><a href="#Xml配置" class="headerlink" title="Xml配置"></a>Xml配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.PACKAGE_ADDED"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.PACKAGE_REMOVED"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.PACKAGE_REPLACED"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MY_PACKAGE_REPLACED"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"package"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a> <h2 id="处理结果"><a href="#处理结果" class="headerlink" title="处理结果"></a>处理结果</h2><p>获取action判断,<code>intent.getData().getSchemeSpecificPart()</code>获取对应包名,然后进行处理.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String action = intent.getAction();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (action.equals(Intent.ACTION_PACKAGE_ADDED)) &#123;</span><br><span class="line">    String packageName = intent.getData().getSchemeSpecificPart();</span><br><span class="line">    Log.d(TAG, <span class="string">"ACTION_PACKAGE_ADDED:"</span> + packageName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (action.equals(Intent.ACTION_PACKAGE_REMOVED)) &#123;</span><br><span class="line">    String packageName = intent.getData().getSchemeSpecificPart();</span><br><span class="line">    Log.d(TAG,<span class="string">"ACTION_PACKAGE_REMOVED:"</span>+packageName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (action.equals(Intent.ACTION_PACKAGE_REPLACED)) &#123;</span><br><span class="line">    String packageName = intent.getData().getSchemeSpecificPart();</span><br><span class="line">    Log.d(TAG,<span class="string">"ACTION_PACKAGE_REPLACED:"</span>+packageName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>That’s all.<br>代码保存在<a href="https://gist.github.com/AlanCheen/ff81ba84c1bbdb653901" target="_blank" rel="noopener">Gist</a><br>Ps: 应用升级没有测试.</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 监听安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)将Listener转换成Observable</title>
      <link href="/blog/62a7fe97.html"/>
      <url>/blog/62a7fe97.html</url>
      
        <content type="html"><![CDATA[<p>在Java中使用listeners很常见.并且如果你使用RxJava,你会更乐意使用Observable替代listeners.<br>但是如果你不得不处理一个你不能修改源代码的库呢?</p><pre><code>这里有一个简单的方法去创建一个围绕listener的Observable.</code></pre><p>假设我们有个一接口<code>ValueUpdateListener</code>并且一个对象<code>ValueUpdater</code>将会调用我们的listener:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ValueUpdateListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onValueChanged</span><span class="params">(@NonNull String value)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueUpdater</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// in some point of the class...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerListener</span><span class="params">(ValueUpdateListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterListener</span><span class="params">(ValueUpdateListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以创建一个Observable像这样:<br>     译者注:这里有些地方缺少了<code>final</code>关键字.</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">observableListenerWrapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">            ValueUpdateListener listener = <span class="keyword">new</span> ValueUpdateListener() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onValueChanged</span><span class="params">(@NonNull String value)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (subscriber.isUnsubscribed()) &#123;</span><br><span class="line">                        registerListener.unregisterListener(<span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        subscriber.onNext(value);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            registerListener.registerListener(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们只需要去订阅:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">observableListenerWrapper().subscribe(value -&gt; &#123;</span><br><span class="line">    <span class="comment">// do something with the new value</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>注意这个监听将会自动注销如果<code>onValueChanged</code>被调用并且这个observable取消订阅.</p><p>译者注:<br>其实有时候不需要<code>ValueUpdater</code>,更加简单,更多代码可以查看我的<a href="https://github.com/AlanCheen/PracticeDemo/blob/master/PracticeDemos/lib/src/main/java/com/example/rx/ConvertListener.java" target="_blank" rel="noopener">PracticeDemo</a></p><p>阅读<a href="http://www.andreamaglie.com/rxjava-listener-to-observable/" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RxJava </tag>
            
            <tag> 译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava操作符学习笔记</title>
      <link href="/blog/b8a92c8d.html"/>
      <url>/blog/b8a92c8d.html</url>
      
        <content type="html"><![CDATA[<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a><a href="http://reactivex.io/documentation/operators.html" target="_blank" rel="noopener">操作符</a></h2><p>操作符是为了解决对Observable对象的变换的问题，操作符用于在Observable和<em>最终的Subscriber</em>之间修改Observable发出的事件。<br>RxJava提供了很多很有用的操作符。</p><p><strong>Subscribers更应该做的事情是“响应”，响应Observable发出的事件，而不是去修改。</strong></p><p>所以修改就交给操作符吧.</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a><a href="http://reactivex.io/documentation/operators/map.html" target="_blank" rel="noopener">Map</a></h2><blockquote><p>transform the items emitted by an Observable by applying a function to each item</p></blockquote><p>用来把一个事件转换为另一个事件。<br>map()操作符就是用于变换Observable对象的，map操作符返回一个Observable对象，这样就可以实现链式调用，在一个Observable对象上多次使用map操作符，最终将最简洁的数据传递给Subscriber对象。</p><p><img src="https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/map.png" alt="原理"></p><p><img src="http://ww4.sinaimg.cn/large/98900c07gw1ew4dfpnulqj20l1081mxk.jpg" alt="实效"><br>特性:</p><ol><li>它不必返回Observable对象返回的类型，你可以使用map操作符返回一个发出新的数据类型的observable对象。</li><li>可以对一个Observable多次使用map</li></ol><p>用一个例子来练习:</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//刚创建的Observable是String类型的</span></span><br><span class="line">Observable.just(<span class="string">"Hellp Map Operator"</span>)</span><br><span class="line">.map(<span class="keyword">new</span> Func1&lt;String, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2015</span>;<span class="comment">//通过第一个map转成Integer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).map(<span class="keyword">new</span> Func1&lt;Integer, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(integer);<span class="comment">//再通过第二个map转成String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Run起来输出日志:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2015</span></span><br></pre></td></tr></table></figure></p><h2 id="From"><a href="#From" class="headerlink" title="From"></a><a href="http://reactivex.io/documentation/operators/from.html" target="_blank" rel="noopener">From</a></h2><blockquote><p>convert various other objects and data types into Observables</p></blockquote><p><code>from()</code>接收一个集合作为输入，然后<strong>每次输出一个元素</strong>给subscriber.</p><p><img src="http://reactivex.io/documentation/operators/images/from.c.png" alt="from"></p><p>看个例子,将集合的数据都输出:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; s = Arrays.asList(<span class="string">"Java"</span>, <span class="string">"Android"</span>, <span class="string">"Ruby"</span>, <span class="string">"Ios"</span>, <span class="string">"Swift"</span>);</span><br><span class="line">Observable.from(s).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>Log:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Java</span></span><br><span class="line"><span class="keyword">Android</span></span><br><span class="line"><span class="keyword">Ruby</span></span><br><span class="line"><span class="keyword">Ios</span></span><br><span class="line"><span class="keyword">Swift</span></span><br></pre></td></tr></table></figure></p><p>另外<code>from</code>也接受数组类型:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.from(<span class="keyword">new</span> String[]&#123;<span class="string">"Java"</span>,<span class="string">"Android"</span>&#125;).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a><a href="http://reactivex.io/documentation/operators/flatmap.html" target="_blank" rel="noopener">FlatMap</a></h2><blockquote><p>transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable</p></blockquote><p>Observable.flatMap()接收一个Observable的输出作为输入，同时输出另外一个Observable。</p><p><img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMap.png" alt=""></p><p>先加一个函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Observable&lt;List&lt;String&gt;&gt;query()&#123;</span><br><span class="line">        List&lt;String&gt; s = Arrays.asList(<span class="string">"Java"</span>, <span class="string">"Android"</span>, <span class="string">"Ruby"</span>, <span class="string">"Ios"</span>, <span class="string">"Swift"</span>);</span><br><span class="line">        <span class="keyword">return</span> Observable.just(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们打印所有query到的语言:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里的参数是 query所返回的Observable的输出,并且返会一个Observable&lt;String&gt;</span></span><br><span class="line">query().flatMap(<span class="keyword">new</span> Func1&lt;List&lt;String&gt;, Observable&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(List&lt;String&gt; strings)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结合from处理</span></span><br><span class="line">        <span class="keyword">return</span> Observable.from(strings);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"_flatMap:"</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>日志:<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">_from:</span>Java</span><br><span class="line"><span class="symbol">_from:</span>Android</span><br><span class="line"><span class="symbol">_flatMap:</span>Java</span><br><span class="line"><span class="symbol">_flatMap:</span>Android</span><br><span class="line"><span class="symbol">_flatMap:</span>Ruby</span><br><span class="line"><span class="symbol">_flatMap:</span>Ios</span><br><span class="line"><span class="symbol">_flatMap:</span>Swift</span><br></pre></td></tr></table></figure></p><pre><code>注意:query返回的Observable的输出是List&lt;String&gt;,在flatMap中变成了参数,而处理过后,返回一个Observable&lt;String&gt;.</code></pre><p>假设这时候我们需要处理一下所获取的结果,我们加个前缀,在保证不修改subscribe的前提下我们可以这么做:</p><p>增加个函数,用来增加个前缀:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Observable&lt;String&gt;addPre(String lan)&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.just(<span class="string">"addPre_"</span>+lan);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码可以这么写:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">query().flatMap(<span class="keyword">new</span> Func1&lt;List&lt;String&gt;, Observable&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(List&lt;String&gt; strings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.from(strings);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).flatMap(<span class="keyword">new</span> Func1&lt;String, Observable&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//我们在这里调用`addPre`方法,就行处理</span></span><br><span class="line">        <span class="keyword">return</span> addPre(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>输出日志<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">addPre_Java</span></span><br><span class="line"><span class="keyword">addPre_Android</span></span><br><span class="line"><span class="keyword">addPre_Ruby</span></span><br><span class="line"><span class="keyword">addPre_Ios</span></span><br><span class="line"><span class="keyword">addPre_Swift</span></span><br></pre></td></tr></table></figure></p><p>map与flatMap的区别(出自朱凯):</p><p>map 是在一个 item 被发射之后，到达 map 处经过转换变成另一个 item ，然后继续往下走；<br>flapMap 是 item 被发射之后，到达 flatMap 处经过转换变成一个 Observable ，而这个 Observable 并不会直接被发射出去，而是会立即被激活，然后把它发射出的每个 item 都传入流中，再继续走下去。<br>所以 flatMap 和 map 有两个区别：  </p><ol><li>经过 Observable 的转换，相当于重新开了一个异步的流；  </li><li>item 被分散了，个数发生了变化。</li></ol><p>这个flatMap还是比较难以理解,它到底是如何工作的.<br>自己还需要多去了解一下.</p><h2 id="更多操作符"><a href="#更多操作符" class="headerlink" title="更多操作符"></a>更多操作符</h2><ol><li>filter 过滤,把不符合条件的过滤掉,留下符合条件的</li><li>take   指定最多输出的数量</li><li>doOnNext 允许我们在<strong>每次输出一个元素之前</strong>做一些额外的事情(其实就是在<code>onNext</code>里调用的)</li></ol><p>就用一个例子来演示一下吧:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">query().flatMap(<span class="keyword">new</span> Func1&lt;List&lt;String&gt;, Observable&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(List&lt;String&gt; strings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.from(strings);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).flatMap(<span class="keyword">new</span> Func1&lt;String, Observable&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addPre(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).filter(<span class="keyword">new</span> Func1&lt;String, Boolean&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//包含a的留下</span></span><br><span class="line">        <span class="keyword">return</span> s.contains(<span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).take(<span class="number">3</span>)<span class="comment">//最多只取3个</span></span><br><span class="line">  .doOnNext(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//onNext之前 输出一下</span></span><br><span class="line">        System.out.println(<span class="string">"doOnNext:"</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出:<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">doOnNext</span>:<span class="keyword">addPre_Java</span></span><br><span class="line"><span class="keyword">addPre_Java</span></span><br><span class="line"><span class="keyword">doOnNext:addPre_Android</span></span><br><span class="line"><span class="keyword">addPre_Android</span></span><br><span class="line"><span class="keyword">doOnNext:addPre_Ruby</span></span><br><span class="line"><span class="keyword">addPre_Ruby</span></span><br></pre></td></tr></table></figure></p><p>还有很多很多很多操作符需要去学习,这里就列举这么几个.</p><p>参考</p><blockquote><p><a href="http://blog.csdn.net/lzyzsd/article/details/44094895" target="_blank" rel="noopener">深入浅出RxJava(二：操作符)</a><br><a href="http://reactivex.io/documentation/operators.html" target="_blank" rel="noopener">Operators</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RxJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava初探</title>
      <link href="/blog/d288ff8a.html"/>
      <url>/blog/d288ff8a.html</url>
      
        <content type="html"><![CDATA[<h2 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a></h2><blockquote><p>RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.</p></blockquote><p>RxJava 是java的响应式编程的扩展.</p><p>Ps:RxJava 配 Lambda 更合适哦!~<br>不过这里没用Lambda,本文只关心RxJava语法,因为现在是学好基础语法,打好基础的时候,如果你还不知道Lambda的可以看看我的<a href="http://www.jianshu.com/p/d4951ef0d707" target="_blank" rel="noopener">使用Lambda在Android中的替代匿名类</a></p><p>依赖:<code>compile &#39;io.reactivex:rxjava:1.0.12&#39;</code></p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>RxJava最核心的两个东西:</p><ol><li>Observables（被观察者，事件源)</li><li>Subscribers（观察者,用来响应Observables发出的事件）。</li></ol><p>Observables发出一系列事件，Subscribers处理这些事件。<br>这里的事件可以是任何你感兴趣的东西 （触摸事件，web接口调用返回的数据。。。）  </p><p>一个Observable可以发出零个或者多个事件，知道结束或者出错。每发出一个事件，就会调用它的Subscriber的onNext方法，最后调用Subscriber.onNext()或者Subscriber.onError()结束。</p><p>粗看跟观察者模式很相似,但是有一点明显不同，那就是:<br><strong>如果一个Observerble没有任何的的Subscriber，那么这个Observable是不会发出任何事件的。</strong></p><p>Talk is cheap ,show me the code.<br>接下去练习一下~<br><a id="more"></a></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><strong>1. 创建Observable</strong><br>通过<code>Observable.create</code>方法很容易创建<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Observable&lt;String&gt; mStringObservable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">            subscriber.onNext(<span class="string">"Hello Rxjava"</span>);</span><br><span class="line">            <span class="comment">//Notice 如果onCompleted 先调用了,那么后面的onNext onError则会被无视掉,但是不是等同于return,后面其他的代码还是会执行</span></span><br><span class="line">            subscriber.onCompleted();</span><br><span class="line">            System.out.println(<span class="string">"看看onCompleted调用了还会不会有输出"</span>);</span><br><span class="line"><span class="comment">//            subscriber.onError(new Throwable("hehehe"));</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>2. 创建Subscriber</strong></p><p>接着我们创建一个Subscriber来处理Observable对象发出的字符串。</p><p>很简单,只是打印一下数据而已.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Subscriber&lt;String&gt; mStringSubscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"onCompleted"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"onError:"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><p><strong>3. 订阅</strong></p><p>main方法添加代码,run起来~<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  mStringObservable.subscribe(mStringSubscriber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出Log:<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Hello</span> Rxjava</span><br><span class="line"><span class="literal">on</span>Completed</span><br><span class="line">看看<span class="literal">on</span>Completed调用了还会不会有输出</span><br></pre></td></tr></table></figure></p><p>注意点:</p><ol><li>如果调用了<code>subscriber.onCompleted()</code>,那么在<code>onCompleted</code>后调用的<code>onNext</code>和<code>onError</code>都不会生效.</li></ol><p>其实如果Rx真的每次都需要这么写的话,真的是比Java还啰嗦,接下去练习更简洁的方法.</p><h2 id="简化代码"><a href="#简化代码" class="headerlink" title="简化代码"></a>简化代码</h2><p>Observable.just方法可以用来创建只发出一个事件就结束的Observable对象<br>上面创建Observable对象的代码可以简化为一行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Observable&lt;String&gt; simpleObservable = Observable.just(<span class="string">"Hell,simple observable"</span>);</span><br></pre></td></tr></table></figure><p>跟踪一下<code>just</code>方法的代码到<code>ScalarSynchronousObservable</code>类,会发现,其实它就是创建了一个OnSubscribe对象,顺便帮忙调用了<code>onNext</code>和<code>onCompleted</code>:<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ScalarSynchronousObservable</span><span class="params">(<span class="keyword">final</span> T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> OnSubscribe&lt;T&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">                s.onNext(t);</span><br><span class="line">                s.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>同样,订阅一下试试~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simpleObservable.subscribe(mStringSubscriber);</span><br></pre></td></tr></table></figure><p>输出Log:<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Hell,</span>simple observable</span><br><span class="line">onCompleted</span><br></pre></td></tr></table></figure></p><h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><p>RxJava中还有<code>Action1</code>和<code>Action0</code>这两个类.</p><p>另外<br><code>subscribe</code>方法有一个重载版本，接受三个<code>Action</code>类型的参数，分别对应OnNext，OnComplete， OnError函数。</p><pre><code>subscribe(onNextAction, onErrorAction, onCompleteAction);</code></pre><p>如果我们并不关心<code>OnComplete</code>和<code>OnError</code>,那么完全可以用<code>Action1</code>来替代上面所写:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Action1&lt;String&gt; onNextAction = <span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Action1&lt;String&gt; onNextAction:"</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在main中增加:<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mStringObservable.subscribe(onNextAction)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>run起来~<br>Log:<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Action1<span class="variable">&lt;String&gt;</span> <span class="keyword">on</span>NextAction:Hello Rxjava</span><br></pre></td></tr></table></figure></p><p>那么再写一下onComplete和onError看:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 注意是:Throwable</span></span><br><span class="line"><span class="keyword">static</span> Action1&lt;Throwable&gt; onErrorAction = <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Action1&lt;Throwable&gt; onErrorAction:"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Action0</span></span><br><span class="line"><span class="keyword">static</span> Action0 onCompleteAction = <span class="keyword">new</span> Action0() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Action0 onCompleteAction:"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Notice  如果调用onError 这个单个的onNextAction 会报错</span></span><br><span class="line">mStringObservable.subscribe(onNextAction);</span><br><span class="line">mStringObservable.subscribe(onNextAction, onErrorAction);</span><br><span class="line">mStringObservable.subscribe(onNextAction, onErrorAction, onCompleteAction);</span><br></pre></td></tr></table></figure><p><strong>需要注意的是<code>onErrorAction</code> 接收的是<code>Throwable</code>,onComplete无类型</strong><br><strong>另外如果<code>call</code>里面调用了<code>onError</code>则会报错:</strong><br><code>Exception in thread &quot;main&quot; rx.exceptions.OnErrorNotImplementedException: hehehe</code></p><p>再简化,单个Action1可以简化成:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"Hello simple onaction1"</span>).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>输出日志:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello<span class="built_in"> simple </span>onaction1</span><br></pre></td></tr></table></figure></p><p>好了,基本语法部分例子学完了,例子很简单,到此结束,下一篇Rx操作符.</p><p>参考/更多</p><blockquote><p><a href="http://blog.danlew.net/tag/rxjava/page/2/" target="_blank" rel="noopener">Dan Lew大神Rx系列</a><br><a href="https://github.com/lzyzsd/Awesome-RxJava" target="_blank" rel="noopener">大头鬼整理</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RxJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>听说每个人都会写单例,你会了吗?</title>
      <link href="/blog/3c3b98ce.html"/>
      <url>/blog/3c3b98ce.html</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式(Singleton Pattern)"></a>单例模式(Singleton Pattern)</h2><p>当我们有这样的需求:<strong>某一些类应该只存在一个实例</strong> 的时候,我们就可以用单例模式来应对.  </p><pre><code>单例模式:确保一个类只有一个实例,并提供一个全局访问点.</code></pre><p>单例模式是所有设计模式中最简单的一个,也是大部分人最早知道的一个设计模式.</p><p>但是即使是最简单的,也有很多可以推敲的细节,要做得对也不简单.</p><h2 id="经典的单例"><a href="#经典的单例" class="headerlink" title="经典的单例"></a>经典的单例</h2><p>相信大家一定写过这样类似的单例模式代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton ins;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getIns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == ins) &#123;</span><br><span class="line">            ins = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ins;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简单总结一下这样的写法:</p><ol><li>提供一个全局静态的<code>getIns</code>方法,使得易于使用.</li><li>延迟Singleton的实例化,节省资源(所谓的<em>懒汉式</em>).</li><li>缺点是线程不安全.当多个线程同时进入<code>if (null == ins) {}</code>的时候就会创建多个实例.</li></ol><p>OK,接下来我们看来是要解决多线程不安全的问题了.  </p><a id="more"></a><h2 id="多线程安全"><a href="#多线程安全" class="headerlink" title="多线程安全"></a>多线程安全</h2><p>这个时候可能有的人就说了,这个太简单了,加一个<code>synchronized</code>不就结了吗?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getIns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == ins) &#123;</span><br><span class="line">        ins = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ins;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>确实,增加<code>synchronized</code>之后能够迫使每个线程在进入这个方法之前,要先等别的线程离开该方法.也即避免了多个线程同时进入<code>getIns</code>方法.</p><p>诚然这个能解决问题,但是我们知道<code>synchronized</code>是非常耗性能的.<br>更何况:<br><strong>我们只需要在第一次执行这个方法的时候同步,也就是说当ins实例化后,我们不再需要同步了</strong><br><strong>而如果我们加了<code>synchronized</code>,那么实例化后的每次调用<code>getIns</code>都是一种多余的消耗操作,是累赘</strong></p><pre><code>Ps:当然,如果哪些额外的负担你能接受(比如用的很少),那么添加`synchronized`的方法也是可以接受的,毕竟这是最简单的方式.</code></pre><p>那么问题来了,如何改善?<br>如何确保单例,而又不影响性能?</p><h2 id="性能进阶"><a href="#性能进阶" class="headerlink" title="性能进阶"></a>性能进阶</h2><p>接下去介绍一种更优秀的,线程安全的单例写法—双重检查锁模式(double check locking pattern)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheck ins;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheck</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheck <span class="title">getIns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span>==ins)&#123; <span class="comment">//检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheck.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == ins) &#123; <span class="comment">//又检查一次</span></span><br><span class="line">                    ins = <span class="keyword">new</span> DoubleCheck();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ins;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的ins用了<code>volatile</code>关键字来修饰,为什么呢?<br>因为执行<code>ins = new DoubleCheck()</code>做了很多事情:</p><ol><li>给ins分配内存</li><li>调用构造函数来初始化成员变量(可能会很久)</li><li>将ins对象指向分配的内存空间（执行完这步 ins才不为null）</li></ol><p>上面的操作并不是原子操作,而jvm也可能重排序指令,导致第二三两步的执行顺序可能会被打乱,当第3步先于第2步完成,那么会导致有线程拿到了初始化未完毕的ins,那么就会错误,而这里利用了<code>volatile</code>的<strong>禁止指令重排序优化</strong>特性,用来解决这个问题.</p><p>  注:volatile 在java 5 后才有效,原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的,当然现在不需要担心这个啦!</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>双重检查非常适用于高并发,我们熟知的开源库<code>Eventbus</code>,<code>ImageLoader</code>等都是用的双重检查锁方式实现单例  </p><p>不过它,写起来稍微复杂了些,有没有简单点的呢?<br>答案是:有!  </p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>直接上代码吧<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Early</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Early ins = <span class="keyword">new</span> Early();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Early <span class="title">getIns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ins;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  饿汉式的原理其实是<strong>基于classloder机制</strong>来避免了多线程的同步问题  </p><p>饿汉式与之前提到的懒汉式不同,它在我们调用getIns之前就实例化了(在类加载的时候就实例化了),所以不是一个懒加载,这样就有几个缺点:  </p><ol><li>延长了类加载时间</li><li>如果没用到这个类,就浪费了资源(加载了但是没用它)</li><li>不能传递参数(很显然适用的场景会减少)</li></ol><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类原理同上,另外虽然它看上去有点饿汉式,但是与之前的饿汉有点不同,它在类<code>Singleton</code>加载完毕后并没有实例化,而是当调用<code>getIns</code>去加载Holder的时候才会实例化,静态内部类的方式把实例化延迟到了内部类的加载中去了!所以它比饿汉式更优秀!(偷偷告诉你Effective Java中也推荐这个方式)  </p><p>例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getIns</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>最后介绍一种,也是我在 EffectiveJava中看到的,但是在开发中我重来没看到过!<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>优点:<strong>简单,线程安全,防反序列化.</strong><br>本人不太了解,也没用过,所以不敢乱说了~~~<br>值得一提的是 EffectiveJava 也提倡这个方式  </p><h2 id="这样真的就能保证单例是个单例了吗"><a href="#这样真的就能保证单例是个单例了吗" class="headerlink" title="这样真的就能保证单例是个单例了吗?"></a>这样真的就能保证单例是个单例了吗?</h2><p>我们采用了很多方式来保证实例的唯一性,但是真的够了吗?<br>如果采用反射呢?<br>如果使用多个ClassLoder呢?<br>那是不是会实例化多个了呢?<br>思考一下吧~  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单例的实现方式有好多种,实际开发中看需求而定,个人比较推荐双重检查锁和静态内部类,这两个我比较常用,其他的说实话我一般不用.<br>同时也可以看到单例也有很多需要学习以及思考的地方,完全弄懂也不容易~</p><p>给自己定了一个每周一个设计模式的学习计划,希望能够坚持下去吧.<br>以上代码可以在<a href="https://github.com/AlanCheen/DesignPattern/tree/master/designpattern/src/main/java/com/example/singleton" target="_blank" rel="noopener">我的Github上找到</a>,好了,就这样,下次见.</p><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>聊完了单例的实现方式,其实单例还有一些比较有趣的,值得思考讨论的地方,下面推荐几个,有兴趣的可以去看看~</p><ol><li><a href="http://stackoverflow.com/questions/5582881/singleton-and-static-utility-classes" target="_blank" rel="noopener">单例还是Util?</a></li><li><a href="http://programmers.stackexchange.com/questions/235527/when-to-use-a-singleton-and-when-to-use-a-static-class" target="_blank" rel="noopener">什么时候该使用单例?</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神器JitPack</title>
      <link href="/blog/ac85740b.html"/>
      <url>/blog/ac85740b.html</url>
      
        <content type="html"><![CDATA[<h2 id="神器JitPack"><a href="#神器JitPack" class="headerlink" title="神器JitPack"></a>神器<a href="https://jitpack.io/" target="_blank" rel="noopener">JitPack</a></h2><p>上一次我写了一篇文章关于自己上传library到JCenter的经历,传送门:<a href="/2015/09/06/将Library上传到Jcenter">将Library上传到Jcenter</a><br>需要一大堆配置,接下来介绍一个神器:JitPack.</p><blockquote><p>Easy to use package repository for GitHub</p></blockquote><p>正如官网所写,它是基于github的,而且非常easy,easy地有点吓人!</p><p>不说了,谁用谁知道.</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> JitPack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将Library上传到Jcenter</title>
      <link href="/blog/55bce092.html"/>
      <url>/blog/55bce092.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>习惯了<code>compile &#39;com.android.support:appcompat-v7:22.2.0&#39;</code>这样一句话帅气的引用某个库.</p><p>这次自己尝试一下如何上传到’JCenter’~</p><p>工具: AndroidStudio,Gradle</p><h2 id="申请Bintray账号"><a href="#申请Bintray账号" class="headerlink" title="申请Bintray账号"></a>申请<a href="https://bintray.com/" target="_blank" rel="noopener">Bintray</a>账号</h2><p>Bintray可以用Github账号登陆,很方便.</p><p>注册完,拿到昵称和ApiKey</p><p>获取方式,点击Edit:<br><img src="http://ww2.sinaimg.cn/large/98900c07gw1evxi1m3tdmj20a906qgly.jpg" alt="点击Edit"></p><p>然后点击API Key:<br><img src="http://ww3.sinaimg.cn/large/98900c07gw1evxi3s6m1jj20ri0cbgmu.jpg" alt="APIKey"></p><p>做过第三方授权登录的同学应该都知道apikey吧,上传到JCenter我们同样需要.</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在上传之前,我们需要做一些配置.<br><a id="more"></a></p><h3 id="配置项目"><a href="#配置项目" class="headerlink" title="配置项目"></a>配置项目</h3><p>修改项目里的<code>build.gradle</code>(注意是项目不是库)<br>增加这两个dependencies:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">classpath</span> <span class="string">'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0'</span></span><br><span class="line"><span class="keyword">classpath</span> <span class="string">'com.github.dcendents:android-maven-gradle-plugin:1.3'</span></span><br></pre></td></tr></table></figure></p><p>增加后如下:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">'com.android.tools.build:gradle:1.3.0'</span></span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0'</span></span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">'com.github.dcendents:android-maven-gradle-plugin:1.3'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><!-- more --><h3 id="配置Library"><a href="#配置Library" class="headerlink" title="配置Library"></a>配置Library</h3><p>library的配置比较麻烦,我把所有的配置都贴出来好了,虽然比较粗糙,但是还能看懂.<br>我就不一步一步写了,相信你可以的!~<br>注意看清楚需要配置的地方就行!<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.library'</span></span><br><span class="line">apply plugin: <span class="string">'com.github.dcendents.android-maven'</span></span><br><span class="line">apply plugin: <span class="string">'com.jfrog.bintray'</span></span><br><span class="line"><span class="comment">//apply plugin: 'bintray-release'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个version是区分library版本的，因此当我们需要更新library时记得修改这个version</span></span><br><span class="line"><span class="comment">// 这个version影响后面的引用</span></span><br><span class="line">version = <span class="string">"0.0.2"</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    resourcePrefix <span class="string">"cc_"</span> <span class="comment">//随意填写</span></span><br><span class="line"></span><br><span class="line">    compileSdkVersion <span class="number">22</span></span><br><span class="line">    buildToolsVersion <span class="string">"22.0.1"</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion <span class="number">9</span></span><br><span class="line">        targetSdkVersion <span class="number">22</span></span><br><span class="line">        versionCode <span class="number">2</span></span><br><span class="line">        versionName <span class="string">"1.1"</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line">    testCompile <span class="string">'junit:junit:4.12'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:22.2.0'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:recyclerview-v7:22.2.0'</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> siteUrl = <span class="string">'https://github.com/AlanCheen/CrashCatcher'</span>   <span class="comment">// 项目的主页</span></span><br><span class="line"><span class="keyword">def</span> gitUrl = <span class="string">'git@github.com:AlanCheen/CrashCatcher.git'</span>   <span class="comment">// Git仓库的url</span></span><br><span class="line"><span class="keyword">group</span> = <span class="string">"yifeiyuan.library.crashcatcher"</span>            <span class="comment">// Maven Group ID for the artifact，一般填你唯一的包名</span></span><br><span class="line">install &#123;</span><br><span class="line">    <span class="keyword">repositories</span>.mavenInstaller &#123;</span><br><span class="line">        <span class="comment">// This generates POM.xml with proper parameters</span></span><br><span class="line">        pom &#123;</span><br><span class="line">            <span class="keyword">project</span> &#123;</span><br><span class="line">                packaging <span class="string">'aar'</span></span><br><span class="line">                <span class="comment">// Add your description here</span></span><br><span class="line">                name <span class="string">'Android CrashCatcher'</span> <span class="comment">//项目的描述 你可以多写一点</span></span><br><span class="line">                url siteUrl</span><br><span class="line">                <span class="comment">// Set your license</span></span><br><span class="line">                licenses &#123;</span><br><span class="line">                    license &#123;</span><br><span class="line">                        name <span class="string">'The Apache Software License, Version 2.0'</span></span><br><span class="line">                        url <span class="string">'http://www.apache.org/licenses/LICENSE-2.0.txt'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                developers &#123;</span><br><span class="line">                    developer &#123;</span><br><span class="line">                        id <span class="string">'alancheen'</span><span class="comment">//填写的一些基本信息</span></span><br><span class="line">                        name <span class="string">'程序亦非猿'</span></span><br><span class="line">                        email <span class="string">'alancheen06@gmail.com'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                scm &#123;</span><br><span class="line">                    connection gitUrl</span><br><span class="line">                    developerConnection gitUrl</span><br><span class="line">                    url siteUrl</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">task</span> sourcesJar(type: Jar) &#123;</span><br><span class="line">    <span class="keyword">from</span> android.<span class="keyword">sourceSets</span>.main.java.srcDirs</span><br><span class="line">    classifier = <span class="string">'sources'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">task</span> javadoc(type: Javadoc) &#123;</span><br><span class="line">    <span class="keyword">source</span> = android.<span class="keyword">sourceSets</span>.main.java.srcDirs</span><br><span class="line">    <span class="keyword">classpath</span> += <span class="keyword">project</span>.files(android.getBootClasspath().<span class="keyword">join</span>(<span class="keyword">File</span>.pathSeparator))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">task</span> javadocJar(type: Jar, dependsOn: javadoc) &#123;</span><br><span class="line">    classifier = <span class="string">'javadoc'</span></span><br><span class="line">    <span class="keyword">from</span> javadoc.<span class="keyword">destinationDir</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">artifacts</span> &#123;</span><br><span class="line">    archives javadocJar</span><br><span class="line">    archives sourcesJar</span><br><span class="line">&#125;</span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties()</span><br><span class="line">properties.load(<span class="keyword">project</span>.rootProject.<span class="keyword">file</span>(<span class="string">'local.properties'</span>).newDataInputStream())</span><br><span class="line">bintray &#123;</span><br><span class="line">    user = properties.getProperty(<span class="string">"bintray.user"</span>)</span><br><span class="line">    key = properties.getProperty(<span class="string">"bintray.apikey"</span>)</span><br><span class="line">    <span class="keyword">configurations</span> = [<span class="string">'archives'</span>]</span><br><span class="line">    pkg &#123;</span><br><span class="line">        repo = <span class="string">"maven"</span></span><br><span class="line">        name = <span class="string">"CrashCatcher"</span><span class="comment">//发布到JCenter上的项目名字</span></span><br><span class="line">        websiteUrl = siteUrl</span><br><span class="line">        vcsUrl = gitUrl</span><br><span class="line">        licenses = [<span class="string">"Apache-2.0"</span>]</span><br><span class="line">        publish = <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="配置apikey和昵称"><a href="#配置apikey和昵称" class="headerlink" title="配置apikey和昵称"></a>配置apikey和昵称</h3><p>打开项目的<code>local.properties</code>,加入以下两句:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bintray.<span class="attribute">user</span>=your_user_name</span><br><span class="line">bintray.<span class="attribute">apikey</span>=your_apikey</span><br></pre></td></tr></table></figure><blockquote><p>PS: 这个文件必须忽略掉,不能上传到github上去哦~~</p></blockquote><h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p>好了,万事俱备,我们开始执行命令:<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./gradlew</span> install</span><br><span class="line"><span class="string">./gradlew</span> bintrayUpload</span><br></pre></td></tr></table></figure></p><p>等待上传完毕,然后去自己的<a href="https://bintray.com/alancheen/maven" target="_blank" rel="noopener">仓库首页</a>找到该库,点击Add TO JCenter,然后发送,接下来就是等待!~</p><p><img src="http://ww4.sinaimg.cn/large/98900c07gw1evxied7oyoj20rf0ezjtt.jpg" alt="示意图"></p><p>等到管理回复,我的大概是6个多小时(可能是我晚上发的原因吧),第一次会比较长,如果是更新的话很快的!</p><p><img src="http://ww3.sinaimg.cn/large/98900c07gw1evxihv7cn5j20rh04qmxl.jpg" alt="如图"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>按照语法规则来拼写路径:<br>groupId:库的名字:版本号<br>所得:<code>yifeiyuan.library.crashcatcher:crashcatcher:0.0.2</code></p><p>接下来添加依赖一句话即可:<br><code>compile &#39;yifeiyuan.library.crashcatcher:crashcatcher:0.0.2&#39;</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第一次配置比较麻烦,不过相信成功后的成就感还是满满的~~</p><p>其实还有更好的工具!可以看看参考,慢慢来~</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://blog.saymagic.cn/2015/02/16/release-library-to-jcenter.html" target="_blank" rel="noopener">http://blog.saymagic.cn/2015/02/16/release-library-to-jcenter.html</a></p></blockquote><blockquote><p><a href="https://www.virag.si/2015/01/publishing-gradle-android-library-to-jcenter/" target="_blank" rel="noopener">https://www.virag.si/2015/01/publishing-gradle-android-library-to-jcenter/</a></p></blockquote><blockquote><p><a href="https://github.com/andforce/release-android-lib-to-jcenter/blob/master/README.md" target="_blank" rel="noopener">https://github.com/andforce/release-android-lib-to-jcenter/blob/master/README.md</a></p></blockquote><blockquote><p> <a href="http://inthecheesefactory.com/blog/how-to-upload-library-to-jcenter-maven-central-as-dependency/en" target="_blank" rel="noopener">How to distribute your own Android library through jCenter and Maven Central from Android Studio</a></p></blockquote><blockquote><p><a href="https://www.virag.si/2015/01/publishing-gradle-android-library-to-jcenter/" target="_blank" rel="noopener">publishing-gradle-android-library-to-jcenter</a></p></blockquote><blockquote><p><a href="http://theartofdev.com/2015/02/19/publish-android-library-to-bintray-jcenter-aar-vs-jar-and-optional-dependency/" target="_blank" rel="noopener">http://theartofdev.com/2015/02/19/publish-android-library-to-bintray-jcenter-aar-vs-jar-and-optional-dependency/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JCenter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式开篇之设计原则</title>
      <link href="/blog/3a04ba73.html"/>
      <url>/blog/3a04ba73.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>PS:本人边学边记录,所以可能有欠缺有错误有不足之处,还望指导!</p></blockquote><p>在学习设计模式之前我们有必要先了解一下一些设计原则.<br>其实设计原则也是从设计模式里来的,所以暂时不需要太理解,毕竟光看原则可能有时候理解不了.</p><h2 id="SOLID设计原则"><a href="#SOLID设计原则" class="headerlink" title="SOLID设计原则)"></a><a href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design" target="_blank" rel="noopener">SOLID设计原则</a>)</h2><p>讲设计原则,则不得不先提一下SOLID设计原则.<br>它的每个字母分别代表一个原则,接下来分别介绍一下.</p><h3 id="单一职责原则-SRP"><a href="#单一职责原则-SRP" class="headerlink" title="单一职责原则(SRP)"></a><a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank" rel="noopener">单一职责原则(SRP)</a></h3><p><strong>单一职责原则（Single Responsibility Principle,SRP）</strong>  </p><blockquote><p>a class should have only a single responsibility (i.e. only one potential change in the software’s specification should be able to affect the specification of the class)</p></blockquote><p>简单来说就是:<strong><em>一个类应该只有一个职责</em></strong>(只有<strong>一个</strong>潜在的改变能影响这个类);  </p><p>每一个引起类变化的原因就是一个职责,当类具有多职责时,应该把多余职责分离出去,分别创建类来完成,<br>否则这个类的耦合度会不断提升,不利于维护等.  </p><p>比如某些所谓的多功能道具,集多少多少功能于一体,吹得很牛逼,结果呢?其中一个坏了,整个都坏了,全完蛋.</p><p>如果说我们的代码也这样,一个类又有Http请求又有IO操作的方法又封装了各种Util方法,背负各种职责,耦合度高得能吓死你,还怎么快乐地敲代码?</p><p>SRP的优点很明显:<strong>高内聚,低耦合,类结构逻辑清晰明了,提高了可读性,同时也易于维护</strong></p><a id="more"></a><h3 id="开闭原则-OCP"><a href="#开闭原则-OCP" class="headerlink" title="开闭原则(OCP)"></a><a href="https://en.wikipedia.org/wiki/Open/closed_principle" target="_blank" rel="noopener">开闭原则(OCP)</a></h3><p><strong>开闭原则（Open Closed Principle）</strong></p><blockquote><p>“software entities(classes, modules, functions, etc.) should be open for extension, but closed for modification.”</p></blockquote><p><strong><em>实体(类,模块..等)应该对扩展开放,对修改关闭.</em></strong><br>也就是说实体可以做到<strong>不修改源代码就可以实现功能扩展</strong>.  </p><p>比如我们实现了功能A,测试完后发布.后来我们需要增加功能,在不得已的情况下我们最好是对原有的代码功能实现扩展,而不是去修改原来的代码.<br>因为原来的代码经过了测试,而我们再次去修改很有可能破坏原来的代码,或者带来Bug,所以我们需要对修改关闭.  </p><p>做到开闭原则可以做到<strong>稳定,可扩展</strong>   </p><p>But,臣妾表示做不到啊!</p><h3 id="里氏代换原则-L"><a href="#里氏代换原则-L" class="headerlink" title="里氏代换原则(L)"></a><a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" rel="noopener">里氏代换原则(L)</a></h3><p>里氏代换原则（Liskov Substitution Principle,LSP）</p><blockquote><p>It states that, in a computer program, if S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e., objects of type S may substitute objects of type T) without altering any of the desirable properties of that program (correctness, task performed, etc.).</p></blockquote><p>简单来说就是:<strong><em>父类可以出现的地方,子类也可以出现,父类都可以被子类代替而无需改动.</em></strong>  </p><p>其实这原则就是运用了继承,多态的特性,在很多设计模式中都有体现.  </p><p>其实这个原则要求我们做的也很好理解,这么做就可以用一个方法符合所有T的类型,节省代码.  </p><h3 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则(ISP)"></a><a href="https://en.wikipedia.org/wiki/Interface_segregation_principle#cite_note-RoleInterface-2" target="_blank" rel="noopener">接口隔离原则(ISP)</a></h3><p><strong>接口隔离原原则（Interface Segregation Principle,ISP）</strong></p><blockquote><p> (ISP) states that no client should be forced to depend on methods it does not use.</p></blockquote><p><strong><em>客户端不应该被强迫地依赖那些根本用不上的方法.</em></strong><br>什么意思?<br>假设有个接口A,A有三个方法,而我们的类B需要其中的某一个,如果让B实现A那么B就会多依赖两个用不上的方法,这就违背了该原则.<br>另外这么做还有另外一个非常大的隐患,如果我们改变了A的其他两个方法,那么会影响到B.  </p><p>在Java源码中我们可以找到很多接口都只有一个方法,比如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T another)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实原因就在这个接口隔离原则上.</p><blockquote><p> ISP is intended to keep a system decoupled and thus easier to refactor, change, and redeploy.</p></blockquote><p>接口隔离原则优点:</p><ol><li>让我们的程序解耦,更容易重构,改变,重新部署.</li></ol><p>另外个人觉得接口隔离原则跟SRP其实挺类似,它也可以<strong>提高内聚,降低耦合,提升可读性</strong>~</p><h3 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则(DIP)"></a><a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" target="_blank" rel="noopener">依赖倒置原则(DIP)</a></h3><p><strong>依赖倒置原则（Dependency Inversion Principle）</strong>  </p><blockquote><p>the dependency inversion principle refers to a specific form of decoupling software modules. When following this principle, the conventional dependency relationships established from high-level, policy-setting modules to low-level, dependency modules are inverted (i.e. reversed), thus rendering high-level modules independent of the low-level module implementation details.</p></blockquote><p>简单说就是:<strong><em>高级模块独立于低级模块的实现细节.</em></strong></p><p>DIP指明了:</p><ol><li>高级模块不应该依赖低级模块,它们都应该依赖于抽象.</li><li>抽象不应该依赖细节.细节应该依赖于抽象.</li></ol><h2 id="其他必须知道的原则"><a href="#其他必须知道的原则" class="headerlink" title="其他必须知道的原则"></a>其他必须知道的原则</h2><h3 id="DRY"><a href="#DRY" class="headerlink" title="DRY"></a>DRY</h3><p><strong><em>Don’t repeat yourself.</em></strong><br>不要重复自己,也许你听过很多次,但它绝不是复制黏贴那么简单.</p><h3 id="优先使用组合-少用继承"><a href="#优先使用组合-少用继承" class="headerlink" title="优先使用组合,少用继承"></a>优先使用组合,少用继承</h3><p>在EffectiveJava 和HeadFirstDesignPattern里不止一次看到优先使用组合的建议.<br>继承的缺点可不少.</p><h3 id="针对接口编程-而不是实现"><a href="#针对接口编程-而不是实现" class="headerlink" title="针对接口编程,而不是实现"></a>针对接口编程,而不是实现</h3><p>这里的接口指<code>interface</code>和<code>抽象</code>.</p><h3 id="封装变化"><a href="#封装变化" class="headerlink" title="封装变化"></a>封装变化</h3><p>把经常变化的代码封装起来,与不变的代码隔离开.</p><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a><a href="https://zh.wikipedia.org/wiki/%E5%BE%97%E5%A2%A8%E5%BF%92%E8%80%B3%E5%AE%9A%E5%BE%8B" target="_blank" rel="noopener">迪米特法则</a></h3><p>迪米特法则    (Law of Demeter Principle),也称为“最少知识原则（Principle of Least Knowledge)<br>wiki百科的解释挺好的,我就照搬过来了,如下:</p><ol><li>每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元；</li><li>每个单元只能和它的朋友交谈：不能和陌生单元交谈；</li><li>只和自己直接的朋友交谈。</li></ol><p>很多面向对象程序设计语言用”.”表示对象的域的解析算符，因此得墨忒耳定律可以简单地陈述为“只使用一个.算符”。    因此，a.b.Method()违反了此定律，而a.Method()不违反此定律。<br>一个简单例子是，人可以命令一条狗行走（walk），但是不应该直接指挥狗的腿行走，应该由狗去指挥控制它的腿如何行走。</p><ul><li>优点</li></ul><p>使得软件更好的可维护性与适应性。<br>因为对象较少依赖其它对象的内部结构,可以改变对象容器（container）而不用改变它的调用者（caller）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果我们的目标是:<code>Reliable,Scalable,Maintainable.</code>,那么设计原则可以帮助我们实现,学习理解设计原则对编码大有裨益!~<br>理论需要与实际结合,多在写代码的时候考虑一下,对提高代码质量有很大的帮助~<br>好了,这次就写那么一点点,如有错误,欢迎批评指正,也欢迎交流!  </p><h2 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h2><p>HeadFirstDesignPattern.<br>Effective Java.</p><h2 id="参考-更多"><a href="#参考-更多" class="headerlink" title="参考/更多"></a>参考/更多</h2><blockquote><p><a href="http://colobu.com/2015/03/05/10-object-oriented-design-principles-you-should-know/" target="_blank" rel="noopener">http://colobu.com/2015/03/05/10-object-oriented-design-principles-you-should-know/</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0922/3499.html" target="_blank" rel="noopener">编程经验之接口分离原则</a><br><a href="http://blog.csdn.net/yanbober/article/details/45312127" target="_blank" rel="noopener">设计模式之面向对象与类基础特征概念</a>  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式前传之面向对象基础</title>
      <link href="/blog/a36d0fc4.html"/>
      <url>/blog/a36d0fc4.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>PS:本人边学变写,由于本人能力有限,所以在理解、解释等各方面一定会有所欠缺,如果有什么不对或者不足之处,非常欢迎各位在各种渠道批评指点!<br>另外设计模式系列会跟随自己的能力or理解or别人的指导不定期更新</p></blockquote><p>面向对象(Object-Oriented,OO)是基础中的基础,亦是重中之重.<br>面向对象学得好,才能顺利地往设计模式的方向继续前行.</p><p>JAVA面向对象最重要的特征就是：封装，继承，多态(所谓的三大特征)。<br>就个人体会来简单讲一下.</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装通过合并特征和行为来创建新的数据类型.</p><h3 id="个人体会"><a href="#个人体会" class="headerlink" title="个人体会:"></a>个人体会:</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>封装有个好处是<em>实现隐藏</em>:<br>通过将细节<strong>私有化</strong>把接口和实现分离开来.  </p><p>个人觉得封装的主要意义有:  </p><ol><li>保护私有数据,只提供方法给外部调用  </li><li>抽象出方法,做成util,统一处理,复用,提高效率</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>记住不要过度封装!</p><a id="more"></a><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在Java中,对应<code>extends</code>关键字.</p><h3 id="个人体会-1"><a href="#个人体会-1" class="headerlink" title="个人体会:"></a>个人体会:</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>子类继承父类后拥有父类的属性成员,可以很好的复用已有的类,不需要再重复写方法属性了.</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>刚开始学习继承的时候很喜欢用,但是后来渐渐地发现继承其实有很大的缺点:</p><ol><li>继承很重,子类拥有父类的所有东西,不管要不要,有没有用.</li><li>父类一改,牵动所有的子类,很明显这不是我们所希望发生的.</li></ol><p>所以提倡组合,而少用继承.</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>在面向对象的程序设计语言中,多态是数据抽象和继承之后的第三种基本特征.<br>多态也称作动态绑定、后期绑定或运行时绑定.</p><h3 id="个人体会-2"><a href="#个人体会-2" class="headerlink" title="个人体会:"></a>个人体会:</h3><p>多态通过分离做什么和怎么做,从另外一个角度<strong>将接口和实现分离开来</strong>；  </p><p>多态不但能够改善代码的组织结构和可读性,还能够创建可扩展的程序。</p><p>说多态是最重要的基本特征也不为过吧。</p><h4 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h4><ol><li>扩展性</li><li>灵活性</li><li>可替换性</li><li>可扩充性</li><li>简化性</li></ol><p>多态的作用:  </p><ol><li>消除类型之间的耦合关系  </li><li>可实现动态绑定,增加可扩展性.  </li></ol><p>多态在设计模式中扮演着非常非常重要的角色.<br>策略模式,里氏替换原则等就是多态的特性的最好阐述.</p><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ol><li>在定位代码的时候比较麻烦,需要去寻找具体的实现类。（有时候根本找不到- -）  </li></ol><h2 id="资料"><a href="#资料" class="headerlink" title="资料:"></a>资料:</h2><blockquote><p>Thinking in Java<br>Effective Java</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NDK初探</title>
      <link href="/blog/a300b2a7.html"/>
      <url>/blog/a300b2a7.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原本老大让我了解一下NDK的,于是有了本笔记.<br>Ps:本人开发环境是Mac,工具是AS.</p><h2 id="下载NDK"><a href="#下载NDK" class="headerlink" title="下载NDK"></a>下载NDK</h2><p><a href="http://developer.android.com/intl/zh-cn/ndk/downloads/index.html" target="_blank" rel="noopener">NDK下载</a></p><p>我新建了个ndk目录,把下载的文件放了进去.  </p><p>接着进入该目录,执行命令:<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod a+<span class="keyword">x</span> android-ndk-r<span class="number">10</span><span class="keyword">c</span>-darwin-<span class="keyword">x</span><span class="number">86</span>_<span class="number">64</span>.bin</span><br><span class="line">./android-ndk-r<span class="number">10</span><span class="keyword">c</span>-darwin-<span class="keyword">x</span><span class="number">86</span>_<span class="number">64</span>.bin  #需要等待一会</span><br></pre></td></tr></table></figure></p><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span> ~/.zshrc</span><br></pre></td></tr></table></figure><p>把<code>/Users/alanchen/Downloads/ndk/android-ndk-r10e</code> 加进去(这个是我自己的)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc   <span class="comment">#使得配置生效</span></span><br></pre></td></tr></table></figure><p>输入以下命令,看看是否成功:<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ndk-build</span></span><br></pre></td></tr></table></figure></p><p><img src="http://7xjgcv.com1.z0.glb.clouddn.com/ndk_1.png" alt="ndk-build"></p><a id="more"></a><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>如果配置成功,让我们接下去看<a href="http://developer.android.com/intl/zh-cn/tools/building/index.html" target="_blank" rel="noopener">Building and Running</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://blog.csdn.net/qiujuer/article/details/42040963" target="_blank" rel="noopener">http://blog.csdn.net/qiujuer/article/details/42040963</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反编译工具Jadx</title>
      <link href="/blog/159e976.html"/>
      <url>/blog/159e976.html</url>
      
        <content type="html"><![CDATA[<h2 id="Jadx"><a href="#Jadx" class="headerlink" title="Jadx"></a><a href="https://github.com/skylot/jadx" target="_blank" rel="noopener">Jadx</a></h2><p>Android开发(/学习)有时候需要用到反编译工具,Window上有很多工具,而Mac上则不多,这里稍微介绍一下Mac上可用的反编译工具Jadx.</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>clone 仓库,编译<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir jadx</span><br><span class="line">git clone https://github.com/skylot/jadx.git</span><br><span class="line">cd jadx</span><br><span class="line">./gradlew dist #这个需要等一下</span><br></pre></td></tr></table></figure></p><h3 id="开始反编译"><a href="#开始反编译" class="headerlink" title="开始反编译"></a>开始反编译</h3><p>等完毕后,可以开始了,我就介绍个最简单最常用的用法</p><ol><li>把apk改成zip</li><li>解压zip获取class.dex文件</li><li>将class.dex文件放到jadx目录下</li></ol><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd build/jadx/</span><br><span class="line">bin/jadx -d <span class="keyword">out</span> <span class="class"><span class="keyword">class</span>.<span class="title">dex</span>  <span class="comment"># 反编译后放入out文件夹下(如果out不存在它会自动创建)</span></span></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">bin/jadx-gui <span class="class"><span class="keyword">class</span>.<span class="title">dex</span>  <span class="comment"># 会反编译,并且使用gui打开</span></span></span><br></pre></td></tr></table></figure><p><img src="http://7xjgcv.com1.z0.glb.clouddn.com/jadx.png" alt="效果图"></p><p>OK,就这样,后续还可以配置环境变量,更加方便.</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Lambda在Android中的替代匿名类</title>
      <link href="/blog/f871d1e5.html"/>
      <url>/blog/f871d1e5.html</url>
      
        <content type="html"><![CDATA[<h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p>Lambda是第十一个希腊字母,大写Λ，小写λ,额,跑题了…<br>Lambda表达式 是Java8的新特性之一:</p><ol><li>Lambda表达式</li><li>函数式接口</li><li>流API</li><li>默认方法</li><li>新的Date 和 Time API</li></ol><p>Lambda表达式<strong>取代了匿名类</strong>，取消了模板，允许用函数式风格编写代码。</p><p>由于最近接触了RxJava,遇到了Lambda,立马就喜欢上了~所以就学习了一下.  </p><p>本文主要介绍一下Lambda在Android中替代匿名类的部分使用场景.  </p><a id="more"></a><h2 id="在Android中使用Lambda"><a href="#在Android中使用Lambda" class="headerlink" title="在Android中使用Lambda"></a>在Android中使用Lambda</h2><h3 id="gradle-retrolambda"><a href="#gradle-retrolambda" class="headerlink" title="gradle-retrolambda"></a><a href="https://github.com/evant/gradle-retrolambda" target="_blank" rel="noopener">gradle-retrolambda</a></h3><blockquote><p>A gradle plugin for getting java lambda support in java 6, 7 and android</p></blockquote><p>在Android中使用我们需要使用这个插件,按照配置配置完就行.</p><h3 id="实战使用"><a href="#实战使用" class="headerlink" title="实战使用"></a>实战使用</h3><p>由于Lambda 可以取代匿名类,所以我们先来挑几个匿名类练练手.  </p><p>这里先简单的提及一下Lambda的语法:<code>() -&gt; {}</code><br>咋一看可能觉得这个什么鬼啊?看不懂啊!<br>不急,看几个例子先~</p><h4 id="设置监听事件"><a href="#设置监听事件" class="headerlink" title="设置监听事件"></a>设置监听事件</h4><p>Android中我们设置监听一般这么写:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mFab.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                doSomething();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><p>这么写AS会提示说匿名类<code>new View.OnClickListener()</code>能被Lambda代替:<br><img src="http://7xjgcv.com1.z0.glb.clouddn.com/lambda_1.png" alt="提示"></p><p>那么用Lambda可以如何写呢?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mFab.setOnClickListener(v-&gt;doSomething());</span><br></pre></td></tr></table></figure><p>看到了么?<br>整个匿名内部类被<code>v-&gt;doSomething()</code>给代替了.<br>是不是非常简单?</p><pre><code>Ps: 本例子中的`v`代表onClick传递的参数v,参数不能省略,但是可以随意命名.</code></pre><h4 id="实现Runnable"><a href="#实现Runnable" class="headerlink" title="实现Runnable"></a>实现Runnable</h4><p>在Android中我们起个线程一般这么写:<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                doSomething();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br></pre></td></tr></table></figure></p><p>而使用Lambda表达式的话可以这么写:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; doSomething()).start();</span><br></pre></td></tr></table></figure></p><p>另外实例化Runnable成员变量也可以这么写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable = ()-&gt;doSomething();</span><br></pre></td></tr></table></figure><p>看完这两个例子是否对Lambda感兴趣了呢?<br>后续我还会继续学习,有兴趣的请继续关注~  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://www.importnew.com/16436.html" target="_blank" rel="noopener">http://www.importnew.com/16436.html</a><br><a href="http://javarevisited.blogspot.sg/2014/02/10-example-of-lambda-expressions-in-java8.html" target="_blank" rel="noopener">http://javarevisited.blogspot.sg/2014/02/10-example-of-lambda-expressions-in-java8.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lambda </tag>
            
            <tag> Java8 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux之常用文件操作命令</title>
      <link href="/blog/23465e17.html"/>
      <url>/blog/23465e17.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本文记录整理了Linux较为常用的处理文件目录的命令.</p></blockquote><h2 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h2><blockquote><p>Linux 下一切皆文件</p></blockquote><h4 id="新建文件-touch"><a href="#新建文件-touch" class="headerlink" title="新建文件:touch"></a>新建文件:<code>touch</code></h4><blockquote><p>touch [选项]… [文件名]…</p></blockquote><p>一般就 <code>touch test.md adf.md</code> 这样就行</p><h4 id="输出命令-echo"><a href="#输出命令-echo" class="headerlink" title="输出命令: echo"></a>输出命令: <code>echo</code></h4><pre><code>echo [选项]... string 在屏幕打印,不知什么用- -echo string &gt; filename  覆盖写入string+换行echo string &gt;&gt; filename 追加内容</code></pre><h4 id="显示文件内容-cat"><a href="#显示文件内容-cat" class="headerlink" title="显示文件内容: cat"></a>显示文件内容: <code>cat</code></h4><pre><code>cat filename</code></pre><p>其实cat还有其他作用,只是常用就这个</p><a id="more"></a><p>复制文件内容到剪切板,非常实用,可以避免复制错误.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat filename | pbcopy</span><br></pre></td></tr></table></figure></p><blockquote><p>pbcopy pbpaste</p></blockquote><h3 id="目录处理命令"><a href="#目录处理命令" class="headerlink" title="目录处理命令"></a>目录处理命令</h3><h4 id="建立目录-mkdir"><a href="#建立目录-mkdir" class="headerlink" title="建立目录: mkdir"></a>建立目录: <code>mkdir</code></h4><p><img src="http://7xjgcv.com1.z0.glb.clouddn.com/linux_d_1.png" alt="mkdir"></p><blockquote><p>-p 用于连续创建目录以及子目录  </p></blockquote><p>比如我要创建language目录,并且创建它的一个子目录android:<br>如果我写成<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> <span class="keyword">language</span>/android</span><br></pre></td></tr></table></figure></p><p>它会提示<code>mkdir: language: No such file or directory</code><br>而加上<code>-p</code>参数则执行成功<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -<span class="selector-tag">p</span> language/android</span><br></pre></td></tr></table></figure></p><h4 id="删除空目录-rmdir"><a href="#删除空目录-rmdir" class="headerlink" title="删除空目录: rmdir"></a>删除空目录: <code>rmdir</code></h4><p>知道如何创建目录,我们当然也需要知道如何删除目录!~<br><img src="http://7xjgcv.com1.z0.glb.clouddn.com/linux_d_5.png" alt="rmdir"></p><blockquote><p>它只能删除<code>空目录</code>,注意必须为<code>空目录</code>,所以其实没什么大用,请看下一个命令</p></blockquote><h4 id="删除文件或目录-rm"><a href="#删除文件或目录-rm" class="headerlink" title="删除文件或目录 rm"></a>删除文件或目录 <code>rm</code></h4><p><img src="http://7xjgcv.com1.z0.glb.clouddn.com/linux_d_6.png" alt="rm"></p><ol><li>删除目录:  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mkdir</span> -p a/b/c/<span class="keyword">d</span>/<span class="built_in">e</span></span><br><span class="line"><span class="keyword">rm</span> -r a</span><br></pre></td></tr></table></figure></li></ol><p>它会不断地问你是否删除某个目录!所以要加上<code>-f</code>强制删除,就不需要频繁地确认了<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rm -rf a</span></span><br></pre></td></tr></table></figure></p><ol start="2"><li>删除多个文件:<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf <span class="selector-tag">a</span><span class="selector-class">.md</span> <span class="selector-tag">b</span><span class="selector-class">.md</span> c.md</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>看视频说在删除目录的时候会有问你是否删除的确认,但是我在Mac下试了没有.但是个人感觉还是有确认比较好,因为玩意失误删了就木有了…废纸篓里也没有的..这要是删了什么关键的东西…那就呵呵了!</p></blockquote><blockquote><p>Ps: 如果要加提示的话 加上<code>-i</code>参数,但是如果已经有<code>f</code>参数,<code>i</code>会失效</p></blockquote><h4 id="切换所在目录-cd"><a href="#切换所在目录-cd" class="headerlink" title="切换所在目录: cd"></a>切换所在目录: <code>cd</code></h4><p><img src="http://7xjgcv.com1.z0.glb.clouddn.com/linux_d_2.png" alt="cd"></p><p>相对路径与绝对路径:<br><img src="http://7xjgcv.com1.z0.glb.clouddn.com/linux_d_3.png" alt="路径问题"></p><p><strong>PS: cd 后面有一个空格,需要留意</strong></p><blockquote><p>吐槽自己:以前自己老是打<code>cd ~</code>,并且也不知道<code>cd -</code>的存在,自己老是打一大串路径切来切去,这下不用麻烦啦!!~</p></blockquote><h4 id="查询所在的目录位置-pwd"><a href="#查询所在的目录位置-pwd" class="headerlink" title="查询所在的目录位置:pwd"></a>查询所在的目录位置:<code>pwd</code></h4><p>当你在目录下切换来切换去不知道自己在哪里的时候,<code>pwd</code>就能帮上大忙啦!<br><img src="http://7xjgcv.com1.z0.glb.clouddn.com/linux_d_4.png" alt="pwd"></p><blockquote><p>很常用,一定要知道,保证你不会迷路的指南针呐!~</p></blockquote><h4 id="复制命令-cp"><a href="#复制命令-cp" class="headerlink" title="复制命令:cp"></a>复制命令:<code>cp</code></h4><p><img src="http://7xjgcv.com1.z0.glb.clouddn.com/linux_d_7.png" alt="cp"></p><p>Ps: 似乎<code>-r</code>解释得不对/不全?<br>补充:</p><ul><li><code>-r</code>   (recursive)递归处理，将指定目录下的文件与子目录一并处理。若源文件或目录的形态，不属于目录或符号链接，则一律视为普通文件处理</li><li><code>-p</code> 或 <code>--preserve</code>(保存的意思) 保留源文件或目录的属性，包括所有者、所属组、权限与时间</li><li><code>-a</code> 或 <code>--archive</code>     此参数的效果和同时指定”-dpR”参数相同</li></ul><blockquote><p>PS: 不加-p -a 则复制生成的文件的时间是执行命令时候的时间!  </p></blockquote><p>练习:<br><code>-p</code>or <code>-a</code>可以顺带赋值属性<br><img src="http://7xjgcv.com1.z0.glb.clouddn.com/linux_d_8.png" alt="效果"></p><h4 id="剪切或改名命令-mv"><a href="#剪切或改名命令-mv" class="headerlink" title="剪切或改名命令:mv"></a>剪切或改名命令:<code>mv</code></h4><p><img src="http://7xjgcv.com1.z0.glb.clouddn.com/linux_d_9.png" alt="mv"></p><h5 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h5><p>将ssss.md 剪切到上一个目录<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv ssss<span class="selector-class">.md</span> ../</span><br></pre></td></tr></table></figure></p><h5 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h5><p>将ssss.md 重命名为aaa.md<br><code>mv ssss.md aaa.md</code><br><img src="http://7xjgcv.com1.z0.glb.clouddn.com/linux_d_10.png" alt="mv练习"></p><blockquote><p>Ps : 重命名的时候一定要记得写<code>后缀</code></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux之文件搜索命令</title>
      <link href="/blog/b729b995.html"/>
      <url>/blog/b729b995.html</url>
      
        <content type="html"><![CDATA[<h2 id="文件搜索命令locate"><a href="#文件搜索命令locate" class="headerlink" title="文件搜索命令locate"></a>文件搜索命令<code>locate</code></h2><p>在指定的数据库按文件名字搜索.</p><p>优点:</p><ol><li>搜索速度快(在后台数据库中按文件名搜索)</li></ol><blockquote><p>数据库: /var/lib/mlocate</p></blockquote><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">locate filename</span></span><br></pre></td></tr></table></figure><p>第一次执行的时候会出现:<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WARNING: The locate database (/var/db/locate.database) does <span class="keyword">not</span> exist.</span><br><span class="line">To <span class="built_in">create</span> <span class="keyword">the</span> database, run <span class="keyword">the</span> following <span class="keyword">command</span>:</span><br><span class="line"></span><br><span class="line">  sudo launchctl <span class="built_in">load</span> -w /System/Library/LaunchDaemons/com.apple.locate.plist</span><br><span class="line"></span><br><span class="line">Please be aware that <span class="keyword">the</span> database can take some <span class="built_in">time</span> <span class="built_in">to</span> generate; once</span><br><span class="line"><span class="keyword">the</span> database has been created, this message will no longer appear.</span><br></pre></td></tr></table></figure></p><p>缺点:</p><ol><li>不能搜所刚创建的文件(数据库默认一天一更新)</li><li>只能按文件名字搜索</li></ol><p>那么我非要立马更新数据库呢?</p><a id="more"></a><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">updatedb</span></span><br></pre></td></tr></table></figure><blockquote><p>Mac 上试了 <code>zsh: command not found: updatedb</code></p></blockquote><p><code>locate locate</code> 可以搜索到数据库</p><p>特点:<br>有配置文件,可以配置哪些不搜索<br><code>/etc/updatedb.conf</code></p><blockquote><p>发现mac 又没有 - -!!</p></blockquote><h2 id="命令搜索命令whereis-和which"><a href="#命令搜索命令whereis-和which" class="headerlink" title="命令搜索命令whereis 和which"></a>命令搜索命令<code>whereis</code> 和<code>which</code></h2><h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3><p>可以看到命令所在路径以及帮助文档所在位置</p><ul><li>whereis 命令名<br>选项:</li></ul><ol><li>-b 只查找可执行文件</li><li>-m 只查找帮助文件</li></ol><blockquote><p>只能搜索系统自带的命令<br>还有一些类似的命令: <code>whoami</code> <code>whatis</code></p></blockquote><h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3><p>可以看到 命令的别名</p><ul><li>which 文件名<br>搜索命令所在路径及别名</li></ul><blockquote><p>Mac都不一样 - -</p></blockquote><h3 id="PATH环境变量"><a href="#PATH环境变量" class="headerlink" title="PATH环境变量"></a>PATH环境变量</h3><p>定义的是系统搜索命令的路径</p><blockquote><p><code>echo $PATH</code> 可以查看环境变量 由<code>:</code>分隔</p></blockquote><h2 id="文件搜索命令find"><a href="#文件搜索命令find" class="headerlink" title="文件搜索命令find"></a>文件搜索命令<code>find</code></h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>非常强大,然而耗费资源(遍历所有文件)</p><ul><li>find [搜索范围] [搜索条件]</li></ul><p>PS:</p><ol><li>避免大范围搜索,会非常耗费系统资源</li><li>find 实在系统当中搜索符合条件的文件名.如果需要匹配,使用通配符匹配,通配符是完全匹配.</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  testlinux  ls</span><br><span class="line"><span class="selector-tag">a</span>                asdfasdfasdfa<span class="selector-class">.md</span> <span class="selector-tag">b</span>                c.md</span><br><span class="line">adad             avc              <span class="selector-tag">b</span>.md</span><br><span class="line">➜  testlinux  find b</span><br><span class="line">b</span><br><span class="line">b/<span class="selector-tag">b</span>.md</span><br></pre></td></tr></table></figure><blockquote><p>不指定 搜索范围,默认在当前目录</p></blockquote><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><ol><li><ul><li>匹配任意内容</li></ul></li><li>? 匹配任意一个字符</li><li>[] 匹配任意一个中括号内的字符</li></ol><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><ol><li>-iname 不区分大小</li><li>-user root 按照所有者搜索</li><li>-nouser 查找没有所有者的文件 (一般就是垃圾文件了)</li></ol><h4 id="按时间查找"><a href="#按时间查找" class="headerlink" title="按时间查找"></a>按时间查找</h4><ol start="4"><li>-atime 文件访问时间</li><li>-ctime 改变文件属性</li><li>-mtime 修改文件内容</li></ol><p>查找10天前修改的文件:</p><blockquote><p>find /var/log/ -mtime +10<br>-10 10天内修改文件<br>10 10天当天修改的文件<br>+10 10天前修改的文件</p></blockquote><h4 id="文件大小-inode"><a href="#文件大小-inode" class="headerlink" title="文件大小,inode"></a>文件大小,inode</h4><blockquote><p>find . -size 25k 查找文件大小是25KB的文件</p></blockquote><ul><li>-25k 小于25KB</li><li>25k  等于25KB</li><li>+25k 大于25KB</li></ul><blockquote><p>k M k要小写M大写,不能省略,省略的话为25个扇区(每个扇区512个字节)</p></blockquote><blockquote><p>find . -inum 262422 查找i节点是262422的文件</p></blockquote><h4 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h4><ul><li>-a  and 逻辑与</li><li>-o or 逻辑或</li></ul><p>查找/etc/目录下,大于20kb并且小于50kb的文件</p><blockquote><p>find /etc -size +20k -a -size -50k</p></blockquote><p>查找/etc/目录下,大于20kb并且小于50kb的文件,并显示详细信息</p><blockquote><p>find /etc -size +20k -a -size -50k -exec ls -lh {} \ 这里有个空格</p></blockquote><ul><li>-exec/-ok 命令{}\ ; 对搜索结果执行操作</li></ul><blockquote><p>-exec {} \ 是语法,必须这么写,中间可以写其他命令~</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="selector-tag">testlinux</span>  <span class="selector-tag">find</span> <span class="selector-tag">b</span><span class="selector-class">.md</span>  <span class="selector-tag">-exec</span> <span class="selector-tag">ls</span> <span class="selector-tag">-lh</span> &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-rw-r--r--</span>  1 <span class="selector-tag">alanchen</span>  <span class="selector-tag">staff</span>     0<span class="selector-tag">B</span>  8 24 20<span class="selector-pseudo">:23</span> <span class="selector-tag">b</span><span class="selector-class">.md</span></span><br><span class="line">➜  <span class="selector-tag">testlinux</span></span><br></pre></td></tr></table></figure><h2 id="字符串搜索命令-grep"><a href="#字符串搜索命令-grep" class="headerlink" title="字符串搜索命令 grep"></a>字符串搜索命令 <code>grep</code></h2><ul><li>grep [选项] 字符串 文件名</li></ul><blockquote><p>在文件当中匹配符合条件的字符串</p></blockquote><p>选项:</p><ol><li>-i 忽略大小写</li><li>-v 排除指定字符串</li></ol><p><img src="http://7xjgcv.com1.z0.glb.clouddn.com/linux_16.png" alt="练习"></p><h2 id="find-与-grep-的区别"><a href="#find-与-grep-的区别" class="headerlink" title="find 与 grep 的区别"></a>find 与 grep 的区别</h2><blockquote><p>find : 在系统当中搜索符合条件的文件名,如果需要匹配,使用通配符匹配,通配符是完全匹配.<br>常用于搜索文件</p></blockquote><blockquote><p>grep : 在文件当中搜索符合条件的字符串,如果需要匹配,使用正则表达式进行匹配,正则表达式是包含匹配.<br>常用于搜索文件内容</p></blockquote><blockquote><p><a href="http://www.imooc.com/video/4048" target="_blank" rel="noopener">Linux达人养成计划</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux之链接命令</title>
      <link href="/blog/fba637b6.html"/>
      <url>/blog/fba637b6.html</url>
      
        <content type="html"><![CDATA[<h2 id="链接命令-ln"><a href="#链接命令-ln" class="headerlink" title="链接命令: ln"></a>链接命令: <code>ln</code></h2><p><img src="http://7xjgcv.com1.z0.glb.clouddn.com/linux_11.png" alt="ln"></p><p>链接分两种:</p><ol><li>软链接 -s (soft)</li><li>硬链接</li></ol><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>特征:<br><img src="http://7xjgcv.com1.z0.glb.clouddn.com/linux_12.png" alt="硬链接"></p><p><img src="http://7xjgcv.com1.z0.glb.clouddn.com/linux_13.png" alt="硬链接练习"></p><blockquote><p>请无视中间的vi命令,因为还没有学习vim</p></blockquote><p>对于硬链接自己的理解备忘:</p><ol><li>相同的硬连接文件指向同一片地址(inode一样),查询的block是一样的</li><li>修改其中一个文件,其实改的是地址所对应的内容,所以所有指向这地址的文件都”一起修改了”</li><li>删除其中某个不会影响其他文件的使用,因为地址的内存依然在</li><li>建立硬链接影响文件被引用的计数(+1)(该计数就是<code>ll</code>看到的 文件权限命令后的那个数字)</li><li>为什么会有引用计数呢?个人觉得正因为硬链接的inode跟block一样,所以可以通过计数来判断block是否还有引用,来决定是否删除数据(感觉像是gc,没有强引用了就代表可以回收了)</li><li>不推荐硬链接</li></ol><a id="more"></a><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p><img src="http://7xjgcv.com1.z0.glb.clouddn.com/linux_14.png" alt="软链接"></p><p><img src="http://7xjgcv.com1.z0.glb.clouddn.com/linux_15.png" alt="软链接练习"></p><p>理解备忘:</p><ol><li>推荐使用</li><li>源文件删除后影响软链接的使用(就像失去源文件的快捷方式)</li><li>软链接拥有自己的inode和block,存的是指向源文件inode的信息,再通过源文件inode的信息找到内容,所以当源文件被删时,软链接也跟着失效了</li><li>修改软链接也同样影响硬链接以及源文件,反之亦然</li><li>软链接的文件类型是<code>l</code>,并且它的权限跟随源文件,而并非是ll后所看到的那样!</li><li>软链接要写绝对路径,默认会在当前文件目录下找,如果找不到就会报错!!(试了MacOS 它能找到 - -!)</li></ol><p>软硬链接区别的个人理解:</p><p>硬链接就如我跟我妈,拥有相同的住址(inode)指向同一个block(我家),我装修了我家,我妈妈的家理所当然的跟着变了,我不见了(被删了)也不影响通过我妈找我家!  </p><p>而软链接则像是我跟我的朋友的关系,他拥有自己的inode以及block,他可以用他们来找到我,然后通过我再找到我家(假设这里用的微博,朋友嘛告诉他家在哪里也正常,只不过他脑子不好,每次问完就忘记).有一天,他送给我了一份礼物,我放家里了,我妈回家也看得到(通过软链接修改,也影响其他的硬链接,其实改的就是我家!~).<br>有一天我没上网,也就上不了微博,我朋友找不到我了(我被删了),那么朋友也找不到我家了(源文件被删,软链接跟着失效了)  </p><p>至于绝对路径,那就更好说啦!~比如我告诉我朋友我家在A村,但是全国这么多A村,他就懵b了…<br>纯属个人理解~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux之命令基础</title>
      <link href="/blog/a4d42055.html"/>
      <url>/blog/a4d42055.html</url>
      
        <content type="html"><![CDATA[<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><blockquote><p>1991 作者–Linus Torvalds Git也同样出自他手</p></blockquote><blockquote><p>虽然自己只是个android新手,但是个人觉得掌握一些linux命令还是很有必要的,这个是自己看<a href="http://www.imooc.com/video/3473" target="_blank" rel="noopener">Linux达人养成计划 I</a>部分章节的学习笔记<br>,外加自己其他所学整理.<br>另外由于自己用的是Mac,所以实际跟Linux有差别,但是还好不太影响~由于本人也是刚学习,所以可能会出现错误,还望各位指正!</p></blockquote><blockquote><p>本人按照自己学习Android的需求学习的,所以东西可能不多,但是够用</p></blockquote><h2 id="命令基本格式"><a href="#命令基本格式" class="headerlink" title="命令基本格式"></a>命令基本格式</h2><h3 id="命令提示符"><a href="#命令提示符" class="headerlink" title="命令提示符"></a>命令提示符</h3><p>[root@localhost ~]#</p><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">root</td><td style="text-align:center">用户</td></tr><tr><td style="text-align:center">\</td><td style="text-align:center">根目录</td></tr><tr><td style="text-align:center">~</td><td style="text-align:center">用户的home目录</td></tr><tr><td style="text-align:center">#</td><td style="text-align:center">超级用户的提示符</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">普通用户的提示符</td></tr></tbody></table><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><p>绝大多数命令支持以下格式<br>命令 [选项] [参数]</p><blockquote><p>PS: 个别命令使用不遵循此格式,当有多个选项时,可以写在一起简化选项与完整选项 <code>-a</code>等于<code>--all</code></p></blockquote><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><ol><li>查询目录中内容: ls</li></ol><p>ls [选项] [文件或目录]</p><p>常用选项:</p><ol><li>-a 显示所有文件,包括隐藏文件(如’.’开头的文件,系统文件)</li><li>-l 显示详细信息 (long list)</li><li>-d 查看目录本身的属性,而不是该目录下的文件</li><li>-h 人性化显示文件大小</li><li>-i 显示inode (查看id号)</li></ol><p>文件或目录:<br><strong>指定查询某个目录</strong><br>如果不填写,则默认当前目录</p><a id="more"></a><h5 id="栗子1"><a href="#栗子1" class="headerlink" title="栗子1"></a>栗子1</h5><p>执行<code>ls -l</code><br><img src="http://7xjgcv.com1.z0.glb.clouddn.com/linux_2.png" alt="结果图"></p><h5 id="栗子2"><a href="#栗子2" class="headerlink" title="栗子2"></a>栗子2</h5><p>ls -l self  (我有个文件夹就叫self)<br><img src="http://7xjgcv.com1.z0.glb.clouddn.com/linux_3.png" alt="结果:"></p><h4 id="文件权限解释"><a href="#文件权限解释" class="headerlink" title="文件权限解释"></a>文件权限解释</h4><p><em>第一位代表文件类型</em><br>后面<code>每三位</code>为一组,分别代表<code>三个身份</code>:</p><ol><li>u所有者</li><li>g所属组</li><li>o其他人</li></ol><!-- more --><p>rw代表对该文件拥有的<code>操作权限</code>:</p><ol><li>r读</li><li>w写</li><li>x执行</li></ol><p><img src="http://7xjgcv.com1.z0.glb.clouddn.com/linux_1.png" alt="文件权限详解-默认占10位"></p><p>了解以后就可以解析一下<br><code>- rw- r-- r--</code>所代表的意义了<br>代表 这个文件(-)所有者拥有读写权限,所属组跟其他人只拥有读权限!</p><blockquote><p>个人表示居然能看懂那一串什么鬼了~~~哈哈哈<br>update: 忽然想明白了chmod 777 的意思就是将权限改为 111-111-111 也就是rwx-rwx-rwx 啊!!!</p></blockquote><p>另外的一些信息:</p><ol><li>权限后面的数字代表被<em>引用的次数?</em> (受硬链接影响,后面会提到<code>ln</code>命令)</li><li>另外还有文件大小(字节,可以加上h参数,可显示单位)</li><li>文件最后一次修改时间</li><li>文件的名字</li></ol><p><code>ls -lh</code><br><img src="http://7xjgcv.com1.z0.glb.clouddn.com/linux_4.png" alt="人性化显示效果"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AndroidStudio必备插件</title>
      <link href="/blog/9a1387af.html"/>
      <url>/blog/9a1387af.html</url>
      
        <content type="html"><![CDATA[<p>记录一下好用的AndroidStudio插件,欢迎推荐!~</p><ol><li><p>ButterKnife Zelezny</p></li><li><p>Drawable Importer</p></li><li><p>File Grouping</p></li><li><p>Eventbus Intellij Plugin</p></li><li><p>Layout ID Converter</p></li><li><p>Selector Generate</p></li><li><p>Gson Format</p></li><li><p>Lifecycle Sorter<br>Sorts the lifecycle methods of an Activity or a Fragment in the order that they are called in your application.</p></li></ol><a id="more"></a><p>//TO BE CONTINUE</p><p>参考/更多:</p><blockquote><p><a href="http://www.admin10000.com/document/6431.html" target="_blank" rel="noopener">http://www.admin10000.com/document/6431.html</a><br><a href="http://blog.csdn.net/liang5630/article/details/46366901" target="_blank" rel="noopener">http://blog.csdn.net/liang5630/article/details/46366901</a><br><a href="http://www.zhihu.com/question/28026027" target="_blank" rel="noopener">http://www.zhihu.com/question/28026027</a><br><a href="http://www.kuqin.com/shuoit/20150914/348061.html" target="_blank" rel="noopener">http://www.kuqin.com/shuoit/20150914/348061.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> AndroidStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac必备神器之Go2Shell</title>
      <link href="/blog/3f45b869.html"/>
      <url>/blog/3f45b869.html</url>
      
        <content type="html"><![CDATA[<h2 id="Go2Shell"><a href="#Go2Shell" class="headerlink" title="Go2Shell"></a><a href="http://zipzapmac.com/Go2Shell" target="_blank" rel="noopener">Go2Shell</a></h2><p>一个可以快速在当前目录打开Shell的工具,小巧,非常好用!</p><p>但是它默认打开是<em>系统的iterm</em>,而我希望它打开<strong>iTerm2</strong>!~</p><h2 id="设置默认iterm"><a href="#设置默认iterm" class="headerlink" title="设置默认iterm"></a>设置默认iterm</h2><p>而Go2Shell默认没有设置界面,需要用命令行打开(隐藏得真深啊!)<br>在Shell中输入:  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open -a Go2Shell --args config</span><br></pre></td></tr></table></figure><p>会打开设置界面</p><p><img src="http://7xjgcv.com1.z0.glb.clouddn.com/go2shell.png" alt="设置界面"></p><p>选择iTerm2 ,保存并退出即可!~</p><a id="more"></a><h2 id="配合其他利器使用"><a href="#配合其他利器使用" class="headerlink" title="配合其他利器使用"></a>配合其他利器使用</h2><p>Go2Shell还可以配合其他软件进一步提升效率,让你爽翻!~</p><h3 id="配合Alfred"><a href="#配合Alfred" class="headerlink" title="配合Alfred"></a>配合Alfred</h3><p>使用Alfred快捷打开,我这里输入2就可以快速打开</p><p><img src="http://7xjgcv.com1.z0.glb.clouddn.com/go2.png" alt="效果图"></p><h3 id="配合Finder"><a href="#配合Finder" class="headerlink" title="配合Finder"></a>配合Finder</h3><p>打开Finder,按住command键,拖动Go2Shell的图标到Finder菜单<br>就可以在Finder快捷打开Go2Shell了</p><p><img src="http://7xjgcv.com1.z0.glb.clouddn.com/gotwoshell.png" alt="效果图"></p><h3 id="配合Manico"><a href="#配合Manico" class="headerlink" title="配合Manico"></a>配合Manico</h3><p>使用Manico给Go2Shell配置个快捷键,爽呆..</p><p>吐槽一下:</p><blockquote><p>推荐在App Store下载旧版本,因为官方网站最新版本已经变了,打开Go2Shell变成了设置界面,虽然不用再输入命令打开设置界面了,但是,事实上这变得更加坑了!<br> 因为不能配合Alfred 和 Manico了!!!那还有个软用?</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态修改Shape的solid属性的color值</title>
      <link href="/blog/cda52602.html"/>
      <url>/blog/cda52602.html</url>
      
        <content type="html"><![CDATA[<p>Android中Shape经常会被用到,今天遇到个问题,要动态修改Shape的背景颜色,在此记录一下.</p><p>Xml中的Shape一般都会写死一个颜色,如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shape</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"5dp"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"@color/white"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然而当我们需要在运行时,动态去修改需要如何做呢?<br>其实很简单:<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GradientDrawable drawable =(GradientDrawable)view.getBackground()<span class="comment">;</span></span><br><span class="line">drawable.setColor(getResources().getColor(color))<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><blockquote><p><a href="http://stackoverflow.com/questions/16775891/how-to-change-solid-color-from-the-code" target="_blank" rel="noopener">参考资料</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改WebView的背景颜色为透明</title>
      <link href="/blog/dc839eaf.html"/>
      <url>/blog/dc839eaf.html</url>
      
        <content type="html"><![CDATA[<p>首先想当然地想到在XML设置背景颜色</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:<span class="built_in">background</span>=<span class="string">"@color/transparent"</span></span><br></pre></td></tr></table></figure><p>但是运行后发现结果并非是透明的,而是白色的!</p><p>后来search之..发现</p><ul><li>有说需要关闭硬件加速的</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码关闭:</span></span><br><span class="line">mWebView.setLayerType(View.LAYER_TYPE_SOFTWARE,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xml里设置:</span></span><br><span class="line"><span class="symbol">android:</span>layerType=<span class="string">"software"</span></span><br></pre></td></tr></table></figure><ul><li>有说的用mWebView.setBackgroundColor(0);</li></ul><p>在4.4的小米4上尝试后发现</p><p><strong>关闭硬件加速是没有用的</strong>,<br><strong>而mWebView.setBackgroundColor(0);有用~</strong></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UI,Tip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ItemTouchHelper之SwipeDismiss</title>
      <link href="/blog/3e4ae14f.html"/>
      <url>/blog/3e4ae14f.html</url>
      
        <content type="html"><![CDATA[<h2 id="ItemTouchHelper"><a href="#ItemTouchHelper" class="headerlink" title="ItemTouchHelper"></a><a href="https://developer.android.com/intl/zh-cn/reference/android/support/v7/widget/helper/ItemTouchHelper.html" target="_blank" rel="noopener">ItemTouchHelper</a></h2><blockquote><p>This is a utility class to add swipe to dismiss and drag &amp; drop support to RecyclerView.</p></blockquote><p>它是一个非常强大的工具,感觉跟ViewDragHelper一样,不过ItemTouchHelper顾名思义是处理item的touch事件的.<br>它能够让你非常容易实现侧滑删除,拖拽的功能.</p><p>今天,就拿它来实现以下侧滑删除!~</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>首先我们看下ItemTouchHelper的构造方法<code>ItemTouchHelper(Callback callback)</code> 它需要我们传入一个Callback<br>而刚好Android非常任性,已经帮我们实现了一个:<code>SimpleCallback</code></p><p>甚至,在注释里已经给我们写好了样例!!!有兴趣的同学可以去看看,这里就不给出了.</p><p>接下来上代码!~</p><a id="more"></a><h3 id="定义一个Adapter"><a href="#定义一个Adapter" class="headerlink" title="定义一个Adapter"></a>定义一个Adapter</h3><p>这个adapter没什么特别的,挺简单的,相信大家会</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">ListAdapter</span>.<span class="title">ViewHolder</span>&gt; <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Context mContext;</span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt;mDatas;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ListAdapter</span><span class="params">(Context context,List&lt;String&gt; data)</span></span>&#123;</span><br><span class="line">            mDatas= data;</span><br><span class="line">            mContext = context;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.material_list_item, parent, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ViewHolder(view);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">            holder.text.setText(mDatas.get(position));</span><br><span class="line"></span><br><span class="line">            holder.text.setTag(position);</span><br><span class="line">            holder.text.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mDatas.size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            TextView tv = (TextView) v;</span><br><span class="line">            Toast.makeText(mContext, tv.getText()+<span class="string">";;"</span>+tv.getTag(), Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            TextView text;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">ViewHolder</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">                <span class="keyword">super</span>(view);</span><br><span class="line">                text = (TextView) view.findViewById(R.id.iv_item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="定义一个RecyclerView"><a href="#定义一个RecyclerView" class="headerlink" title="定义一个RecyclerView"></a>定义一个RecyclerView</h3><p>设置为垂直list的样式,并且与上面的Adapter关联</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mRvList</span><span class="selector-class">.setLayoutManager</span>(<span class="selector-tag">new</span> <span class="selector-tag">LinearLayoutManager</span>(<span class="selector-tag">getActivity</span>(), <span class="selector-tag">LinearLayoutManager</span><span class="selector-class">.VERTICAL</span>, <span class="selector-tag">false</span>));</span><br><span class="line"><span class="selector-tag">mRvList</span><span class="selector-class">.setAdapter</span>(<span class="selector-tag">mAdapter</span>);</span><br></pre></td></tr></table></figure><h3 id="实例化一个ItemTouchHelper"><a href="#实例化一个ItemTouchHelper" class="headerlink" title="实例化一个ItemTouchHelper"></a>实例化一个ItemTouchHelper</h3><p>再实例化ItemTouchHelper之前我们再看一下SimpleCallback的构造方法:</p><p><code>ItemTouchHelper.SimpleCallback(int dragDirs, int swipeDirs)</code></p><ul><li>dragDirs 代表你想拖拽的方向</li><li>swipeDirs 你想滑动的方向</li></ul><p>都分别有一下值,很好理解:</p><ol><li>LEFT</li><li>RIGHT</li><li>START</li><li>END</li><li>UP</li><li>DOWN</li></ol><h3 id="动手"><a href="#动手" class="headerlink" title="动手"></a>动手</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 代表我不拖拽, ItemTouchHelper.RIGHT代表我往右滑动</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> ItemTouchHelper(<span class="keyword">new</span> ItemTouchHelper.SimpleCallback(<span class="number">0</span>, ItemTouchHelper.RIGHT) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在这个回调 我们处理滑动</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onSwiped</span><span class="params">(RecyclerView.ViewHolder viewHolder, <span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onSwiped() called with "</span> + <span class="string">"viewHolder = ["</span> + viewHolder + <span class="string">"], direction = ["</span> + direction + <span class="string">"]"</span>);</span><br><span class="line">                <span class="comment">//这里我们通过viewHolder获取position</span></span><br><span class="line">                <span class="keyword">int</span> position = viewHolder.getAdapterPosition();</span><br><span class="line">                mData.remove(position);</span><br><span class="line">                mAdapter.notifyItemRemoved(position);</span><br><span class="line">                Toast.makeText(getActivity(), <span class="string">"拆散的position:"</span>+position, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暂时不处理移动事件...</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onMove</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onMove() called with "</span> + <span class="string">"recyclerView = ["</span> + recyclerView + <span class="string">"], viewHolder = ["</span> + viewHolder + <span class="string">"], target = ["</span> + <span class="keyword">target</span> + <span class="string">"]"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).attachToRecyclerView(mRvList);</span><br></pre></td></tr></table></figure><h2 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h2><p>来看看效果图:</p><p><img src="http://7xjgcv.com1.z0.glb.clouddn.com/ezgif.com-add-text.gif" alt="效果图"></p><p>由于写在七夕,所以开启了恶搞拆情侣模式,哈哈~~~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ItemTouchHelper跟ViewDragHelper一样,给我们带来了极大的方便,不经想问,Android还有什么Helper也这么牛逼而鲜为人知?</p><h2 id="预告"><a href="#预告" class="headerlink" title="预告"></a>预告</h2><p>不出意外,下期实现拖拽功能,再见!~</p><p>完整的代码在我的Github上~</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://medium.com/@ipaulpro/drag-and-swipe-with-recyclerview-b9456d2b1aaf" target="_blank" rel="noopener">Drag and Swipe with RecyclerView</a>–<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0630/3123.html" target="_blank" rel="noopener">泡网翻译</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RecyclerView </tag>
            
            <tag> ItemTouchHelper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建博客之旅</title>
      <link href="/blog/233dd982.html"/>
      <url>/blog/233dd982.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直想自己搭建一个博客,断断续续,折折腾腾了一周多时间,终于算是搭建完毕了.</p><p>为什么要搭建博客呢?</p><ol><li>想有个属于自己的博客空间</li><li>世面上的平台不够好看 - -</li><li>佩服那些有博客的人,所以自己也想搞一个</li></ol><p>但是不懂服务器,没有空间,不懂前端怎么破?</p><blockquote><p>本博客是利用<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>+Github搭建,主题是<a href="http://wuchong.me/jacman/" target="_blank" rel="noopener">Jacman</a>,感觉不错,不需要什么上面所说的知识,也能搭建成功,方便也美观,<strong>我可以,你也可以</strong>.</p></blockquote><p>接下来讲讲自己的经历,说下自己遇到的坑以及注意事项~</p><a id="more"></a><h2 id="安装Git-Node-js"><a href="#安装Git-Node-js" class="headerlink" title="安装Git,Node.js"></a>安装Git,Node.js</h2><p>Hexo的文档还算详细,按照着文档安装Git,Node.js.<br>提醒一下:</p><ol><li>要翻墙</li><li>网要好</li><li>有必要时 sudo 用起来..<br>我记得当时网差,搞半天装不好…</li></ol><p>等一切安装完毕,可以开始搭建博客了,</p><h2 id="开始搭建博客"><a href="#开始搭建博客" class="headerlink" title="开始搭建博客"></a>开始搭建博客</h2><p>在某个目录执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt; <span class="comment">##如果folder没有创建,则会帮你创建</span></span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ (sudo) npm install   <span class="comment">##安装一些工具?</span></span><br></pre></td></tr></table></figure></p><p>执行完会自动生成一些必要的文件</p><p>这个时候执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s <span class="comment">##开启本地服务器就可以</span></span><br></pre></td></tr></table></figure></p><p>在浏览器输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就可以看到博客了</p><!-- more --><h2 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h2><ol><li>新建github的博客仓库</li><li>将本地的ssh key 关联到github</li><li>部署本地hexo 与github关联</li></ol><p>这里我只讲下配置hexo与github关联,其他的相信都已经做过!~<br><strong>Hexo提供了一个非常快速方便的一键部署功能,一个命令即可!</strong><br>不过不急,咱要先配置一下~</p><h3 id="修改-config-yml"><a href="#修改-config-yml" class="headerlink" title="修改_config.yml"></a>修改_config.yml</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repository</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:AlanCheen/alancheen.github.io.git</span><br><span class="line">  <span class="attribute">branch</span>: master</span><br><span class="line">  <span class="attribute">message</span>:</span><br></pre></td></tr></table></figure><p><strong>这里遇到了个坑,看了很多教程,都说type:github,但是那是过去式了,试了我好几次都不行,其实现在应该填git了!!!所以官方文档才是最靠谱的</strong></p><h3 id="安装git插件-hexo-deployer-git"><a href="#安装git插件-hexo-deployer-git" class="headerlink" title="安装git插件 hexo-deployer-git"></a>安装git插件 hexo-deployer-git</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><p>安装完毕后,执行遍可以把博客部署到github:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo d</span><br></pre></td></tr></table></figure></p><p>如果一切顺利,你就能看到自己的博客了!!~</p><p>不过github可能要同步,不一定能马上看到,过一会就可以看到啦!莫着急!~</p><p>怎么样?</p><p>一个命令部署!!</p><p>简单方便!!</p><p>爽爆了!!</p><h2 id="换主题"><a href="#换主题" class="headerlink" title="换主题"></a>换主题</h2><p>hexo自带的主题并不太好看,不过幸好hexo也提供了不少的<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a><br>这里我选择了<a href="http://wuchong.me/jacman/" target="_blank" rel="noopener">Jacman</a>.</p><p>个人原因:</p><ol><li>美观</li><li>有分类,标签等功能满足我的写作需求</li><li>响应式布局,在移动端观看也有很不错的阅读体验<br>当然你可以选择其他的!~~</li></ol><p>Jacman的作者写了个较为全面的使用教程:<br><a href="http://wuchong.me/blog/2014/11/20/how-to-use-jacman/" target="_blank" rel="noopener">Jacman教程</a></p><p>一步一步照着修改你所要修改的即可,还算简单~</p><p>我就配置了几个</p><ol><li><a href="http://duoshuo.com/" target="_blank" rel="noopener">多说</a></li><li><a href="http://weibo.com/tool/" target="_blank" rel="noopener">微博秀</a></li></ol><p><strong>不过这里提醒一下,配置属性的注意点</strong></p><ol><li>某个属性:后面一定记得跟一个空格!不然会报错</li><li>注意编码格式,最好手动敲,不要从网站上复制黏贴,不然你哪里的空格格式不对,等着哭吧…</li><li>记得使用git保存,随时commit,在你突然出错的不知所措的时候,可以还原,😄</li><li>没用git,没备份,为此我重新配置了好多遍….</li><li>微博秀的配置需要部署上github才能看到</li></ol><h2 id="配置自己的域名"><a href="#配置自己的域名" class="headerlink" title="配置自己的域名"></a>配置自己的域名</h2><ol><li>购买域名<br>很多人推荐什么国外的,但是比较贵,所以我还是选择了国内的<a href="http://wanwang.aliyun.com/?utm_campaign=new&amp;utm_medium=301&amp;utm_source=netcn&amp;spm=5176.3047821.1.3.3gA0Tr" target="_blank" rel="noopener">万网</a>,值得注意的是,不是所有你想要的域名都还存在.最后买的域名: yifeiyuan.me,3年265元,价格还好~</li><li><p>解析域名(dns)<br>按照<a href="https://help.github.com/articles/tips-for-configuring-an-a-record-with-your-dns-provider/" target="_blank" rel="noopener">Github</a>所提示的,在万网后台将以下两个ip解析一下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192<span class="selector-class">.30</span><span class="selector-class">.252</span><span class="selector-class">.154</span></span><br><span class="line">192<span class="selector-class">.30</span><span class="selector-class">.252</span><span class="selector-class">.153</span></span><br></pre></td></tr></table></figure></li><li><p>配置Hexo<br>在根目录下/source/ 下新建一个CNAME 文件,将你的域名填入就行</p></li><li>部署到github</li><li>过一段时间,输入yifeiyuan.me,就可以啦~</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>对于一个不懂什么服务器,什么前端的人来说,Hexo+Github给搭建个人博客带来了很大的便利.</li><li>搭建博客不是心血来潮,也并不是一帆风顺的,所以需要耐心,折腾得起才行.</li><li>很多教程已经过时,多看官方文档.</li><li>搭建博客并不是必须,写笔记文章找个平台也是可以的.</li><li>搭建博客才是第一步,坚持写好文章才是关键,路还很长.</li></ol><p>本人对Hexo的使用还只是基础的,皮毛的,可能有所遗漏,写的不好还望见谅!~</p><p>用了一会我感觉Hexo还是挺好用的,我表示我很喜欢!~</p><p>后面不出意外还会增加Hexo的使用心得/技巧,等我使用一段时间再说~</p><p>感谢Hexo,jacman,以及在搭建过程中帮助过我的人!~</p><p>希望本文能够帮助你早日搭建自己的博客!</p><p>也希望自己能写出好文章!~</p><p>8月8,好日子!~</p><p>再见!~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是程序亦非猿，整个互联网统一 ID，可能你在其他地方也看到过我了。</p><p>个人觉得我是一个非典型90后工程师，2014年毕业于某二本大学，称不上学霸，不过也年年拿奖学金。</p><p>目前主攻 Android，虽然是 计算机科学与技术专业 出身，也即所谓的科班出身。</p><p>关于 Android ，从 0 到 1 全都是我自学的，已经养成了一套自己的学习方法以及习惯。</p><p>在工作经历上呢，在小厂待过，在中厂也做过，目前在杭州阿里巴巴，算是顶尖大厂了吧。</p><p>也在阿里真一线&amp;核心部门待过，比如手机淘宝，负责过 PV 几十亿的巨型项目开发，有多巨型呢？</p><p>众所周知，手机淘宝是个航母级APP，商品详情则是导购链路核心页面，其业务复杂度超乎你想象。</p><p>为人呢，比较随和，也比较喜欢分享，对代码有洁癖，有追求。</p><p>不求改变世界，但求把世界变得更加美好。</p><h2 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h2><p>博客改过几次主题，也荒废过一段时间，导致各种问题比如阅读数量数据丢失等，比较尴尬。</p><p>在自己的博客比较自由，想写点什么就写了，可能比较任性，也有点随意。</p><p>没人能在我的博客打败我，whatever。</p><h2 id="其他平台"><a href="#其他平台" class="headerlink" title="其他平台"></a>其他平台</h2><p>微信公众号：程序亦非猿，不关注损失一个亿！<br>GitHub：<a href="https://github.com/AlanCheen" target="_blank" rel="noopener">https://github.com/AlanCheen</a>  ，不关注再损失一个亿！<br>掘金：<a href="https://juejin.im/user/558cc8dae4b0de86abc9cfda" target="_blank" rel="noopener">https://juejin.im/user/558cc8dae4b0de86abc9cfda</a></p><p>不要错过了！</p><p>欢迎交流。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Links</title>
      <link href="/friends/index.html"/>
      <url>/friends/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="友情链接："><a href="#友情链接：" class="headerlink" title="友情链接："></a>友情链接：</h2><p>  <a href="http://mrfu.me/" target="_blank" rel="noopener">MrFu</a><br>  <a href="http://www.jianshu.com/users/df40282480b4/latest_articles" target="_blank" rel="noopener">小鄧子</a><br>  <a href="http://blog.zhaiyifan.cn" target="_blank" rel="noopener">markzhai’s home</a><br>  <a href="http://abner-nimengbo.cn" target="_blank" rel="noopener">Abner</a><br>  <a href="http://www.liangzhitao.com/" target="_blank" rel="noopener">Ailurus</a><br>  <a href="http://liangfei.me/" target="_blank" rel="noopener">梁飞</a><br>  <a href="http://blog.csdn.net/lzyzsd/" target="_blank" rel="noopener">大头鬼</a><br>  <a href="http://blog.kymjs.com/" target="_blank" rel="noopener">张涛</a><br>  <a href="http://wuxiaolong.me/" target="_blank" rel="noopener">吴小龙同学</a><br>  <a href="https://www.androidperformance.com/" target="_blank" rel="noopener">Gracker</a><br>  <a href="http://www.dajipai.cc/" target="_blank" rel="noopener">香脆的大鸡排</a><br>  <a href="https://felixxiong.github.io/" target="_blank" rel="noopener">故事熊</a><br>  <a href="http://www.jayfeng.com/" target="_blank" rel="noopener">冯建</a></p><p>  <a href="http://droidyue.com/" target="_blank" rel="noopener">小黑屋</a><br>  <a href="http://blog.csdn.net/sinyu890807/" target="_blank" rel="noopener">郭霖</a><br>  <a href="http://blog.csdn.net/lmj623565791" target="_blank" rel="noopener">鸿洋</a><br>  <a href="http://blog.csdn.net/eclipsexys" target="_blank" rel="noopener">医生</a><br>  <a href="http://blog.csdn.net/singwhatiwanna" target="_blank" rel="noopener">主席</a><br>  <a href="http://hukai.me/" target="_blank" rel="noopener">胡凯</a><br>  <a href="http://www.codekk.com/open-source-project-analysis" target="_blank" rel="noopener">CodeKK</a><br>  <a href="http://gityuan.com/" target="_blank" rel="noopener">gityuan</a></p><p>  <a href="https://www.wanandroid.com/ulink" target="_blank" rel="noopener">wanandroid</a></p><p>  加友链请微信联系我，注明来意，或者在本页留下网站名称以及地址。</p><p>  <strong>注意：</strong> 我会不定期删除已失效的链接，还请见谅。</p>]]></content>
      
    </entry>
    
    
  
</search>

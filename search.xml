<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[t]]></title>
    <url>%2Ft%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客之旅]]></title>
    <url>%2F2019-02-12-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Android多渠道打包技术对比]]></title>
    <url>%2Fmuitl-channel-pkg-compare%2F</url>
    <content type="text"><![CDATA[前言 本文整理自我去年在公司内部做的一次分享，去掉了公司的信息，整理出来分享一下。希望对读者有所帮助。 加入公司后，就一直负责App的多渠道打包，今天来分享一下多渠道打包技术的介绍与对比，以及我们最后的选择。 什么是多渠道打包技术我们知道，由于某种黑暗力量，Android的亲爹市场 GooglePlay 不能进入大陆，导致大陆 Android 市场众多，如：小米、豌豆荚、华为等等等。 当新版本发布，我们需要通过渠道号来区分不同的市场，为不同市场生成不同的包，再把对应的包上传到各个市场。这种为App打出不同渠道包的技术称为多渠道打包技术。 怎么去做多渠道打包多渠道打包实现有多种，但是有两点不会变： 渠道区分 打包 接下去介绍一下现今的多渠道打包技术，以及它们之间的对比。 Umeng+Gradle我们 App 集成了 Umeng 的服务，所以就拿它举例了，事实上，不用 Umeng 也没有丝毫关系。 渠道的区分在AndroidManifest.xml中配置一个meta-data： 123&lt;meta-data android:name="UMENG_CHANNEL" android:value="$&#123;CHANNEL_NAME&#125;"/&gt; 然后在app/build.gradle里配置productFlavors： 12345678productFlavors &#123; def path = "channels.txt" file(path).eachLine &#123; channel -&gt; "$channel" &#123; manifestPlaceholders = [CHANNEL_NAME: channel] &#125; &#125;&#125; PS：channels.txt 是渠道列表文件，每一行代表一个渠道，这样方便管理。 打包方法使用 ./gradlew assembleRelease命令，就可以打出多渠道的包了。 原理该种方式的打包原理是利用了 Gradle 的flavors功能来实现的，渠道的获取是通过如下代码方式获取。 12ApplicationInfo appInfo = cxt.getPackageManager().getApplicationInfo(cxt.getPackageName(), PackageManager.GET_META_DATA);String channel = String.valueOf(appInfo.metaData.get("UMENG_CHANNEL")); 优缺点优点： 简单，易懂，没什么门槛，也不需要依赖其他工具与插件。 Gradle强大的flavor功能，可以实现不同渠道拥有不同的代码实现，可以给渠道做定制包。 扩展性强大，没有兼容性问题。 缺点： 打包速度极慢，因为每个渠道包都是从“0到1”，渠道一多，打包时间以小时为单位。 PS：我们 App 几百个渠道，用这种方式打包需要2多个小时，怎么受得了？。 所以，该方式适合渠道不多的时候使用，或者不同渠道需要使用不同的代码。 美团的打包方案 上面说到，每个渠道包都是从“0到1”，然而实际上，渠道包之间的唯一差别仅仅在于一个渠道号（这里暂时只考虑不同渠道的代码相同），如果能拿已经打好的包，拿来修改一下渠道号，变成另一个渠道包，那这速度就能大幅度提高了。 美团的打包方案，利用META-INF（解压APK可以看到）不参与 APK 签名的原理，在META-INF新增空的文件来代表渠道，实现了这个功能，极大的提高了打包的速度。 渠道的区分 META-INF目录下新增空文件，再在代码中读取文件名获取()。 PS：可以去市场下载一个美团 APP 来解压一下看看。 打包方法由于美团并没有给出具体的实现代码，所以我当时尝试的是开源实现：安卓多渠道打包工具 原理上面已经提到了，META-INF不参与 APK 签名。 在META-INF目录下新增一个空的文件来代表渠道名。 这样就可以只打一次签名包，后续只需拷贝，新增渠道文件即可。 优缺点优点： 速度极快,每打一个包就只需要复制一个APK，并新增一个空文件即可。（900个包一分钟，我天） 可以利用已存在的包打新的渠道包。（可多个） 第2点其实也是非常棒的优点，当需要一个新的渠道包时，不再需要停下工作，去保存代码，切分支，build，打包，只要一个已存在的包，一个命令就好，非常方便。 缺点： 不安全，由于不需要签名，所以任何人都可以拿到已有的包，修改成任意其他渠道的包，可能会被恶意利用污染渠道数据。 扩展性较差。（暂时没有Gradle的实现方案，相对来说选择余地较小，扩展性也差一些） 不支持 flavors 潜在风险，现在META-INF不参与APK签名，万一以后参与了，那么这套方案就失效了，当然这个概率估计很小。 似乎不支持 android 7.0？issue(没亲测，未知) 需要修改代码，修改渠道的获取方式（Umeng配置修改） 美团打包方式是一次大创新，最吸引人的就是速度快，真心快，就是打包的时间喝杯水再也不够了。 packer-ng-plugin名字太长，简称为 packer 吧。号称『下一代Android打包工具』，拥有与美团的方案相媲美的打包速度。 原理我们知道，其实 APK 是一个 Zip 文件，所以 APK 拥有 Zip 格式的特点。 该方法利用 Zip 格式的特点，修改Comment Length和File Comment两个字段，不会对ZIP文件造成破坏，将渠道信息放入其中，达到修改渠道的目的。由于修改以上内容也不需要重新签名打包，所以拥有与美团的方案相媲美的打包速度。 更多详情，见原项目Github。 渠道区分渠道信息存放在APK文件的注释字段File Comment，在代码中使用 packer 提供的方法获取。 打包方法提供了三种实现方式，Gradle、Java、Python，都可以使用。 优缺点优点： 打包速度极快。（与美团方案速度差不多） 选择性更多，作者很良心，提供了Gradle，Java，Python三种实现。 扩展性强大，由于有 Gradle 的实现方案，所以扩展性有了保障。 缺点： 不支持 flavors。 需要修改代码，修改渠道的获取方式。（Umeng配置修改） 有潜在兼容性问题，具体可见 兼容性问题(已经解决) 潜在风险，Zip 格式万一修改，那么该方式失效，这概论应该也非常低。 已知360加固后，重新签名Apk后会抹去渠道信息。 小结packer 利用 Zip 格式，又一个多渠道打包的创新，速度极快，又安全，非常棒！ 对比 对比项 Gradle 美团 packer 是否支持 flavors 是 否 否 打包速度 慢 极快 极快 安全性 高 有风险 高 扩展性 高 较低 较高 兼容性问题 无 无 无 风险 无 极低 极低 加固影响 无 未测试 丢失渠道信息(360加固) 如何选择？目前只有Gradle支持flavors功能，所以如果这个需求强烈，那么就只能选择Gradle。 如果没有这个需求，那么相对于美团打包的方式，第三种方式packer更加安全一些，速度方面也令人满意。 当然如果使用美团方式，可以在服务端过滤非法的渠道，也是可以的！~（看了美团的 APK，渠道是明文的，所以估计也是在服务端处理的，如果用的是 Umeng 统计，那么就不行喽）。 最后我们的选择是，以packer为主，Gradle为辅。 资料美团Android自动化之旅—生成渠道包安卓多渠道打包工具]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>多渠道打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[invalidate和postInvalidate的关系与区别]]></title>
    <url>%2Finvalidate-and-postinvalidate%2F</url>
    <content type="text"><![CDATA[引言我们知道，当我们需要重绘一个 View 的时候（onDraw ），通常我们有两个方法可供选择，invalidate 和 postInvalidate。 那么它们之间的关系与区别是什么呢？ 本篇从源码角度分析 invalidate 与 postInvalidate 之间的关系区别。 分析invalidate的代码调用路径： 1234567public void invalidate() &#123; invalidate(true);&#125;void invalidate(boolean invalidateCache) &#123; invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);&#125; 可以看到 invalidate 最后调用 invalidateInternal 去刷新，这里暂时不关心它们的具体实现。 然后再看看postInvalidate的代码调用路径： 123456789101112131415161718192021222324252627282930313233public void postInvalidate(int left, int top, int right, int bottom) &#123; postInvalidateDelayed(0, left, top, right, bottom);&#125;/** * This method can be invoked from outside of the UI thread * only when this View is attached to a window. */public void postInvalidateDelayed(long delayMilliseconds) &#123; // We try only with the AttachInfo because there's no point in invalidating // if we are not attached to our window final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) &#123; attachInfo.mViewRootImpl.dispatchInvalidateDelayed(this, delayMilliseconds); &#125;&#125;// ViewRootImplpublic void dispatchInvalidateDelayed(View view, long delayMilliseconds) &#123; Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view); mHandler.sendMessageDelayed(msg, delayMilliseconds);&#125;// ViewRootImpl$ViewRootHandler extends Handler@Overridepublic void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_INVALIDATE: ((View) msg.obj).invalidate(); break; case xxx: break; &#125; &#125; postInvalidate 其实是把 invalidate 这个操作封装成了一个 Message，post 到了 ViewRootImpl$ViewRootHandler 中去，最终在UI线程中调用了 View 的 invalidate。 我们知道，异步更新一个 View 会报&quot;Only the original thread that created a view hierarchy can touch its views.&quot;（来自 ViewRootImplement$checkThread）的错误， 而 postInvalidate 可以在任意线程去调用，而不需要担心线程问题。 PS：很多人说『一定要在主线程更新 UI』，其实不然，仔细看这报错信息指得是 original thread,而这个线程是创建 ViewRootImpl 的线程，而不是特指主线程，只不过是绝大部分情况下是主线程，仅此而已。 小结关系： postInvalidate 其实最终调用的就是 invalidate 差别： invalidate只能在 original thread 调用（一般就是主线程），而 postInvalidate 可以在任意线程调用。 这结论其实早就知道了，但是光知道这结论是远远不够的，要深入源码去理解，找出结论的由来； 慢慢地，会发现，其实那些知识点以及结论其实就是从源码里得来的； 自己看源码，会收获更多意想不到的知识。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RTFSC</tag>
        <tag>invalidate</tag>
        <tag>postInvalidate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LayoutInflater 源码分析（四）闪耀的彩蛋]]></title>
    <url>%2Fanalyze-layoutinflater4-blinklayout%2F</url>
    <content type="text"><![CDATA[BlinkLayout源码分析private static class BlinkLayout extends FrameLayout 首先，我猜，你肯定不知道有这个BlinkLayout的存在！！！ 据我所知，没有一本书里讲到过它（反正我是没见过），甚至国内的博客都没有人提及过它！！ 因为它隐藏的非常深，是LayoutInflater的静态内部类，是我在看LayoutInflater源码的时候发现的！简直是个彩蛋！！ 在这里发现的： 1234if (name.equals(TAG_1995)) &#123; // Let's party like it's 1995! return new BlinkLayout(context, attrs);&#125; oh,它其实还真算是个彩蛋，似乎是为了庆祝1995年的复活节，有兴趣可以看看reddit上的讨论。 blink 有 使…闪烁的意思，可以用来做一闪一闪的效果哦！！！ 先上个简单的效果图看看它的效果： 是不是很闪？ 明明这么闪耀，为何要躲起来？ BlinkLayout的使用也有些特殊，它跟merge、include这些标签一样，用标签blink来表示。 贴一下上图效果的XML： 1234567891011121314151617&lt;blink android:layout_width="wrap_content" android:layout_height="wrap_content" &gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/ic_launcher" &gt; &lt;/ImageView&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!"/&gt;&lt;/blink&gt; 非常简单！ 那么它是怎么实现的呢？ 接下去源码分析。 源码分析BlinkLayout的源码非常简单，只有几十行！我就全部贴出来啦！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private static class BlinkLayout extends FrameLayout &#123; private static final int MESSAGE_BLINK = 0x42; private static final int BLINK_DELAY = 500; private boolean mBlink; private boolean mBlinkState; private final Handler mHandler; public BlinkLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); mHandler = new Handler(new Handler.Callback() &#123; @Override public boolean handleMessage(Message msg) &#123; if (msg.what == MESSAGE_BLINK) &#123; if (mBlink) &#123; mBlinkState = !mBlinkState; // 循环调用 makeBlink makeBlink(); &#125; // 触发 dispatchDraw invalidate(); return true; &#125; return false; &#125; &#125;); &#125; // 发送blink指令 private void makeBlink() &#123; Message message = mHandler.obtainMessage(MESSAGE_BLINK); mHandler.sendMessageDelayed(message, BLINK_DELAY); &#125; @Override protected void onAttachedToWindow() &#123; super.onAttachedToWindow(); // 设置为可以闪啦 mBlink = true; mBlinkState = true; // 发送消息 makeBlink(); &#125; @Override protected void onDetachedFromWindow() &#123; super.onDetachedFromWindow(); mBlink = false; mBlinkState = true; // 移除消息 避免内存泄漏 mHandler.removeMessages(MESSAGE_BLINK); &#125; @Override protected void dispatchDraw(Canvas canvas) &#123; // 通过这个开关来控制是否分发绘制事件，来达到一闪一闪的效果 if (mBlinkState) &#123; super.dispatchDraw(canvas); &#125; &#125;&#125; 从源码中可以看出，BlinkLayout通过Handler循环调用invalidate()方法，触发并控制dispatchDraw来做到一闪一闪的效果，默认的闪烁间隔为Handler的DELAY时间，即500毫秒。 ## 小结 BlinkLayout的使用场景或许不多，但是它的代码还是非常漂亮哒！~ 如果有类似需求，仿造它的源码写一个功能更强的View也是非常简单的！ 深入源码阅读是一件相对枯燥的事情，能发现这么个小彩蛋也是棒棒的，心情也美丽了些，哈哈！~~]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RTFSC</tag>
        <tag>LayoutInflater</tag>
        <tag>BlinkLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LayoutInflater源码分析（三）fragment 标签的处理]]></title>
    <url>%2Fanalyze-layoutinflater3-fragment%2F</url>
    <content type="text"><![CDATA[前言在上一篇LayoutInflater 源码分析（二）中分析了LayoutInflater对include以及merge标签的处理，但是并没有找到对fragment的处理痕迹。 本文将继续探索以求揭晓答案。 可能有同学不知道，在这里提一下fragment标签的使用方式： 1234567&lt;fragment android:layout_width="match_parent" android:layout_height="match_parent" class="me.yifeiyuan.MainFragment" android:tag="Main" android:id="@+id/main" /&gt; 这属于加载 Fragment 中的静态加载，在 XML 中写死了 class，缺乏灵活性，实际开发中并不常用，甚至已经淘汰了，所以不推荐使用。 不过这并不妨碍对它的原理探究。 分析思路在第一篇分析中提到了 Factory 的 Hook 机制，代码如下: 123456789101112View view;if (mFactory2 != null) &#123; view = mFactory2.onCreateView(parent, name, context, attrs);&#125; else if (mFactory != null) &#123; view = mFactory.onCreateView(name, context, attrs);&#125; else &#123; view = null;&#125;// mPrivateFactory 是个 FactoryMerger if (view == null &amp;&amp; mPrivateFactory != null) &#123; view = mPrivateFactory.onCreateView(parent, name, context, attrs);&#125; 为了便于理解那些个 Factory，特意大致的画了一张类图： 注意：前面代码中的mPrivateFactory 是个 FactoryMerger 对象。 可能看到这里还是会有些茫然，不过仔细一回想我们在使用 Fragment 的时候都会继承 FragmentActivity，所以去 FragmentActivity 寻找答案感觉比较靠谱。 接下去开始分析。 寻找踪迹之 FragmentActivity查看了源码后发现，FragmentActivity 的继承结构如下 其实 Activity 就已经实现了 LayoutInflater.Factory2 接口，具体实现如下： 123456789101112public View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123; // 如果不是 fragment 则调用另一个onCreateView，而它返回的是 null if (!"fragment".equals(name)) &#123; return onCreateView(name, context, attrs); &#125; // 如果是 fragment 标签 则交给了 mFragments return mFragments.onCreateView(parent, name, context, attrs);&#125;public View onCreateView(String name, Context context, AttributeSet attrs) &#123; return null;&#125; 可以看到如果是 fragment 标签，则会交给一个叫 mFragments 的FragmentController类的对象。 但是需要注意的是：Activity 并没有调用 LayoutInflater.setFactory 使之生效，所以 Activity 并不支持 fragment 的解析。 继续看它的子类的实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// Donut 好古老的版本啊~abstract class BaseFragmentActivityDonut extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; if (Build.VERSION.SDK_INT &lt; 11 &amp;&amp; getLayoutInflater().getFactory() == null) &#123; // On pre-HC devices we need to manually install ourselves as a Factory. // On HC and above, we are automatically installed as a private factory getLayoutInflater().setFactory(this); &#125; super.onCreate(savedInstanceState); &#125; //重写 onCreateView @Override public View onCreateView(String name, Context context, AttributeSet attrs) &#123; // 优先调用 dispatchFragmentsOnCreateView final View v = dispatchFragmentsOnCreateView(null, name, context, attrs); if (v == null) &#123; return super.onCreateView(name, context, attrs); &#125; return v; &#125; abstract View dispatchFragmentsOnCreateView(View parent, String name, Context context, AttributeSet attrs);&#125;// Honeycombabstract class BaseFragmentActivityHoneycomb extends BaseFragmentActivityDonut &#123; @Override public View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123; final View v = dispatchFragmentsOnCreateView(parent, name, context, attrs); if (v == null &amp;&amp; Build.VERSION.SDK_INT &gt;= 11) &#123; // If we're running on HC or above, let the super have a go return super.onCreateView(parent, name, context, attrs); &#125; return v; &#125;&#125;// FragmentActivity 并没有重写 onCreateViewpublic class FragmentActivity extends BaseFragmentActivityHoneycomb&#123; @Override final View dispatchFragmentsOnCreateView(View parent, String name, Context context, AttributeSet attrs) &#123; return mFragments.onCreateView(parent, name, context, attrs); &#125;&#125; 可以看到，在BaseFragmentActivityDonut中调用了setFactory，并定义了一个dispatchFragmentsOnCreateView抽象方法，并在onCreateView里调用了它，这样就把创建 View 的工作交给了dispatchFragmentsOnCreateView。 接着，在 FragmentActivity 重写dispatchFragmentsOnCreateView，又把它交给了mFragments，咦，又回去了。 其实到这里已经可以知道，LayoutInflater把处理fragment的事情最终交给了FragmentManagerImpl。 而对于FragmentManagerImpl的分析其实已经超过了本文的界限。 但是我想再深入，看看Fragment的onCreateView方法究竟是什么时候调用的！！ 所以继续跟下去： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123; //mFragmentManager 是 FragmentManagerImpl 的实例 return mHost.mFragmentManager.onCreateView(parent, name, context, attrs);&#125;// #FragmentManagerImpl @Overridepublic View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123; // 不为 fragment 直接 return null 说明确实只处理 fragment if (!"fragment".equals(name)) &#123; return null; &#125; // xml 中的 各种 属性 fname为 Fragemnt 的全路径 String fname = attrs.getAttributeValue(null, "class"); TypedArray a = context.obtainStyledAttributes(attrs, FragmentTag.Fragment); if (fname == null) &#123; fname = a.getString(FragmentTag.Fragment_name); &#125; int id = a.getResourceId(FragmentTag.Fragment_id, View.NO_ID); String tag = a.getString(FragmentTag.Fragment_tag); a.recycle(); if (!Fragment.isSupportFragmentClass(mHost.getContext(), fname)) &#123; // Invalid support lib fragment; let the device's framework handle it. // This will allow android.app.Fragments to do the right thing. return null; &#125; // 如果配置的信息不够 则会抛异常 int containerId = parent != null ? parent.getId() : 0; if (containerId == View.NO_ID &amp;&amp; id == View.NO_ID &amp;&amp; tag == null) &#123; throw new IllegalArgumentException(attrs.getPositionDescription() + ": Must specify unique android:id, android:tag, or have a parent with an id for " + fname); &#125; // If we restored from a previous state, we may already have // instantiated this fragment from the state and should use // that instance instead of making a new one. // 尝试着先去找 fragment Fragment fragment = id != View.NO_ID ? findFragmentById(id) : null; if (fragment == null &amp;&amp; tag != null) &#123; fragment = findFragmentByTag(tag); &#125; if (fragment == null &amp;&amp; containerId != View.NO_ID) &#123; fragment = findFragmentById(containerId); &#125; if (FragmentManagerImpl.DEBUG) Log.v(TAG, "onCreateView: id=0x" + Integer.toHexString(id) + " fname=" + fname + " existing=" + fragment); // 如果没有 则去实例化 if (fragment == null) &#123; // 调用 instantiate 其实也是反射来实例化的。 fragment = Fragment.instantiate(context, fname); fragment.mFromLayout = true; fragment.mFragmentId = id != 0 ? id : containerId; fragment.mContainerId = containerId; fragment.mTag = tag; fragment.mInLayout = true; fragment.mFragmentManager = this; fragment.mHost = mHost; fragment.onInflate(mHost.getContext(), attrs, fragment.mSavedFragmentState); addFragment(fragment, true); &#125; else if (fragment.mInLayout) &#123; // A fragment already exists and it is not one we restored from // previous state. throw new IllegalArgumentException(attrs.getPositionDescription() + ": Duplicate id 0x" + Integer.toHexString(id) + ", tag " + tag + ", or parent id 0x" + Integer.toHexString(containerId) + " with another fragment for " + fname); &#125; else &#123; // This fragment was retained from a previous instance; get it // going now. fragment.mInLayout = true; fragment.mHost = mHost; // If this fragment is newly instantiated (either right now, or // from last saved state), then give it the attributes to // initialize itself. if (!fragment.mRetaining) &#123; fragment.onInflate(mHost.getContext(), attrs, fragment.mSavedFragmentState); &#125; &#125; // If we haven't finished entering the CREATED state ourselves yet, // push the inflated child fragment along. if (mCurState &lt; Fragment.CREATED &amp;&amp; fragment.mFromLayout) &#123; moveToState(fragment, Fragment.CREATED, 0, 0, false); &#125; else &#123; moveToState(fragment); &#125; if (fragment.mView == null) &#123; throw new IllegalStateException("Fragment " + fname + " did not create a view."); &#125; if (id != 0) &#123; fragment.mView.setId(id); &#125; if (fragment.mView.getTag() == null) &#123; fragment.mView.setTag(tag); &#125; return fragment.mView;&#125; 可以看到，在处理 xml 中的属性后，会先去寻找要加载的 fragment 是否已经加载过了，如果没有则会调用fragment = Fragment.instantiate(context, fname);，这个方法也是反射，这点其实跟 View 的处理是一样的。 接着会去调用moveToState方法，而这个方法里，我看了onCreateView方法的调用时机。 伪代码如下（太复杂，删减了绝大部分代码）： 12345678910111213141516// # FragmentManagervoid moveToState(Fragment f, int newState, int transit, int transitionStyle,boolean keepActive) &#123; //... f.mView = f.performCreateView(xxx); //....&#125;// 真正的调用时机在这里！！// # FragmentView performCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; if (mChildFragmentManager != null) &#123; mChildFragmentManager.noteStateNotSaved(); &#125; // 调用onCreateView 熟悉吧？ return onCreateView(inflater, container, savedInstanceState);&#125; 可以看到，FragmentManager的moveToState中会去调用Fragment的performCreateView方法，而它里面，调用了onCreateView！！ onCreateView熟悉吧？就是我们使用 Fragment 第一个重写的方法！ 终于找到啦！！ 呼，藏得真深。 不过功夫不负有心人！~~~ 爽！~ 小结FragmentActivity通过 setFactory把对fragment标签的处理委托给了 FragmentManageImpl的onCreateView方法。 最终通过反射，实例化指定的 Fragment，并调用了Fragment.performCreateView，最后到我们所熟悉的onCreateView。 整体的流程分析完毕。 另外要说的是，LayoutInflater.Factory的作用其实非常强大，我们可以 Hook 每个 View 的创建于设置，比如 AppCompact库通过AppCompactViewInflater Hook 了大部分 View，给我们提供了向下兼容的功能； 另外它也还可以配合 DayNight 实现夜间模式功能，有兴趣可以去看看AppCompactActivity、AppCompactViewInflater等类，有机会再讲吧。 到此对于 LayoutInflater 的源码分析已经结束，在查看源码的过程中发现一枚彩蛋，下一篇分享。 推荐阅读一步一步深入理解CoordinatorLayoutViewStub是如何实现懒加载的Space源码分析LayoutInflater 源码分析（一）之 inflate 深度分析LayoutInflater源码分析（二）之include以及merge标签的处理]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RTFSC</tag>
        <tag>LayoutInflater</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LayoutInflater源码分析（二）include以及merge标签的处理]]></title>
    <url>%2Fanalyze-layoutinflater2-include-and-merge%2F</url>
    <content type="text"><![CDATA[前言接上篇LayoutInflater 源码分析（一）之 inflate 深度分析 本篇继续对LayoutInflater进行源码分析,目标为分析LayoutInflater对include、merge、fragment等标签的处理原理以及onFinishInflate的调用时机。 merge 标签分析上篇我们讲到inflate方法中出现 Merge 的踪迹，代码如下： 12345678if (TAG_MERGE.equals(name)) &#123; if (root == null || !attachToRoot) &#123; throw new InflateException("&lt;merge /&gt; can be used only with a valid " + "ViewGroup root and attachToRoot=true"); &#125; // 调用 rInflate 注意最后的参数是 false rInflate(parser, root, inflaterContext, attrs, false);&#125; 所以需要看 rInflate方法才行。 rInflate 深入解析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Recursive method used to descend down the xml hierarchy and instantiate * views, instantiate their children, and then call onFinishInflate(). * &lt;p&gt; * &lt;strong&gt;Note:&lt;/strong&gt; Default visibility so the BridgeInflater can * override it. * 递归方法 实例化 View 以及它的子 View,并且调用 onFinishInflate */void rInflate(XmlPullParser parser, View parent, Context context, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123; final int depth = parser.getDepth(); int type; // while 循环 parser.next 遍历整个 XML while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; if (type != XmlPullParser.START_TAG) &#123; continue; &#125; //获取标签名 final String name = parser.getName(); //如果是 requestFocus if (TAG_REQUEST_FOCUS.equals(name)) &#123; parseRequestFocus(parser, parent); &#125; else if (TAG_TAG.equals(name)) &#123; // 处理 tag parseViewTag(parser, parent, attrs); &#125; else if (TAG_INCLUDE.equals(name)) &#123; if (parser.getDepth() == 0) &#123; throw new InflateException("&lt;include /&gt; cannot be the root element"); &#125; // 处理 include parseInclude(parser, context, parent, attrs); &#125; else if (TAG_MERGE.equals(name)) &#123; // merge 里不能再有 merge 标签的 throw new InflateException("&lt;merge /&gt; must be the root element"); &#125; else &#123; // 如果不是特殊的标签那么走 createViewFromTag final View view = createViewFromTag(parent, name, context, attrs); final ViewGroup viewGroup = (ViewGroup) parent; final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs); rInflateChildren(parser, view, attrs, true); viewGroup.addView(view, params); &#125; &#125; // 注意这里从传递inflate传递过来的是 false！！ // 从 rInflateChildren 过来的是 true！！！ if (finishInflate) &#123; parent.onFinishInflate(); &#125;&#125; 从注释来看rInflate方法，是个 递归方法 实例化 View 以及它的子 View,并且调用 onFinishInflate 从源码来看，rInflate方法先判断特殊的标签名，优先处理： 针对requestFocus标签,调用parseRequestFocus方法 针对tag标签，调用 parseViewTag 方法 针对merge标签则直接抛了异常，因为merge标签不能是子元素 很奇怪，并没有看到 fragment 标签的处理逻辑! 处理完特殊标签之后走到最后一个else 块中，这块代码需要注意： 1234567891011121314// 如果不是特殊的标签那么走 createViewFromTag 获得 view// createViewFromTag 方法的流程已经分析过了，不再多说。 final View view = createViewFromTag(parent, name, context, attrs);// 注意注意 这边的 parent 是之前inflate传入的 rootfinal ViewGroup viewGroup = (ViewGroup) parent;// 生成 paramasfinal ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);// 调用 rInflateChildren 把 view传递过去 并传了一个 true 过去rInflateChildren(parser, view, attrs, true);// 注意// 注意// 注意// 这里直接调用 viewGroup 的 addView 这也是 merge 能减少层级的根本原因viewGroup.addView(view, params); 这里涉及到一个方法rInflateChildren，其实它在上一篇中的inflate方法中出现过，不过我并没有去分析，所以这里讲一下。 方法实现如下： 1234final void rInflateChildren(XmlPullParser parser, View parent, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123; rInflate(parser, parent, parent.getContext(), attrs, finishInflate);&#125; rInflateChildren 是个递归方法，被用来实例化不是 root 的子View，实际也是调用rInflate方法。(所以才是递归了嘛！) 这里需要注意的是finishInflate，按照之前所说的流程，rInflate方法传递过来的finishInflate参数为false,在上一篇中inflate传递的参数是true,这关系到onFinishInflate的回调。 了解完rInflateChildren方法后，继续分析。 可以看到，在处理merge标签的时候，是将merge标签里解析出来的 View 直接 add 到了传递进来的root中去了，而并不会多加一层 View，从而实现减少层级的效果，这就是merge标签的原理所在了。最后，由于inflate传递进来的finishInflate为 false，所以不会去调用parent.onFinishInflate(); 到此也知晓了LayoutInflater是如何处理merge标签以及merge减少布局层次的原理了。 include 标签123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127private void parseInclude(XmlPullParser parser, Context context, View parent, AttributeSet attrs) throws XmlPullParserException, IOException &#123; int type; if (parent instanceof ViewGroup) &#123; // Apply a theme wrapper, if requested. This is sort of a weird // edge case, since developers think the &lt;include&gt; overwrites // values in the AttributeSet of the included View. So, if the // included View has a theme attribute, we'll need to ignore it. final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME); final int themeResId = ta.getResourceId(0, 0); final boolean hasThemeOverride = themeResId != 0; if (hasThemeOverride) &#123; context = new ContextThemeWrapper(context, themeResId); &#125; ta.recycle(); // If the layout is pointing to a theme attribute, we have to // massage the value to get a resource identifier out of it. int layout = attrs.getAttributeResourceValue(null, ATTR_LAYOUT, 0); if (layout == 0) &#123; // 没有 layout 属性则抛异常 final String value = attrs.getAttributeValue(null, ATTR_LAYOUT); if (value == null || value.length() &lt;= 0) &#123; throw new InflateException("You must specify a layout in the" + " include tag: &lt;include layout=\"@layout/layoutID\" /&gt;"); &#125; // Attempt to resolve the "?attr/name" string to an identifier. layout = context.getResources().getIdentifier(value.substring(1), null, null); &#125; // The layout might be referencing a theme attribute. if (mTempValue == null) &#123; mTempValue = new TypedValue(); &#125; if (layout != 0 &amp;&amp; context.getTheme().resolveAttribute(layout, mTempValue, true)) &#123; layout = mTempValue.resourceId; &#125; // 之前的代码都是处理 theme layout 属性 不多说。 if (layout == 0) &#123; // 必须指定有效的layout final String value = attrs.getAttributeValue(null, ATTR_LAYOUT); throw new InflateException("You must specify a valid layout " + "reference. The layout ID " + value + " is not valid."); &#125; else &#123; final XmlResourceParser childParser = context.getResources().getLayout(layout); try &#123; final AttributeSet childAttrs = Xml.asAttributeSet(childParser); while ((type = childParser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // Empty. &#125; if (type != XmlPullParser.START_TAG) &#123; throw new InflateException(childParser.getPositionDescription() + ": No start tag found!"); &#125; final String childName = childParser.getName(); if (TAG_MERGE.equals(childName)) &#123; // The &lt;merge&gt; tag doesn't support android:theme, so // nothing special to do here. rInflate(childParser, parent, context, childAttrs, false); &#125; else &#123; // 获取 被 inlcude 的 topview final View view = createViewFromTag(parent, childName, context, childAttrs, hasThemeOverride); final ViewGroup group = (ViewGroup) parent; final TypedArray a = context.obtainStyledAttributes( attrs, R.styleable.Include); final int id = a.getResourceId(R.styleable.Include_id, View.NO_ID); final int visibility = a.getInt(R.styleable.Include_visibility, -1); a.recycle(); // We try to load the layout params set in the &lt;include /&gt; tag. // If the parent can't generate layout params (ex. missing width // or height for the framework ViewGroups, though this is not // necessarily true of all ViewGroups) then we expect it to throw // a runtime exception. // We catch this exception and set localParams accordingly: true // means we successfully loaded layout params from the &lt;include&gt; // tag, false means we need to rely on the included layout params. ViewGroup.LayoutParams params = null; try &#123;// 尝试对 include 标签生成 params params = group.generateLayoutParams(attrs); &#125; catch (RuntimeException e) &#123; // Ignore, just fail over to child attrs. &#125; // 如果失败 则对被 include 的 topview 处理 if (params == null) &#123; params = group.generateLayoutParams(childAttrs); &#125; view.setLayoutParams(params); // Inflate all children. 前面已经提到过了 rInflateChildren(childParser, view, childAttrs, true); // 处理 id if (id != View.NO_ID) &#123; view.setId(id); &#125; // 处理可见性 switch (visibility) &#123; case 0: view.setVisibility(View.VISIBLE); break; case 1: view.setVisibility(View.INVISIBLE); break; case 2: view.setVisibility(View.GONE); break; &#125; // 把 view 添加到 group 中 group.addView(view); &#125; &#125; finally &#123; childParser.close(); &#125; &#125; &#125; else &#123; throw new InflateException("&lt;include /&gt; can only be used inside of a ViewGroup"); &#125; LayoutInflater.consumeChildElements(parser);&#125; 首先判断 parent 是不是个 ViewGroup,如果不是则直接抛异常。 如果是则接下去处理 theme 属性以及 layout 属性，我们知道使用include标签，layout 属性是必须要有的。 其原因就是在源码中如果发现没有指定 layout 属性的话，那么会直接抛出异常。 再接下去的步骤可以看出其实跟上篇inflate方法类似： 通过调用createViewFromTag解析获取被include的 topview 生成 params，这里要注意，include标签可能没有宽高，会导致生成失败，如果失败则接着又对被include的 topview 做操作。所以使用include的时候，不对它设置宽高是没有关系的。 调用rInflateChildren处理子View 之前已经分析过 把 include 标签的 id 以及 visibility属性 设置给 topview（如果有的话） topView 被直接 add 进 group，这样被 include 的 topView 就被加到布局里去了。 小结通过阅读源码，其实 merge 以及 include 等标签处理其实并不难，而且它们的使用方法在源码中皆有体现。 稍微总结一下要点： 使用 LayoutInflater 去 inflate merge 标签的时候，root 一定不能为 null，attachToRoot 也不能为 false merge标签在 XML 中必须是根元素 与 merge 标签相反，include 绝对不能是根元素，必须需要在一个 ViewGroup 中使用 使用 include 标签必须指定有效的 layout 属性 使用 include 标签不写宽高是没有关系的（会去解析被 include 的 layout） 到这里merge以及include已经分析完毕。 同时也看到了其他标签如tag、requestFocus的处理（很简单就不分析了），但是就是没看到fragment标签。 那究竟是在哪处理fragment标签的呢？ 下一篇为你揭晓答案。 推荐阅读一步一步深入理解CoordinatorLayoutLayoutInflater 源码分析（一）之 inflate 深度分析LayoutInflater源码分析（二）之include以及merge标签的处理]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RTFSC</tag>
        <tag>LayoutInflater</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LayoutInflater源码分析（一）inflate深度分析]]></title>
    <url>%2Fanalyze-layoutinflater1-inflate%2F</url>
    <content type="text"><![CDATA[简介public abstract class LayoutInflater LayoutInflater,布局填充器，从名字就可以看出它用于加载布局。 我们常用的方式大概如下： 12// 方法定义：inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot)View view = LayoutInflater.from(context).inflate(R.layout.resource,root,flase); 这样我们就可以把一个 XML 文件实例化成一个 View 来供我们使用。 PS：LayoutInflater的获取方式不止这一种，实际最终调用的都是 Context.getSystemService 方法，最终拿到的是PhoneLayoutInflater,有兴趣的同学可以去看看我的Context.getSystemService分析。 上述代码我写过无数遍，但是心中一直有很多疑问： 上述方法中的root、attachToRoot究竟有什么作用？ 它究竟是在哪里实例化View又是如何去实例化 View 的？ 为什么系统的View我们在Xml里不需要写全路径，而自定义View却需要？ 它又是如何处理fragment以及各种标签如include、merge的？ View的onFinishInflate是否跟它有关呢？ 这一切都藏在源码里，所以深入源码一点点了解吧！ inflate深入解析上面的例子中可以看到，我们调用的是inflate(in resource, in root, in attachToRoot)方法，所以首先分析一下该方法。 12345678910111213141516public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123; //获取rescources final Resources res = getContext().getResources(); if (DEBUG) &#123; Log.d(TAG, "INFLATING from resource: \"" + res.getResourceName(resource) + "\" (" + Integer.toHexString(resource) + ")"); &#125; // 获取parser 这里我不关心parse是怎么来的 final XmlResourceParser parser = res.getLayout(resource); try &#123; // 调用了另外一个inflate方法 return inflate(parser, root, attachToRoot); &#125; finally &#123; parser.close(); &#125;&#125; 上面代码可以看到该方法主要是获取一个XmlResourceParser对象parser（这里不关心它是如何来的）。 不过需要提一下的这里解析XML采用的是 Pull方法(不知道的自行Google)。 然后调用了另外一个inflate方法，所以我们还需要继续跟踪inflate(parser, root, attachToRoot)才能进一步理解。 上代码！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, "inflate"); // 一些赋值 后续会有用到 final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; // 先把result赋值为我们传递的root View result = root; try &#123; // Look for the root node. int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // Empty &#125; if (type != XmlPullParser.START_TAG) &#123; throw new InflateException(parser.getPositionDescription() + ": No start tag found!"); &#125; // 获取标签名字 比如FrameLayout final String name = parser.getName(); if (DEBUG) &#123; System.out.println("**************************"); System.out.println("Creating root view: " + name); System.out.println("**************************"); &#125; // 这里的 TAG_MERGE 为 merge 看到了merge的身影 if (TAG_MERGE.equals(name)) &#123; // 不知道merge怎么用？ 这个异常教你做人。 if (root == null || !attachToRoot) &#123; throw new InflateException("&lt;merge /&gt; can be used only with a valid " + "ViewGroup root and attachToRoot=true"); &#125; //如果为 merge 调用rInflate方法 后面再具体分析merge的情况 rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; // Temp is the root view that was found in the xml // 这里调用了一个createViewFromTag 从名字来看，就是用来创建View的！ // 注意，这里的temp其实是我们xml里的top view,具体暂时先不管 先把整个流程看了 final View temp = createViewFromTag(root, name, inflaterContext, attrs); //接下去处理LayoutParams ViewGroup.LayoutParams params = null; //如果我们传递进来的root不为null if (root != null) &#123; if (DEBUG) &#123; System.out.println("Creating params from root: " + root); &#125; // Create layout params that match root, if supplied // 那么调用 root的generateLayoutParams 来生成LayoutParamas params = root.generateLayoutParams(attrs); //如果attachToRoot为false，那么就把刚生成的params赋值给View if (!attachToRoot) &#123; // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); &#125; &#125; if (DEBUG) &#123; System.out.println("-----&gt; start inflating children"); &#125; // 源码的打印日志已经告诉我，这里是加载子View的~~ 后续再讲解 // Inflate all children under temp against its context. rInflateChildren(parser, temp, attrs, true); if (DEBUG) &#123; System.out.println("-----&gt; done inflating children"); &#125; // We are supposed to attach all the views we found (int temp) // to root. Do that now. // root不为null 并且 attachToRoot 则直接把temp添加到root里去 if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; // Decide whether to return the root that was passed in or the // top view found in xml. // null或false 那么结果就是之前的top view了 if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; &#125; catch (XmlPullParserException e) &#123; InflateException ex = new InflateException(e.getMessage()); ex.initCause(e); throw ex; &#125; catch (Exception e) &#123; InflateException ex = new InflateException( parser.getPositionDescription() + ": " + e.getMessage()); ex.initCause(e); throw ex; &#125; finally &#123; // Don't retain static reference on context. mConstructorArgs[0] = lastContext; mConstructorArgs[1] = null; &#125; Trace.traceEnd(Trace.TRACE_TAG_VIEW); // 返回结果 return result; &#125;&#125; 可以看到该方法是重点了。 这里出现了merge的踪迹，可以看到遇到merge标签，当root为null或者attachToRoot为false的时候，直接抛了异常！也可以看到如果是merge标签，走的是rInflate方法(不过这里暂时不分析rInflate方法)。 关键的是，我看到inflate方法处理了root与attachToRoot参数。 围绕root是否为null有两种处理分支： 第一种 当root不为null的时候： 调用root.generateLayoutParams方法来生成LayoutParamas并赋值给paramas 然后如果attachToRoot为false，则把paramas赋值给createViewFromTag解析出来的temp（XML里的根布局） 而如果attachToRoot为true的话，则会 调用root.addView(temp, params); 直接把temp给加到root里去。如果我们自己再调用addView则会报错！ 这里再提一下root 对topView的LayoutParamas的影响： 需要先提一下 LayoutParamas 一般有3种来源： 用户完全自定义 自己 new 出来 ViewGroup.generateLayoutParams 方法生成 上面已经提到 ViewGroup.generateDefaultLayoutParams 方法生成，在addView的时候 如果 childView 没有的话 LayoutParams 属性的话，会由这个方法生成。 来看一下 addView 里对 paramas 的操作就明白了： 1234567891011121314151617public void addView(View child) &#123; addView(child, -1);&#125;public void addView(View child, int index) &#123; if (child == null) &#123; throw new IllegalArgumentException("Cannot add a null child view to a ViewGroup"); &#125; LayoutParams params = child.getLayoutParams(); if (params == null) &#123; // 没有 params 则调用 generateDefaultLayoutParams 去生成 params = generateDefaultLayoutParams(); if (params == null) &#123; throw new IllegalArgumentException("generateDefaultLayoutParams() cannot return null"); &#125; &#125; addView(child, index, params);&#125; 所以当 root 不为 null 的时候，topview 的 paramas 是通过generateLayoutParams生成的。 需要注意的是：generateLayoutParams与generateDefaultLayoutParams生成的 paramas 是不同的,会无视我们在 xml 里配置的属性，所以它会影响到布局效果。 第二种 当root为null的时候： 是null的时候会返回temp （XML里的根布局） 1234// null 或是 false 那么result=tempif (root == null || !attachToRoot) &#123; result = temp;&#125; 也可以看到，root==null如果成立，那么attachToRoot也就没有用了。 所以attachToRoot只有在root不为 null 的时候才有效。 大致总结成流程图如下所示： 搞清楚root以及attachToRoot参数的影响之后，来看View究竟是如何被创建的。 进入createViewFromTag方法。 createViewFromTag解析上面提到的createViewFromTag方法如下： 12345678910/** * 提到了include，除了include，都会被使用 * Convenience method for calling through to the five-arg createViewFromTag * method. This method passes &#123;@code false&#125; for the &#123;@code ignoreThemeAttr&#125; * argument and should be used for everything except &#123;@code &amp;gt;include&gt;&#125; * tag parsing. */private View createViewFromTag(View parent, String name, Context context, AttributeSet attrs) &#123; return createViewFromTag(parent, name, context, attrs, false);//这里传了false进去&#125; 可以看到，它又调用了另外一个重载函数，并从注释中我们可以看到了include的信息。 该方法把ignoreThemeAttr属性赋值为了false，继续跟下去。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * Creates a view from a tag name using the supplied attribute set. * @param ignoreThemeAttr &#123;@code true&#125; to ignore the &#123;@code android:theme&#125; * attribute (if set) for the view being inflated, * &#123;@code false&#125; otherwise */View createViewFromTag(View parent, String name, Context context, AttributeSet attrs, boolean ignoreThemeAttr) &#123; if (name.equals("view")) &#123; name = attrs.getAttributeValue(null, "class"); &#125; // Apply a theme wrapper, if allowed and one is specified. // 之前传递过来的为false if (!ignoreThemeAttr) &#123; final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME); final int themeResId = ta.getResourceId(0, 0); //如果设置了theme 那么context会被重新实例化为 ContextThemeWrapper if (themeResId != 0) &#123; context = new ContextThemeWrapper(context, themeResId); &#125; ta.recycle(); &#125; // 彩蛋后续 分析 if (name.equals(TAG_1995)) &#123; // Let's party like it's 1995! return new BlinkLayout(context, attrs); &#125; // 这里开始去创建View了 try &#123; View view; //如果mFactory2不为null 那么mFactory2先解析 if (mFactory2 != null) &#123; view = mFactory2.onCreateView(parent, name, context, attrs); &#125; else if (mFactory != null) &#123; // 接着是 mFactory view = mFactory.onCreateView(name, context, attrs); &#125; else &#123; view = null; &#125; // 如果 mFactory2 mFactory都返回null了 那么如果mPrivateFactory不为null，则交给它 if (view == null &amp;&amp; mPrivateFactory != null) &#123; view = mPrivateFactory.onCreateView(parent, name, context, attrs); &#125; // 如果 那几个factory都返回null 即view还是null 那么继续 if (view == null) &#123; final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try &#123; // 有. 代表不是系统自带的View,比如TextView、me.yifeiyuan.XXXLayout if (-1 == name.indexOf('.')) &#123; view = onCreateView(parent, name, attrs); &#125; else &#123; // 系统自带的View view = createView(name, null, attrs); &#125; &#125; finally &#123; mConstructorArgs[0] = lastContext; &#125; &#125; return view; &#125; catch (InflateException e) &#123; throw e; &#125; catch (ClassNotFoundException e) &#123; final InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + name); ie.initCause(e); throw ie; &#125; catch (Exception e) &#123; final InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + name); ie.initCause(e); throw ie; &#125;&#125; 该createViewFromTag方法 先处理了主题属性，再走入创建View的流程。 这里还涉及到了几个Factory，这其实是系统留给我们的Hook入口，我们可以人为的干涉系统创建View，可以添加更多功能，比如夜间模式。 Factory相关的知识后续再讲。 另外，我们可以看到该方法依然没有涉及到创建View的具体实现，而是又会去调用onCreateView以及createView方法，这俩方法总应该是View创建的具体地方了吧？！！ onCreateView 与 createView初步来看onCreateView方法负责创建自定义View，而createView方法负责创建系统自带的View。但是感觉比较奇怪，因为不管是什么View，创建的套路应该是一样才对啊~感觉有诈！ 1234protected View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException &#123; return createView(name, "android.view.", attrs);&#125; 咦！~ onCreateView调用了createView，到最后，其实都是调用createView方法啦！ 另外还传入了android.view.的一个参数，咦？这不是系统自带的View的包路径吗？ 继续深入createView。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public final View createView(String name, String prefix, AttributeSet attrs) throws ClassNotFoundException, InflateException &#123; // 构造方法缓存 Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name); Class&lt;? extends View&gt; clazz = null; try &#123; // Trace Trace.traceBegin(Trace.TRACE_TAG_VIEW, name); //没有缓存 则去获取constructor 并存入缓存 注意这个缓存是静态的 if (constructor == null) &#123; // Class not found in the cache, see if it's real, and try to add it // 注意 注意 注意 在这里把 View的全称拼全，并loadClass 难怪要传递android.View.进来啊~ clazz = mContext.getClassLoader().loadClass( prefix != null ? (prefix + name) : name).asSubclass(View.class); // 让 Filter 处理这个clazz能否被加载 if (mFilter != null &amp;&amp; clazz != null) &#123; boolean allowed = mFilter.onLoadClass(clazz); if (!allowed) &#123; // 如果不允许加载 则failNotAllowed会抛出异常！ failNotAllowed(name, prefix, attrs); &#125; &#125; // 反射获取构造方法 并存入缓存 constructor = clazz.getConstructor(mConstructorSignature); constructor.setAccessible(true); sConstructorMap.put(name, constructor); &#125; else &#123; // 如果有缓存 就走filter流程，并把结果存入缓存（非静态） // If we have a filter, apply it to cached constructor if (mFilter != null) &#123; // Have we seen this name before? Boolean allowedState = mFilterMap.get(name); if (allowedState == null) &#123; // New class -- remember whether it is allowed clazz = mContext.getClassLoader().loadClass( prefix != null ? (prefix + name) : name).asSubclass(View.class); // 获取allowed 并存入 缓存 boolean allowed = clazz != null &amp;&amp; mFilter.onLoadClass(clazz); mFilterMap.put(name, allowed); if (!allowed) &#123; failNotAllowed(name, prefix, attrs); &#125; &#125; else if (allowedState.equals(Boolean.FALSE)) &#123; failNotAllowed(name, prefix, attrs); &#125; &#125; &#125; // mConstructorArgs存放了context 跟 args Object[] args = mConstructorArgs; args[1] = attrs; // 终于看到view实例化的地方了！！ final View view = constructor.newInstance(args); // 如果是ViewStub 则设置LayoutInflater给它用 if (view instanceof ViewStub) &#123; // Use the same context when inflating ViewStub later. final ViewStub viewStub = (ViewStub) view; viewStub.setLayoutInflater(cloneInContext((Context) args[0])); &#125; return view; &#125; catch (NoSuchMethodException e) &#123; InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (prefix != null ? (prefix + name) : name)); ie.initCause(e); throw ie; &#125; catch (ClassCastException e) &#123; // If loaded class is not a View subclass InflateException ie = new InflateException(attrs.getPositionDescription() + ": Class is not a View " + (prefix != null ? (prefix + name) : name)); ie.initCause(e); throw ie; &#125; catch (ClassNotFoundException e) &#123; // If loadClass fails, we should propagate the exception. throw e; &#125; catch (Exception e) &#123; InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (clazz == null ? "&lt;unknown&gt;" : clazz.getName())); ie.initCause(e); throw ie; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;&#125; 调来调去，终于到真正实例化View的地方了。 看到这方法的 clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class) 步骤会把系统自带的View的路径拼起来，把类加载进来； 然后clazz.getConstructor(mConstructorSignature);获取View的构造方法，最终通过反射constructor.newInstance(args);实例化View。 如果你足够机智，你会发现这里出来一个问题，WebView 怎么办？ 它的路径可是android.webkit啊~其实这里涉及到 LayoutInflater 的一个子类com.android.internal.policy.PhoneLayoutInflater，它处理了android.widget.、android.webkit.、android.app.这些路径。 事实上，我们最开始使用LayoutInflater.from(cxt)获取的就是PhoneLayoutInflater的实例。 另外这里又涉及到一个Hook入口，即Filter，但是我不知道它的使用场景。 createView方法里解答了我 View是哪里实例化的以及XML中系统View为什么不需要写全路径 这两个疑问。 小结这一篇中分析了如下方法(省去了参数)： inflate：LayoutInflater对外开放的入口，这里分析了 root与attachToRoot 参数的作用。 createViewFromTag：处理主题属性与Factory的Hook onCreateView： 处理系统自带View的路径，android.view.，实际调用的还是createView方法 createView： 真正实例化View的地方，通过View的路径去加载类并获取构造方法，通过反射获取View的实例。 本篇解决了一些疑问： 上述方法中的root、attachToRoot究竟有什么作用？ 影响了merge标签， View是否直接被 add 到 root View 的 LayoutParams 从何而来 inflate 方法的返回值 为什么系统的View我们在Xml里不需要写全路径，而自定义View却需要？ 针对系统 View，会帮忙拼全路径,所以不需要写全 它究竟是在哪里实例化View又是如何实例化 View 的？ 在 createView 方法中，默认利用反射实例化 View 也可通过 Factory hook 的方式实例化 但是还有好多疑问没有解决，也还有部分重要的方法没有解析，所以需要继续探索。 篇幅太长了，所以先小结一下，换一篇继续。 下一篇着重分析merge、include等标签是如何处理的。 已经写好啦：LayoutInflater源码分析（二）之include以及merge标签的处理 推荐阅读一步一步深入理解CoordinatorLayoutViewStub是如何实现懒加载的Space源码分析LayoutInflater源码分析（二）之include以及merge标签的处理]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RTFSC</tag>
        <tag>LayoutInflater</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Context.getSystemService分析]]></title>
    <url>%2Fanalyze-context-getsystemservice%2F</url>
    <content type="text"><![CDATA[引言Context.getSystemService(String) 方法是我们用来获取各种系统服务的手段，比如： 123LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);ActivityManager am = (ActivityManager) cxt.getSystemService(Context.ACTIVITY_SERVICE); BONUS：像这样传入不同的参数(或 String 或 int)，返回不同的对象，通常称为『工厂方法』。 那么问题来了：这些服务是从哪里来的呢？ 在Android应用的程序入口是哪里？一文中我们知道了，我们App的 Context 的实例实际是 ContextImpl的实例，所以需要去它那边研究。 接下去分析。 深入分析看看 ContextImpl 的 getSystemService： 1234@Overridepublic Object getSystemService(String name) &#123; return SystemServiceRegistry.getSystemService(this, name);&#125; 发现调用了 SystemServiceRegistry.getSystemService： 12345// SystemServiceRegistrypublic static Object getSystemService(ContextImpl ctx, String name) &#123; ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null;&#125; SystemServiceRegistry 是什么？ServiceFetcher又是什么？ 当切换到一个新的不熟悉的类的时候，先不要着急，先看看这个类的介绍、结构与方法等，先大致了解一下，再继续深入研究。 SystemServiceRegistry来看看 SystemServiceRegistry 的定义以及我画的类图: 12345/** * Manages all of the system services that can be returned by &#123;@link Context#getSystemService&#125;. * Used by &#123;@link ContextImpl&#125;. */final class SystemServiceRegistry&#123;&#125; 可以清楚的看到，SystemServiceRegistry 是『用来管理所有 ContextImpl.getSystemService 所返回的系统服务』的； ServiceFetcher 则是一个泛型接口。 那么是如何管理的呢？ 系统服务的注册在 SystemServiceRegistry 中有一个static块，代码是这样的： 123456789101112131415161718static&#123; registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class, new CachedServiceFetcher&lt;LayoutInflater&gt;() &#123; @Override public LayoutInflater createService(ContextImpl ctx) &#123; return new PhoneLayoutInflater(ctx.getOuterContext()); &#125;&#125;); registerService(Context.ALARM_SERVICE, AlarmManager.class, new CachedServiceFetcher&lt;AlarmManager&gt;() &#123; @Override public AlarmManager createService(ContextImpl ctx) &#123; IBinder b = ServiceManager.getService(Context.ALARM_SERVICE); IAlarmManager service = IAlarmManager.Stub.asInterface(b); return new AlarmManager(service, ctx); &#125;&#125;); //...&#125; 我挑了两个例子展示，省略了其他的系统服务注册代码，因为实际上，生成系统服务，就这两种方式： 一种是 直接实例化对象，如PhoneLayoutInflater是直接new出来的。 另外一种是从ServiceManager.getService(String)获取的。 PS：ServiceManager 涉及到了 ServiceManagerNative、Binder、Binder 驱动等相关知识，非常复杂，这里不展开去研究，以后会有机会讲。 原来是在 static 代码块里注册了所有的系统服务。 系统服务的缓存实现像这种系统服务一般都是大对象，单例，不可能每次获取都是去新建。 所以当然会有缓存啦。 这个缓存在 ContextImpl 中 1final Object[] mServiceCache = SystemServiceRegistry.createServiceCache(); 至于存入缓存的时机，需要看一个 ServiceFetcher 的实现（其他几个原理类似） 123456789101112131415161718192021222324252627// SystemServiceRegistrystatic abstract class CachedServiceFetcher&lt;T&gt; implements ServiceFetcher&lt;T&gt; &#123; private final int mCacheIndex; public CachedServiceFetcher() &#123; mCacheIndex = sServiceCacheSize++; &#125; @Override @SuppressWarnings("unchecked") public final T getService(ContextImpl ctx) &#123; // 获取缓存 final Object[] cache = ctx.mServiceCache; synchronized (cache) &#123; // Fetch or create the service. Object service = cache[mCacheIndex]; // 如果缓存里没有 则调用 createService 去生成。 if (service == null) &#123; service = createService(ctx); cache[mCacheIndex] = service; &#125; return (T)service; &#125; &#125; public abstract T createService(ContextImpl ctx);&#125; ServiceFetcher.getService 被调用的时候会去判断是否有缓存，如果没有再调用 createService 去创建，再放入缓存，很简单的逻辑。 小结我们 Context.getSystemService 获取到的系统服务其实从 SystemServiceRegistry 来，它负责注册以及管理系统服务。 推荐阅读一步一步深入理解CoordinatorLayoutViewStub是如何实现懒加载的LayoutInflater源码分析（一）之inflate深度分析LayoutInflater源码分析（二）之include以及merge标签的处理]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RTFSC</tag>
        <tag>Context</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Space源码分析]]></title>
    <url>%2Fanalyze-space%2F</url>
    <content type="text"><![CDATA[简介public final class Space extends View Space是一个轻量的View，可以在布局中被用来创建间隙,常用于布局优化。 介于可能很多人根本不知道Space的存在！所以稍微提一下它的使用场景，比如以下场景的右侧小三角，就可以使用Space： 在两个三角之间放置一个Space，两三角分别位于它的上下，控制它的高度就能控制三角之间的间隔。 1234567891011121314151617181920212223242526272829303132&lt;RelativeLayout android:layout_width="wrap_content" android:layout_height="match_parent" android:layout_alignParentRight="true" android:layout_marginRight="2dp" &gt; &lt;ImageView android:id="@+id/iv_price_up" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_above="@+id/divider" android:background="@drawable/price_up" android:layout_marginBottom="1dp" /&gt; &lt;Space android:layout_width="wrap_content" android:layout_height="1dp" android:id="@+id/divider" android:layout_centerInParent="true" /&gt; &lt;ImageView android:id="@+id/iv_price_down" android:layout_marginTop="1dp" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_below="@+id/divider" android:background="@drawable/price_down" /&gt;&lt;/RelativeLayout&gt; 构造方法分析看第一个构造方法即可。 12345678910111213141516171819202122// 最终都会调用这个构造方法public Space(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; super(context, attrs, defStyleAttr, defStyleRes); // 如果是VISIBLE 则改为 INVISIBLE if (getVisibility() == VISIBLE) &#123; setVisibility(INVISIBLE); &#125;&#125;public Space(Context context, AttributeSet attrs, int defStyleAttr) &#123; this(context, attrs, defStyleAttr, 0);&#125;public Space(Context context, AttributeSet attrs) &#123; this(context, attrs, 0);&#125;public Space(Context context) &#123; //noinspection NullableProblems this(context, null);&#125; 跟ViewStub类似，Space在构造方法里做了一些操作：当可见性为VISIBLE的时候，把它改为INVISIBLE了。 由于Space方法非常少，接下去直接都分析了。 其余方法分析1234567891011121314151617181920212223242526272829303132333435363738394041/** * Draw nothing. * * @param canvas an unused parameter. */@Overridepublic void draw(Canvas canvas) &#123; //空方法&#125;/** * Compare to: &#123;@link View#getDefaultSize(int, int)&#125; * If mode is AT_MOST, return the child size instead of the parent size * (unless it is too big). */private static int getDefaultSize2(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: //wrap_content 返回更小的值 result = Math.min(size, specSize); break; case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125;@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // getSuggestedMinimumWidth() 根据minWidth以及背景的宽度来返回 setMeasuredDimension( getDefaultSize2(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize2(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; Space跟ViewStub一个套路，draw()都为空方法，然后重写onMeasure，相比ViewStub，Space代码更加比较简单。 另外一般我们使用Space都是会指定宽高，大部分走的是 EXACTLY的流程。 要点 Space 用来做间隙非常有用 Space 默认为不可见（invisible），但是有宽高，会占据空间。 布局文件中设置 VISIBLE 无效。 小结ViewStub跟Space作为Android布局优化的常用手段，有着一些同样的思路值得我们去学习： 不绘制(减少overDraw) 优化或者不参与测量与布局（提高整体布局的渲染速度） 总结来讲，Space 是一个不绘制任何东西，默认为INVISIBLE的 View，可以用来在布局中占空间，作布局优化。 推荐阅读一步一步深入理解CoordinatorLayoutViewStub是如何实现懒加载的Space源码分析LayoutInflater源码分析（一）之inflate深度分析]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RTFSC</tag>
        <tag>Space</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewStub是如何实现懒加载的]]></title>
    <url>%2Fdeep-into-viewstub%2F</url>
    <content type="text"><![CDATA[ViewStub简介public final class ViewStub extends View ViewStub 是一个宽高都为0，不可见的(GONE)，不参与measure与layout(绝大部分情况)，不绘制任何东西，可以用来做懒加载的View,常用于布局优化； PS: 为什么说绝大部分情况不参与测量与布局呢？因为大部分ViewGroup对于GONE的View，都不会让它参与测量与布局流程（自定义的就不一定了，另外可以看一下FrameLayout的源码）。 首先需要说的是，本文涉及到两个角色，一个是 ViewStub本身，另外一个是被用来做懒加载的View，是ViewStub的作用对象，称之为『StubbedView』（本文用此称呼来替代）。 那么 ViewStub 是怎么实现懒加载的呢？ 本文通过ViewStub源码来分析。 ViewStub的简单使用教程ViewStub 的使用非常非常简单，只需要两步~ Step 1. 在XML里配置使用： 12345678&lt;ViewStub android:id="@+id/stub" // 这个id是ViewStub的id android:layout_width="match_parent" android:layout_height="wrap_content" android:layout="@layout/mySubTree" //StubbedView的资源id（跟include一样） android:visibility="gone" android:inflatedId="@+id/subTree" // StubbedView的id /&gt; Step 2. 调用ViewStub的inflate 123ViewStub stub = (ViewStub)findViewById(R.id.stub);View stubbedView = stub.inflate();//后面分析//...初始化StubbedView 非常简单的两步，就能做到View的懒加载，非常方便，其原因是什么呢？ 接下去深入源码分析一下。 构造方法分析首先分析一下构造方法，了解一下它是如何创建的。 12345678910111213141516171819202122232425262728293031public ViewStub(Context context, @LayoutRes int layoutResource) &#123; this(context, null); // StubbedView的资源id mLayoutResource = layoutResource;&#125;public ViewStub(Context context, AttributeSet attrs) &#123; this(context, attrs, 0);&#125;public ViewStub(Context context, AttributeSet attrs, int defStyleAttr) &#123; this(context, attrs, defStyleAttr, 0);&#125;public ViewStub(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; super(context); final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ViewStub, defStyleAttr, defStyleRes); // mInflatedId 存储StubbedView的id mInflatedId = a.getResourceId(R.styleable.ViewStub_inflatedId, NO_ID); // mLayoutResource 为StubbedView的resourceId mLayoutResource = a.getResourceId(R.styleable.ViewStub_layout, 0); // viewStub 自己的id mID = a.getResourceId(R.styleable.ViewStub_id, NO_ID); a.recycle(); // 设置为不可见 setVisibility(GONE); // 不绘制本身 setWillNotDraw(true);&#125; ViewStub在构造方法里不仅仅获取赋值属性，比较关键的是，还 默认将ViewStub自己设置为不可见（跳过onMeasure与onLayout），不绘制。 这里有一个要点：在XML里配置ViewStub的可见性是没有用的。 测量 与 绘制123456789101112131415@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // 写死的宽高为0 setMeasuredDimension(0, 0);&#125;@Overridepublic void draw(Canvas canvas) &#123; //空方法，不draw任何东西&#125;@Overrideprotected void dispatchDraw(Canvas canvas) &#123; //空方法，不draw任何东西&#125; inflate()方法分析之前在简单教程里有提到 inflate方法，它是ViewStub实现懒加载的最为关键的方法，接下去去分析一下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 返回 StubbedViewpublic View inflate() &#123; // 尝试去获取 viewParent 第一次调用的时候不为null，而后则为null final ViewParent viewParent = getParent(); // 当 viewParent 不为null的时候 if (viewParent != null &amp;&amp; viewParent instanceof ViewGroup) &#123; // 我们在xml里配置的layout的资源id 如果id无效，则会报错 if (mLayoutResource != 0) &#123; final ViewGroup parent = (ViewGroup) viewParent; // 实例化 LayoutInflater final LayoutInflater factory; if (mInflater != null) &#123; factory = mInflater; &#125; else &#123; factory = LayoutInflater.from(mContext); &#125; // inflate，StubbedView在这里被实例化 final View view = factory.inflate(mLayoutResource, parent, false); // 可以看到，这里如果我们在XML里写了inflateId，则会设置给StubbedView if (mInflatedId != NO_ID) &#123; view.setId(mInflatedId); &#125; // 注意：这两步步 ViewSutb 找到自己的位置，并从父View中移除了自己 // 这会导致 以后调用inflate的时候 再也获取不到 viewParent了 final int index = parent.indexOfChild(this); parent.removeViewInLayout(this); // 拿出ViewStub的LayoutParamas，不为null 则会赋值给 StubbedView final ViewGroup.LayoutParams layoutParams = getLayoutParams(); // 把 StubbedView 添加到ViewStub的父View里 if (layoutParams != null) &#123; parent.addView(view, index, layoutParams); &#125; else &#123; parent.addView(view, index); &#125; //使用一个弱引用来保存StubbedView mInflatedViewRef = new WeakReference&lt;View&gt;(view); //回调listener if (mInflateListener != null) &#123; mInflateListener.onInflate(this, view); &#125; // 返回 StubbedView return view; &#125; else &#123; // id无效，则throw一个 IllegalArgumentException throw new IllegalArgumentException("ViewStub must have a valid layoutResource"); &#125; &#125; else &#123; // inflate被调用一次后 就没有了ViewParent，就会报这个错 throw new IllegalStateException("ViewStub must have a non-null ViewGroup viewParent"); &#125;&#125; 我在每行代码上都加上了详细的注释，主要的操作就是把StubbedView给Inflate出来，然后把它放到自己的位置，代码非常清晰，非常简单。 总结来说，其实inflate方法是做了一个『偷梁换柱』的操作，把 StubbedView动态的添加到自己原来的位置上，也因此实现了懒加载功能。 这里还需要注意的是 ViewStub 必须要有一个 Parent，即必须要有父视图！（谢谢 JangGwa 的提醒） 另外值得一提的是：ViewStub还重写了View的setVisibility方法，让我们来分析一下： 12345678910111213141516171819public void setVisibility(int visibility) &#123; // mInflatedViewRef 保存了 StubbedView还记得吗？ inflate过后它就不是null了 if (mInflatedViewRef != null) &#123; View view = mInflatedViewRef.get(); // 操作 StubbedView if (view != null) &#123; view.setVisibility(visibility); &#125; else &#123; throw new IllegalStateException("setVisibility called on un-referenced view"); &#125; &#125; else &#123; // 操作ViewStub自己，构造方法里的GONE记得么？ super.setVisibility(visibility); // 如果是 VISIBLE INVISIBLE 则会去调用 inflate方法！！！！ if (visibility == VISIBLE || visibility == INVISIBLE) &#123; inflate();//注意这一行代码 &#125; &#125;&#125; 可以看到setVisibility方法中也可能会调用inflate()方法，所以当我们想让StubbedView被加载进来，而我们不需要StubbedView的实例的时候，可以用setVisibility（View.VISIBLE）。 不过需要注意的是 不要再接着调用inflate方法，因为此时的 ViewStub 已经被移除了！ 要点 使用ViewStub，必须指定layoutResourceId(必须是布局文件) 在XML里配置ViewStub的可见性是没有用的 ViewStub 主要原理藏在inflate()方法中，是它把真正要加载的View给加载了进来 inflate()方法只能调用一次 ViewStub调用inflate()后就不要再用它了（让它功成身退！） 要小心setVisibility方法，因为它可能会调用inflate() 在XML里给ViewStub设置的LayoutParamas(宽高margin等)会传递给StubbedView,所以我们如果要控制StubbedView的LayoutParamas，则需要写在ViewStub里而不是StubbedView！ 期待补充！ 小结源码分析完毕，可以看到，ViewStub的源码还是非常简单的。 总结来说，它为需要被懒加载的View在布局中占了一个坑，当需要加载时把自己占的坑让给了被加载的 View ，从而实现了懒加载。 推荐阅读一步一步深入理解CoordinatorLayoutLayoutInflater源码分析（一）之inflate深度分析LayoutInflater源码分析（二）之include以及merge标签的处理]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RTFSC</tag>
        <tag>ViewStub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retrofit是如何工作的？]]></title>
    <url>%2Fhow-retrofit-works%2F</url>
    <content type="text"><![CDATA[注：本文基于 Retrofit2.0版本，并配合 RxJava 来分析。com.squareup.retrofit2:retrofit:2.0.0com.squareup.retrofit2:converter-gson:2.0.0com.squareup.retrofit2:adapter-rxjava:2.0.0 ​ ​ Retrofit adapts a Java interface to HTTP calls by using annotations on the declared methods to how requests are made. 本文主要通过分析 Retrofit 与 RxJava 的合作流程 来深入理解 Retrofit的工作原理，并且解答自己心中的疑惑。 疑惑 我们调用接口的方法后是怎么发送请求的？这背后发生了什么？ Retrofit 与 OkHttp 是怎么合作的？ Retrofit 中的数据究竟是怎么处理的？它是怎么返回 RxJava.Observable 的？ Retrofit 的基本使用1234567891011121314151617public interface ApiService&#123; @GET("data/Android/"+ GankConfig.PAGE_COUNT+"/&#123;page&#125;") Observable&lt;GankResponse&gt; getAndroid(@Path("page") int page);&#125;// Builder 模式来构建 retrofitRetrofit retrofit = new Retrofit.Builder() .baseUrl(baseUrl) .addConverterFactory(GsonConverterFactory.create(new GsonBuilder().create())) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .client(okHttpClient) .build();// 通过 retrofit.create 方法来生成 service(非四大组件中的 Service)ApiService service = retrofit.create(ApiService.class);// 发起请求 获取数据Observable&lt;GankResponse&gt; observable= service.getAndroid(1);observable.... Retrofit 就这样经过简单的配置后就可以向服务器请求数据了，超级简单。 Retrofit.create 方法分析Retrofit的create方法作为 Retrofit 的入口，当然得第一个分析。 123456789101112131415161718192021222324252627282930313233public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; //验证接口是否合理 Utils.validateServiceInterface(service); //默认 false if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; // 动态代理 return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; // 平台的抽象,指定默认的 CallbackExecutor CallAdapterFactory用， 这里 Android 平台是 Android (Java8 iOS 咱不管) private final Platform platform = Platform.get(); //ApiService 中的方法调用都会走到这里 @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. // 注释已经说明 Object 的方法不管 if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; // java8 的默认方法，Android暂不支持默认方法，所以暂时也不需要管 if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; // 重点了 后面分析 // 为 Method 生成一个 ServiceMethod ServiceMethod serviceMethod = loadServiceMethod(method); // 再包装成 OkHttpCall OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); // 请求 return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;);&#125; 在上面的代码中可以看到，Retrofit 的主要原理是利用了 Java 的动态代理技术，把 ApiService 的方法调用集中到了InvocationHandler.invoke,再构建了ServiceMethod ,OKHttpCall，返回 callAdapter.adapt 的结果。 要弄清楚，还需要分析那最后三行代码。 一步一步来。 ServiceMethod的职责以及 loadServiceMethod分析我认为 ServiceMethod 是接口具体方法的抽象，它主要负责解析它对应的 method 的各种参数（它有各种如 parseHeaders 的方法），比如注解（@Get），入参，另外还负责获取 callAdapter,responseConverter等Retrofit配置，好为后面的okhttp3.Request做好参数准备，它的toRequest为 OkHttp 提供 Request，可以说它承载了后续 Http 请求所需的一切参数。 再分析loadServiceMethod，比较简单。 12345678910111213141516// serviceMethodCache 的定义private final Map&lt;Method, ServiceMethod&gt; serviceMethodCache = new LinkedHashMap&lt;&gt;(); // 获取method对应的 ServiceMethod ServiceMethod loadServiceMethod(Method method) &#123; ServiceMethod result; synchronized (serviceMethodCache) &#123; // 先从缓存去获取 result = serviceMethodCache.get(method); if (result == null) &#123; //缓存中没有 则新建，并存入缓存 result = new ServiceMethod.Builder(this, method).build(); serviceMethodCache.put(method, result); &#125; &#125; return result; &#125; loadServiceMethod方法，负责 为 method 生成一个 ServiceMethod ，并且给 ServiceMethod 做了缓存。 动态代理是有一定的性能损耗的，并且ServiceMethod 的创建伴随着各种注解参数解析，这也是耗时间的，在加上一个 App 调用接口是非常频繁的，如果每次接口请求都需要重新生成那么有浪费资源损害性能的可能，所以这里做了一份缓存来提高效率。 OkHttpCall再接下去往后看OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);，是再为 ServiceMethod 以及 args(参数)生成了一个 OkHttpCall。 从 OkHttpCall 这个名字来看就能猜到，它是对 OkHttp3.Call 的组合包装,事实上，它也确实是。(OkHttpCall中有一个成员okhttp3.Call rawCall)。 callAdapter.adapt流程分析最后return serviceMethod.callAdapter.adapt(okHttpCall) 似乎是走到了最后一步。 如果说前面的都是准备的话，那么到这里就是真的要行动了。 来分析一下，这里涉及到的 callAdapter,是由我们配置 Retrofit 的 addCallAdapterFactory方法中传入的RxJavaCallAdapterFactory.create()生成，实例为RxJavaCallAdapterFactory。 实例的生成大致流程为： ServiceMethod.Bulider.Build() -&gt;ServiceMethod.createCallAdapter() -&gt;retrofit.callAdapter() -&gt;adapterFactories遍历 ​ -&gt;最终到RxJavaCallAdapterFactory.get()#getCallAdapter() ​ -&gt;return return new SimpleCallAdapter(observableType, scheduler); 由于使用了 RxJava ，我们最终得到的 callAdapter 为 SimpleCallAdapter，所以接下去分析SimpleCallAdapter的 adapt 方法： 这里涉及到的 CallOnSubscriber 后面有给出： 1234567891011121314151617 @Override public &lt;R&gt; Observable&lt;R&gt; adapt(Call&lt;R&gt; call) &#123; // 这里的 call 是 OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args) 生成的 okHttpCall Observable&lt;R&gt; observable = Observable.create(new CallOnSubscribe&lt;&gt;(call)) // .flatMap(new Func1&lt;Response&lt;R&gt;, Observable&lt;R&gt;&gt;() &#123; @Override public Observable&lt;R&gt; call(Response&lt;R&gt; response) &#123; if (response.isSuccessful()) &#123; return Observable.just(response.body()); &#125; return Observable.error(new HttpException(response)); &#125; &#125;); if (scheduler != null) &#123; return observable.subscribeOn(scheduler); &#125; return observable; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637static final class CallOnSubscribe&lt;T&gt; implements Observable.OnSubscribe&lt;Response&lt;T&gt;&gt; &#123; private final Call&lt;T&gt; originalCall; CallOnSubscribe(Call&lt;T&gt; originalCall) &#123; this.originalCall = originalCall; &#125; @Override public void call(final Subscriber&lt;? super Response&lt;T&gt;&gt; subscriber) &#123; // Since Call is a one-shot type, clone it for each new subscriber. final Call&lt;T&gt; call = originalCall.clone(); // Attempt to cancel the call if it is still in-flight on unsubscription. // 当我们取消订阅的时候 会取消请求 棒棒哒 subscriber.add(Subscriptions.create(new Action0() &#123; @Override public void call() &#123; call.cancel(); &#125; &#125;)); try &#123; // call 是 OkHttpCall 的实例 Response&lt;T&gt; response = call.execute(); if (!subscriber.isUnsubscribed()) &#123; subscriber.onNext(response); &#125; &#125; catch (Throwable t) &#123; Exceptions.throwIfFatal(t); if (!subscriber.isUnsubscribed()) &#123; subscriber.onError(t); &#125; return; &#125; if (!subscriber.isUnsubscribed()) &#123; subscriber.onCompleted(); &#125; &#125;&#125; SimpleCallAdapter.adapt 很简单，创建一个 Observable获取CallOnSubscribe中的Response 通过 flatMap转成Observable后返回。这里去发送请求获取数据的任务在CallOnSubscribe.call 方法之中。并且最后走到了 okHttpCall.execute 中去了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 // OkHttpCall.execute @Override public Response&lt;T&gt; execute() throws IOException &#123; okhttp3.Call call; synchronized (this) &#123; //同一个请求 不能执行两次 if (executed) throw new IllegalStateException("Already executed."); executed = true; // ...省略 Execption 处理 call = rawCall; if (call == null) &#123; try &#123; // 创建 okhttp3.call call = rawCall = createRawCall(); &#125; catch (IOException | RuntimeException e) &#123; creationFailure = e; throw e; &#125; &#125; &#125; if (canceled) &#123; call.cancel(); &#125; // 请求并解析response 这个 call 是 okhttp3.call 是真交给 OkHttp 去发送请求了 return parseResponse(call.execute()); &#125;// 解析 response Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123; //... 省略一些处理 只显示关键代码 try &#123; T body = serviceMethod.toResponse(catchingBody); return Response.success(body, rawResponse); &#125; catch (RuntimeException e) &#123; catchingBody.throwIfCaught(); throw e; &#125; &#125;// serviceMethod.toResponse T toResponse(ResponseBody body) throws IOException &#123; // 还记得吗？这就是我们配置Retrofit时候的 converter return responseConverter.convert(body); &#125; 经过一连串的处理，最终在 OkHttpCall.execute() 的方法中生成 okhttp3.call 交给 OkHttpClient 去发送请求，再由我们配置的 Converter(本文为GsonConverterFactory) 处理 Response,返回给SimpleCallAdapter处理，返回我们最终所需要的Observable。 流程分析流程图总结总体的流程图整理如下： 解答疑问对于之前的疑问可以作答了。 第一个疑问: 我们调用接口的方法后是怎么发送请求的？这背后发生了什么？Retrofit 使用了动态代理给我们定义的接口设置了代理，当我们调用接口的方法时，Retrofit 会拦截下来，然后经过一系列处理，比如解析方法的注解等，生成了 Call Request 等OKHttp所需的资源，最后交给 OkHttp 去发送请求， 此间经过 callAdapter,convertr 的处理，最后拿到我们所需要的数据。 第二个疑问: Retrofit 与 OkHttp 是怎么合作的？在Retrofit 中，ServiceMethod 承载了一个 Http 请求的所有参数，OkHttpCall 为 okhttp3.call 的组合包装，由它们俩合作，生成用于 OkHttp所需的 Request以及okhttp3.Call，交给 OkHttp 去发送请求。(在本文环境下具体用的是 call.execute()) 可以说 Retrofit 为 OkHttp 再封装了一层，并增添了不少功能以及扩展，减少了开发使用成本。 第三个疑问: Retrofit 中的数据究竟是怎么处理的？它是怎么返回 RxJava.Observable 的？Retrofit 中的数据其实是交给了 callAdapter 以及 converter 去处理，callAdapter 负责把 okHttpCall 转成我们所需的 Observable类型(本文环境),converter负责把服务器返回的数据转成具体的实体类。 小结Retrofit 的源码其实非常好跟也非常好理解，不像看 framework 的代码，跟着跟着就不见了。 另外 Retrofit的代码确实非常漂亮，将设计模式运用的可以说是炉火纯青，非常值得学习。 推荐文章Retrofit分析-漂亮的解耦套路]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RTFSC</tag>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[strings文件中修改部分字体颜色]]></title>
    <url>%2Fstrings%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BF%AE%E6%94%B9%E9%83%A8%E5%88%86%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[在 Android 开发中，通常会吧文本放在 strings.xml 文件中，然后再引用。 有时候，有些需求需要修改文本中的部分字的字体颜色，可以用以下方式修改： 修改原本的strings.xml: 1&lt;string name="hh_no_order"&gt;&lt;![CDATA[sorry，没有任何订单，&lt;font color="#fc2a56"&gt;前往买买买&lt;/font&gt;]]&gt;&lt;/string&gt; 代码中的使用需要配合Html.fromHtml()，如： 1mTvTip.setText(Html.fromHtml(mTips)) 最终效果图为：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Tip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RTFSC]]></title>
    <url>%2FRTFSC%2F</url>
    <content type="text"><![CDATA[# RTFSC Read The Fucking Source CodeRTFSC 初衷&amp;为什么要阅读源码随着做Android开发时间越来越久，看别人的文章博客对自己的收益越来越少，以前看10篇文章，可能9篇对自己有用，后来慢慢减少，8 7 6..1 。 再加上现在国内的风气不好，标题党特别多，质量好的文章太少，在茫茫文章中获取有用信息变得越来越困难。 投入与回报不成比例，所以需要换一种方式去学习。 现在我更推荐看书以及阅读源码。 相对于看文章，看书有利于系统的学习，看源码的好处更是多多。 书也是有好有坏，关于书籍，我有一个记录读书笔记的项目ReadingNotes,记录读书笔记，也有些扩展，对书籍也有一个相对比较客观的评价,或许可以帮到你，这里就不多说了。 阅读源码的好处『所有的知识其实都来自源码』是我最深的感悟。 通过阅读源码，对知识点的掌握不再流于表面，而能够做到知其然以及所以然，极大地提升判断力，不再人云亦云。 阅读源码还能极大的扩大知识面，通常在阅读源码的时候你会发现很多你根本不知道，或者看文章博客根本不会获取得到的知识，经常会遇到各种『彩蛋』。 Android 源码是学习设计模式的最佳途径之一，Android 团队遇到的坑，比我写过的代码还多，Android 源码中到处可见设计模式的影子，阅读它，可以加深对设计模式的理解。 好处绝不止我所说的，自己去体会。 哪里可以看Android源码Android 源码的查看一般有以下几种方式： 在在线网站上查看,如：grepcode,androidxref 获取Android Framework源码查看，clone frameworks_base ，在 Mac 端可以使用 Sublime 配合 CTAG 查看。 使用 AndroidStudio 看 取合适自己的。 阅读源码的姿势源码数量庞大，如果漫无目的地去阅读很容易迷失自己，所以阅读源码要有一定的技巧。 要有目标 由浅入深 比如针对某一个问题去查看源码，eg. invalidate 和 postInvalidate 的关系与区别是什么？这样有目标性的去寻找答案，才不容易迷失。 另外阅读源码不是容易的事情，可以从简单的类开始阅读，培养阅读习惯以及技巧，增加信心，再一层一层深入，不宜在刚开始就非常深入，这样容易打击自信，甚至开始『怀疑猿生』。 资料另外这些资料可能对你有帮助： 大牛们是怎么阅读 Android 系统源码的？ 阅读 ANDROID 源码的一些姿势]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RTFSC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[访问者模式]]></title>
    <url>%2FVisitor%2F</url>
    <content type="text"><![CDATA[设计模式专题系列: 设计模式 访问者模式当你想要为一个对象的组合(组合模式)增加新的能力,且封装并不重要时,就使用访问者模式。 用途: 当采用访问者模式的时候,就会打破组合类的封装。 优点: 允许你对组合结构加入新的操作,而无需改变结构本身。 想要加入新的操作,相对容易。 访问者所进行的操作,其代码是集中在一起的。 缺点: 因为游走的功能牵涉其中,所以对组合结构的改变就更加困难。 感想才两页纸，没有代码很难理解啊。 See alsoVisitor_pattern]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式]]></title>
    <url>%2FPrototype%2F</url>
    <content type="text"><![CDATA[设计模式专题系列: 设计模式 原型模式当创建给定类的实例的过程很昂贵或很复杂时，就使用原型模式（Prototype Pattern）。 原型模式允许你通过复制现有的实例来创建新的实例（在Java中，这通常意味着使用clone（）方法，或者反序列化）。 原型模式的重点在于，客户端的代码在不知道要实例化何种特定类的情况下，可以制造出新的实例。（？不太理解） 用途： 在一个复杂的类层次中，当系统必须从其中的许多类型创建新的对象时，可以考虑原型。 优点： 向客户隐藏制造新实例的复杂性。 提供客户能够产生位置类型对象的选项。 在某些环境下，复制对象比创建对象更有效。 缺点： 对象的复制有时相当复杂。 ## See alsoPrototype_pattern]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[备忘录模式]]></title>
    <url>%2FMemento%2F</url>
    <content type="text"><![CDATA[设计模式专题系列: 设计模式 备忘录模式当你需要让对象返回之前的状态时（例如，你的用户请求“撤销”），就使用备忘录模式。 备忘录的目标： 储存系统关键对象的重要状态。 维护关键对象的封装。 咦，那Activity、Fragment、View的 onSaveInstanceState 不就是备忘录模式吗？ 用途： 备忘录用于存储状态。 优点： 将被储存的状态放在外面，不要和关键对象混在一起，这可以帮助维护内聚。 保持关键对象的数据封装。 提供了容易实现的恢复能力。 缺点： 储存和回复状态的过程可能相当耗时。 在Java系统中，其实可以考虑使用序列化机制储存系统的状态。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中介者模式]]></title>
    <url>%2FMediator%2F</url>
    <content type="text"><![CDATA[设计模式专题系列: 设计模式 中介者模式使用中介者模式来集中相关对象之间复杂的沟通和控制方式。 每个对象都会在自己的状态改变时,告诉中介者 每个对象都会对中介者锁发出的请求作出回应 没有中介者的情况之下,所有的对象都需要认识其他对象,也即对象之间是紧耦合的.当有了中介者后,对象之间不需要认识,只需要跟中介者打交道,这样一来对象之间就被解耦了. 中介者包含了整个系统的控制逻辑. 用途: 中介者常常被用来协调相关的GUI组件 这让我想到了Android中的Activity,在Activity中包含了各种View以及Adapter等对象,Activity也包含了整个系统的控制逻辑,那么我想,Activity就是一个中介者吧! 优点: 通过将对象彼此解耦,可以增加对象的复用性 通过将控制逻辑集中,可以简化系统维护 可以让对象之间所传递的消息变得简单而且大幅减少 缺点: 如果设计不当,中介者本身会变得过于复杂 想想Activity,如果职责一多,两三千行代码,就非常复杂了,缺点也显而易见了]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解释器模式]]></title>
    <url>%2FInterpreter%2F</url>
    <content type="text"><![CDATA[设计模式专题系列: 设计模式 解释器模式使用解释器模式为语言创建解释器. 用途: 当你需要实现一个简单的语言时,使用解释器. 当你有一个简单的语法,而且简单比效率更重要时,使用解释器. 可以处理脚本语言和编程语言. 可以处理脚本语言和编程语言. 优点: 将每一个语法规则表示成一个类,方便于实现语言. 因为语法由许多类表示,所以你可以轻易地改变或扩展此语言. 通过在类结构中加入新的方法,可以在解释的同时增加新的行为,例如打印格式的美化或者进行复杂的程序验证. 缺点: 当语法规则的数目太大时,这个模式可能会变得非常繁杂.在这种情况下,使用解析器/编译器的产生器可能更合适. 小结我觉着吧,跟自己定义一个语法规则类似,对应的不一定要类,可以是行为.比如 隐式跳转什么的]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蝇量模式]]></title>
    <url>%2FFlyweight%2F</url>
    <content type="text"><![CDATA[设计模式专题系列: 设计模式 蝇量模式如果想让某个类的实例能用来提供许多”虚拟实例”,就使用蝇量模式。 用途: 当一个类有许多的实例,而这些实例能被同一个方法控制的时候,我们就可以使用蝇量模式. 优点: 减少运行时对象实例的个数,节省内存. 将许多”虚拟”对象的状态集中管理. 缺点: 蝇量模式的缺点在于,一旦你实现了它,那么单个的逻辑实例无法拥有独立而不同的行为.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[责任链模式]]></title>
    <url>%2FChain-of-Responsibility%2F</url>
    <content type="text"><![CDATA[设计模式专题系列: 设计模式 责任链模式当你想要让一个以上的对象有机会能够处理某个请求的时候,就使用责任链模式. 通过责任链模式,可以为某个请求创建一个对象链.每个对象依序检查此请求,并对其进行处理,或者将它传给链中的下一个对象. 拿Android来说,View的 onTouch 等方法都是使用了责任链模式. 用途: 经常被使用在窗口系统中,处理鼠标和键盘之类的事件(在Android的触摸事件分发) 优点: 将请求的发送者和接受者解耦 可以简化你的对象,因为它不需要知道链的结构 通过改变链内的成员或调动它们的次序,允许你动态地新增或者删除责任 缺点: 并不保证请求一定会被执行,如果没有任何对象处理它的话,它可能会落到链尾端之外(这可以是优点也可以是缺点) 可能不容易观察运行时的特征,有碍于排除错误]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成器模式]]></title>
    <url>%2FBuilder%2F</url>
    <content type="text"><![CDATA[设计模式专题系列: 设计模式 生成器模式使用生成器模式封装一个产品的构造过程，并允许按步骤构造。 在Android中比较常见了,比如 Dialog,,另外在EffectiveJava的笔记中也有提到,就不多说了. 用途: 经常被用来创建组合结构. 优点: 将一个复杂对象的创建过程封装起来. 允许对象通过多个步骤来创建,并且可以改变过程(这和只有一个步骤的工厂模式不同) 向客户隐藏产品内部的表现 产品的实现可以被替换,因为客户只看到一个抽象的接口. 缺点: 与工厂模式相比,采用生成器模式创建对象的客户,需要具备更多的领域知识. See alsoBuilder_Pattern]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桥接模式]]></title>
    <url>%2FBridge%2F</url>
    <content type="text"><![CDATA[设计模式专题系列: 设计模式 桥接模式桥接模式通过 将实现和抽象放在两个不同的类层次中而使它们可以独立改变。 使用桥接模式不只改变你的实现，也改变你的抽象。 上code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** "Implementor" */interface DrawingAPI &#123; public void drawCircle(double x, double y, double radius);&#125;/** "ConcreteImplementor" 1/2 */class DrawingAPI1 implements DrawingAPI &#123; public void drawCircle(double x, double y, double radius) &#123; System.out.printf("API1.circle at %f:%f radius %f\n", x, y, radius); &#125;&#125;/** "ConcreteImplementor" 2/2 */class DrawingAPI2 implements DrawingAPI &#123; public void drawCircle(double x, double y, double radius) &#123; System.out.printf("API2.circle at %f:%f radius %f\n", x, y, radius); &#125;&#125;/** "Abstraction" */abstract class Shape &#123; protected DrawingAPI drawingAPI; protected Shape(DrawingAPI drawingAPI)&#123; this.drawingAPI = drawingAPI; &#125; public abstract void draw(); // low-level public abstract void resizeByPercentage(double pct); // high-level&#125;/** "Refined Abstraction" */class CircleShape extends Shape &#123; private double x, y, radius; public CircleShape(double x, double y, double radius, DrawingAPI drawingAPI) &#123; super(drawingAPI); this.x = x; this.y = y; this.radius = radius; &#125; // low-level i.e. Implementation specific public void draw() &#123; drawingAPI.drawCircle(x, y, radius); &#125; // high-level i.e. Abstraction specific public void resizeByPercentage(double pct) &#123; radius *= (1.0 + pct/100.0); &#125;&#125;/** "Client" */class BridgePattern &#123; public static void main(String[] args) &#123; Shape[] shapes = new Shape[] &#123; new CircleShape(1, 2, 3, new DrawingAPI1()), new CircleShape(5, 7, 11, new DrawingAPI2()) &#125;; for (Shape shape : shapes) &#123; shape.resizeByPercentage(2.5); shape.draw(); &#125; &#125;&#125; 解析：具体实现为 Implemetor,抽象为 Shape,放在不同的层次，抽象拥有实现的引用，具体实现的修改不需要修改抽象 用途: 适合使用在需要跨越多个平台的图形和窗口系统上。 当需要用不同的方式改变接口和实现时，你会发现桥接模式很好用。 优点： 将实现予以解耦，让它和界面之间不再永久绑定。 抽象和实现可以独立扩展，不会影响到对方。 对于『具体的抽象类』所做的改变，不会影响到客户。 缺点： 桥接模式的缺点是增加了复杂度。 See alsoBridge]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板方法模式]]></title>
    <url>%2FTemplate-Method%2F</url>
    <content type="text"><![CDATA[设计模式专题系列: 设计模式 模板方法模式模板方法模式： 在一个方法中定义一个算法的估价，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变方法结构的情况下，重新定义算法的某些步骤。 具体来说： 创建一个算法的模板，这个模板其实就是第一个方法(需要定义为final)。而这个方法将算法定义成一组步骤，其中的任何步骤都可以是抽象的，由子类负责实现。这样可以确保算法结构保持不变，同时由子类提供部分实现。 模板方法模式用来封装算法。 HookBONUS TIME！ hook()(钩子)指那些 『默认不做事的方法』，子类可以视情况决定要不要覆盖它们。 钩子 是 『一种被声明在抽象类中的方法，但只有空的或者默认的实现』。 钩子的存在，可以让子类有能力对算法的不同点就行挂钩。要不要挂钩，由子类自行决定。 其实Hook并不高端，在实际中有很多运用，比如在BaseActivity里配置一些东西的时候，留几个有默认返回值的方法做为某个功能的开关，比如：是否能侧滑返回等。 12345678//...if（canSwipeBack()）&#123; setupSwipeBack();&#125;//...protected boolean canSwipeBack()&#123; return true;&#125; Hook 的用法&amp;目的 Hook可以让子类实现算法中的『可选』部分。 让子类有机会对模板方法中某些即将发生的(或刚刚发生的)步骤做出反应。 钩子也可以让子类有能力为其抽象类做一些决定。 Java中数组的 Arrays.sort([]) 方法就是模板方法。 要点 模板方法定义了算法的步骤，把这些步骤的实现延迟到了子类。 模板方法为我们提供了一种代码复用的重要技巧。 模板方法的抽象类可以定义具体方法、抽象方法和钩子。 抽象方法由子类实现。 钩子是一种方法，它在抽象类中不做事，或者只做默认的事情，子类可以选择要不要去覆盖它。 为了防止子类改变模板方法中的算法，可以将模板方法声明为final 好莱坞原则告诉我们，将决策权放在高层模块中，以便决定如何以及何时调用低层模块。 你将在真实世界代码中看到模板方法模式的许多变体，不要期待它们全都是一眼就可以被你认出的。 策略模式和模板模式都封装算法，一个用组合，一个用继承。 工厂方法是模板方法的一个特殊版本。 小结模板方法更侧重在『模板』二字，它需要做的是定义一个算法的『大纲』，它的子类去实现的是这个『大纲』里的几个步骤，算法的结构维持不变。 模板方法对算法的控制权更大一些，但是由于模板方法使用的是 继承，并且父类中有实现，所以子类会依赖父类中的实现，缺乏了点弹性。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态模式]]></title>
    <url>%2FState%2F</url>
    <content type="text"><![CDATA[设计模式专题系列: 设计模式 状态模式状态模式： 允许对象在内部状态改变时改变它的行为，对象看起来好像修改它的类。 状态模式把每个状态都独立成类，并将动作委托到代表当前状态的对象。 Context需要持有 所有状态的一个实例（弹性的代价），通过不同状态来切换状态对象，把行为委托给当前状态的对象，客户端不知道Context内部的状态，跟策略模式不同，策略模式需要客户端去指定策略，而且一般来讲策略模式就只有一个最佳策略，不会存在多个。 要点 状态模式允许一个对象基于内部状态而拥有不同的行为。 和程序状态机（PSM）不同，状态模式用类代表状态。 Context会将行为委托给当前状态对象。 通过将每个状态封装进一个类，我们把以后需要做的任何状态局部化了。 状态模式和策略模式有相同的类图，但是它们的意图不同。 策略模式通常会用行为或算法来配置Context类。 状态模式允许Context随着状态的改变而改变行为。 状态转换可以由State类或Context类控制。 使用状态模式通常会导致设计中类的数目大量增加。 状态类可以被多个Context实例共享。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2FProxy%2F</url>
    <content type="text"><![CDATA[设计模式专题系列: 设计模式 代理模式 这一章节的内容较多，笔记比较乱，还是看书好些。 代理模式： 为另一个对象提供一个替身或占位符以控制对这个对象的访问。 所谓代理（proxy），就是代表某个真实的对象。 代理要做的就是：控制和管理访问(控制对象访问) why? 是因为Client不知道如何和远程对象沟通。从某方面来看，远程代理控制访问，可以帮忙处理一些细节（比如网络，IPC）。 （Subject可以是接口） 代理最主要的方法： 远程代理（remote proxy），好比『远程对象的本地代表』;远程代理是 一种对象，活在不同的Java虚拟机(JVM)堆中（更一般的说法为，在不同 地址空间运行的远程对象） PS：在Android中的代理，如 Binder，处理不同进程间IPC，就是在不同的地址。 变体代理方法： 远程代理 控制访问远程对象。 虚拟代理控制访问创建开销大的资源（在必要的时候才创建对象，对象创建完了才委托给对象） 保护代理基于权限控制对资源的访问。 本地代表，是一种可以由本地方法调用的对象，其行为会转发到远程对象中。 工作原理示意图： 书中提到了 RMI 技术，它将 客户辅助对象称为stub（桩）,服务器辅助对象称为skeleton（g骨架）。 BONUS： 原语类型（primitive-原来常说的基本类型），传输过程允许的对象类型要注意，自己定义的类的对象需要实现Serializable（Java） 当不需要传输的时候，用transient来修饰变量。 例子让我想起来Android中的 AIDL和Binder，忽然间懂了好多。 保护代理可以在运行时动态地创建一个代理类，实现一个或多个接口，并将方法的调用转发到你所指定的类。因为实际的代理类是在运行时创建的，我们称这个Java技术为：动态代理。大名鼎鼎的 retrofit 用的就是动态代理。 动态代理的UML： 要点 代理模式为另一个对象提供代表，以便控制客户对对象的访问，管理访问的方式有许多种。 远程代理管理客户和远程对象之间的交互。 虚拟代理控制访问实例化对对象方法的访问。 代理模式有许多变体，例如：缓存代理、同步代理、防火墙代理和写入时复制代理。 代理在结构上类似装饰者，但是目的不同。 装饰者模式为对象加上行为，而代理则是控制访问。 Java内置的代理支持，可以根据需要建立动态代理，并将所有调用分配到所选的处理器。 就和其他的包装者（wrapper)一样，代理会造成你的设计中类的数目增加。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2FObserver%2F</url>
    <content type="text"><![CDATA[设计模式专题系列: 设计模式 观察者模式观察者模式：定义了对象之间的一对多依赖，这样依赖，当一个对象改变状态时，它的所有依赖者都会受到通知，并自动更新。 出版者（Subject） + 订阅者（Observer） = 观察者模式 观察者依赖于主题。 观察者模式提供了一种对象设计，让主题和观察者之间松耦合。 观察者与主题之间依赖于接口，主题不需要知道观察者的具体实现 可以动态添加删除观察者，对主题没有任何影响 新增新类型的观察者对主题没有影响，主题的代码不需要修改，而且旧的观察者也不受影响 观察者与主题都可以独立复用，因为是松耦合 只要约定的接口不改变，修改主题或观察者任何一方，都不会影响另一方 比如 EventBus 就是观察者模式。注意： 观察者模式会造成内存泄漏，一定要记得取消订阅 See alsoObserver patternObserver Design Pattern Example]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器模式]]></title>
    <url>%2FIterator%2F</url>
    <content type="text"><![CDATA[设计模式专题系列: 设计模式 迭代器模式迭代器模式(Iterator)： 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。 迭代器模式服务『集合』，为了更好地管理集合。 所谓集合(Collection)就是是，一群对象，可以放在数组、堆栈、列表、散列表等。集合有时候也被称为『聚合』(aggregate)。 迭代器的意义与优势 我们不需要知道一个集合到底是数组还是列表还是什么其他的结构。 把游走的任务放在迭代器上，而不是聚合上。这样简化了聚合的接口和实现，也让责任各得其所。 要点 迭代器允许访问聚合的元素，而不需要暴露它的内部结构。 迭代器将遍历聚合的工作封装进一个对象中。 当使用迭代器的时候，我们依赖聚合提供遍历。 迭代器提供了一个通用的接口，让我们遍历聚合的项，当我们编码使用聚合的项时，就可以使用多台机制。 小结Java中已经存在有 Iterator 了，大部分情况下，我们不需要自己在写。如果要加新的功能，当然还是可以扩展的，比如 ListIterator新增了previous等方法。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2FFactory%2F</url>
    <content type="text"><![CDATA[设计模式专题系列: 设计模式 工厂模式工厂模式分两种模式： 工厂方法 抽象工厂 简单工厂使用new Xxx()创建对象非常脆弱，缺乏弹性，耦合度高。 当具体类需要新增或删除的时候，就必须修改这段代码，非常容易出错，难以维护和更新。 所以需要把创建对象的方法封装起来，用“工厂”来负责创建对象。 定义Factory： 使用： 看起来可能只是把代码挪到了另外一个地方，但是其实有不少好处。 好处 避免代码重复，可复用，也可服务多个对象 降低耦合度，增加弹性 便于维护 NOTE：它跟静态方法的差别是，静态方法不需要实例化，并且它不能通过继承来改变创建方法的行为。 oh，另外，其实简单工厂并不是设计模式。 工厂方法工厂方法模式(FactoryMethod)定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。 工厂方法通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的 ，所以工厂方法是 继承，覆盖方法来实现 通常工厂方法模板是这样的： 12// 返回对象和入参根据实际情况定 abstract Product factoryMethod（String type）; createPizza应该是受保护权限 在父类PizzaStore中定义createPizza抽象方法，让子类去实现。 NOTE：也可以不是抽象方法，提供默认的实现。 好处 将‘实例化’从‘使用’中解耦 易扩展 易维护 更具弹性 抽象工厂抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。 抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道（或关心）实际产出的具体产品是什么。这样一来客户就从具体的产品中被解耦。 抽象工厂跟工厂方法非常相似，但抽象工厂强调的是一组产品，是对组的抽象，需要一个大的接口；工厂方法使用的是类与继承而抽象工厂使用的是组合； 要点 所有的工厂都是用来封装对象的创建。 工厂方法使用继承：把对象的创建委托给子类，将实例化延迟到子类。 抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中。 所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合。 抽象工厂创建相关的对象家族，而不需要依赖它们的具体类。 See alsoFactory method pattern Factory Design Pattern Example]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[外观模式]]></title>
    <url>%2FFacade%2F</url>
    <content type="text"><![CDATA[设计模式专题系列: 设计模式 外观模式(Facade)外观模式： 提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。 或者说：将一个类或数个类的复杂的一切都隐藏在背后，只显露出一个感觉美好的外观。 外观模式创建一个接口简化而统一的类，用来包装子系统中的一个或者多个复杂的类，而暴露给客户端的是非常简单的接口，让 客户端和子系统解耦。 特点 让接口更简单 外观提供简化的接口，但依然可以直接使用子系统的类。 外观可以附加更『聪明的』功能，让子系统更方便。 外观不只是简化了接口，也 将客户从组件的子系统中解耦。 外观和适配器可以包装许多类，但是外观的意图是 简化接口，而适配器的意图是 将接口转换成不同的接口。 要点 需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观。 外观将客户从一个复杂的子系统中解耦。 实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行。 你可以为一个子系统实现一个以上的外观。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰者模式]]></title>
    <url>%2FDecorator%2F</url>
    <content type="text"><![CDATA[设计模式专题系列: 设计模式 装饰者模式装饰者模式： 动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 装饰者模式可以给类 动态地添加功能，而不需要修改已经存在的类，类似一个Wrapper。 装饰者有弹性，非常符合 开闭原则 特点 装饰者和被装饰者对象拥有相同的超类型 你可以用一个或多个装饰者包装一个对象 既然装饰者和被装饰者对象拥有相同的超类型，所以在任何需要原始对象（被包装的）的场合，可以用装饰过的对象替代它 装饰者可以在所委托被装饰者的行为之前或之后加上自己的行为，以达到特定的目的 对象可以在任何时候被装饰，所以可以在运行时动态地不限量地用你喜欢的装饰者来装饰对象 装饰者模式的缺点可能会引入大量的类，导致理解起来并不容易，也可能会使使用者懵逼。 可能会出现以下情况：1D a = new A(new B(new C(new D))); 比较复杂，难以理解。 具体使用Java源码中的I/O就是装饰者模式，各种 XXXStream、Reader 和 Writer。 比如： 1BufferedReader reader = new BufferedReader(new FileReader(new File("C:\\testing.txt"))); See alsoDecorator Design Pattern Example]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复合模式]]></title>
    <url>%2FCompound%2F</url>
    <content type="text"><![CDATA[设计模式专题系列: 设计模式 复合模式复合模式结合两个或以上的模式，组成一个解决方案，解决一再发生的一般性问题。 复合模式在一个解决方案中结合两个或多个模式，已解决一般或重复发生的问题。 MVC就是一个复合模式。（书中把MVC夸得不行不行的-0-~，称它为 复合模式之王！） 多的不说，截一张示意图：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合模式]]></title>
    <url>%2FComposite%2F</url>
    <content type="text"><![CDATA[设计模式专题系列: 设计模式 组合模式组合(Composite)模式：允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。 组合模式比较复杂一些，跟迭代器模式配合威力强大。 树形结构： 带子元素的元素称为 『节点』(node) 没有子元素的元素称为 『叶节点』(leaf) 包含其他组件的组件为『组合对象』，没有包含其他组件的组件为『叶节点对象』 任何一个『节点』和『叶节点』都是一种『组合』。 注意点组合模式让我们能用树型方式创建对象的结构，树里面包含了组合以及个别的对象。使用组合结构，我们能把相同的操作应用在组合和个别对象上。换句话说，在大多数情况下，我们可以忽略对象组合和个别对象之间的差别。 使用组合模式的时候，Component需要包含Leaf和Composite，以致于它们都会包含一些自己不需要的方法，所以可能在不需要的方法里throw UnsupportedOperationExecption 或者 返回nullorfalse。 并且这么做，其实是不符合单一职责原则的，但是这么做能换来『透明性』(transparency): 通过让组件的接口同时包含一些管理子节点和页节点的操作，客户就可以将组合和叶节点一视同仁。也就是说，一个元素究竟是组合还是叶节点，对客户是透明的。 要点 组合模式提供一个结构，可同时包含个别对象和组合对象。 组合模式允许客户对个别对象以及组合对象一视同仁。 组合结构内的任意对象成为组件，组件可以是组合，也可以是叶节点。 实现组合模式时，有许多设计上的折中。你要根据需要平衡透明性和安全性。 小结组合最大的优势是：让客户端更加简单，客户端不需要再操心面对的是组合对象还是叶节点对象，所以不需要写一大堆if语句来保证他们对正确的对象调用了正确的方法。通常，他们只需要对整个结构调用一个方法并执行操作就可以了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2FAdapter%2F</url>
    <content type="text"><![CDATA[设计模式专题系列: 设计模式 适配器模式(Adapter)适配器模式：将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 适配器非常形象的图： 非常形象的模式，就像生活中的手机充电器，电脑的电源适配器一样。 使用场景当想使用一个已经存在的类，但是不匹配需求接口的时候，可以考虑使用适配器模式来适配，如果有需要还可以做 双向适配，来完成适配。 适配器实现Client所需的目标的接口，并包裹一个被适配者的对象，收到方法调用的时候，委托给被适配者，来达到适配的目标。 小结优势 使用对象组合的方式，用修改的接口来包装适配者 被适配者的任何子类也可以搭配适配器使用 个人觉得使用适配器最大的好处是 不需要修改客户端以及被适配者的代码。 缺点 需要实现所有的方法去完成适配，如果目标非常大，那么工作量也比较大。 NOTE：之前提到的都是 对象适配器，另外还有一种叫做 类适配器，不过类适配器需要多重继承去实现(Adapter需要继承Target和Adaptee)，而不是组合的方式去实现。 适配器 装饰者 外观模式的不同：适配器是：将一个接口转成另一个接口装饰者是：不改变接口，但加入新的责任外观模式是：让接口更简单 要点 当需要使用一个现有的类而其接口并不符合你的需要时，就使用适配器。 适配器改变接口以符合客户的期望。 实现一个适配器可能需要一番功夫，也可能不费功夫，视目标接口的大小与复杂度而定。 适配器模式有两种形式：对象适配器和类适配器。类适配器需要用到多重继承。 适配器将一个对象包装起来以改变其接口；装饰者将一个对象包装起来以增加新的行为和责任；而外观将一群对象『包装』起来以简化其接口。 See alsoAdapter patternAdapter Design Pattern Example]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令模式]]></title>
    <url>%2FCommand%2F</url>
    <content type="text"><![CDATA[设计模式专题系列: 设计模式 命令模式命令模式: 将请求封装成对象，这可以让你使用不同的请求、队列，或者日志请求来参数化其他对象。命令模式也可以支持撤销操作。 将请求封装成对象，比如 Runnable 将 发出请求的对象 和 接受与执行这些请求的对象 分隔开来。 一些应用：日程安排、线程池、工作队列等。 感觉Android中的 Handler 相关也可以算是：把命令(Runnable对象) post(r) 到 MessageQueue 里，Looper再取出来处理~，不需要管Runnable里做的到底什么操作，只要调用它的 run() 方法就行了。 Java代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** The Command interface */public interface Command &#123; void execute();&#125;/** The Invoker class */public class Switch &#123; private List&lt;Command&gt; history = new ArrayList&lt;Command&gt;(); public void storeAndExecute(Command cmd) &#123; this.history.add(cmd); // optional cmd.execute(); &#125;&#125;/** The Receiver class */public class Light &#123; public void turnOn() &#123; System.out.println("The light is on"); &#125; public void turnOff() &#123; System.out.println("The light is off"); &#125;&#125;/** The Command for turning on the light - ConcreteCommand #1 */public class FlipUpCommand implements Command &#123; private Light theLight; public FlipUpCommand(Light light) &#123; this.theLight = light; &#125; @Override // Command public void execute() &#123; theLight.turnOn(); &#125;&#125;/** The Command for turning off the light - ConcreteCommand #2 */public class FlipDownCommand implements Command &#123; private Light theLight; public FlipDownCommand(Light light) &#123; this.theLight = light; &#125; @Override // Command public void execute() &#123; theLight.turnOff(); &#125;&#125;/* The test class or client */public class PressSwitch &#123; public static void main(String[] args)&#123; // Check number of arguments if (args.length != 1) &#123; System.err.println("Argument \"ON\" or \"OFF\" is required."); System.exit(-1); &#125; Light lamp = new Light(); Command switchUp = new FlipUpCommand(lamp); Command switchDown = new FlipDownCommand(lamp); Switch mySwitch = new Switch(); switch(args[0]) &#123; case "ON": mySwitch.storeAndExecute(switchUp); break; case "OFF": mySwitch.storeAndExecute(switchDown); break; default: System.err.println("Argument \"ON\" or \"OFF\" is required."); System.exit(-1); &#125; &#125;&#125; 宏命令，可以存储一系列命令，一起执行，达到一个『按钮』实现多个功能的目的。 可以用个List来保存历史命令，来实现撤销功能。 要点 命令模式将发出请求的对象和执行请求的对象解耦 在被解耦的两者之间是通过命令对象进行沟通的。命令对象封装了接受者和一个或一组动作。 调用者通过命令对象的 execute() 发出请求，这会使得接受者的动作被调用。 调用者可以接受命令当做参数，甚至在运行时动态地进行。 命令可以支持撤销，做法是实现一个 undo()方法来回到 execute()被执行前的状态。 宏命令是命令的一种简单的延伸，允许调用多个命令。红方法也可以支持撤销。 实际操作时，很常见使用『聪明』命令对象，也就是直接实现了请求，而不是将工作委托给接受者。 命令也可以用来实现日志和事务系统。 See alsoCommand patternCommand Design Pattern Example]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计原则]]></title>
    <url>%2FDesign-Principles%2F</url>
    <content type="text"><![CDATA[设计模式专题系列: 设计模式 持续更新中 设计原则设计模式中的设计原则 封装变化找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 或者说是：把变化的部分取出来并封装起来，以便以后可以轻易地改动或扩充此部分，而不影响不需要变化的其他部分。 优势： 代码变化引起的不经意后果变少，系统变得更有弹性 针对接口编程针对接口编程，而不是针对实现编程 将行为放在不同的类中，此类专门提供某行为接口的实现。 针对接口编程的真正意思是：针对超类型编程 利用多态，程序可以针对超类型编程，执行时会根据实际状况执行到真正的行为，不会被绑死在超类型的行为上。 针对接口编程具体的做法：变量的声明类型应该是超类型，然后在运行时才确定。 比如： 1Animal animal = new Dog(); 另外有个概念叫 依赖于实现： 行为来自超类的具体实现，或是继承某个接口并由子类自行实现而来。依赖于实现的 缺点：被实现绑的死死的，难于修改行为。 所以不推荐依赖于实现编程。 多用组合，少用继承优势： 弹性大 可以在运行时动态改变行为 松耦合解耦（decouple） 优势： 当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。 松耦合的设计之所以能让我们建立 有弹性的OO系统，能够应对变化，是因为 对象之间的相互依赖降到了最低。 为了交互对象之间的松耦合设计而努力！！ 开放关闭原则类应该 对扩展开放，对修改关闭。 目标： 允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为。 好处: 具有弹性可以应对改变，可以接受新的功能来应对改变的需求。 依赖倒置原则要依赖抽象，不要依赖具体类。 高层以及低层模块都要依赖于抽象。 （A使用B，A就是高层 B就是低层） 指导方针： 变量不可以持有具体类的引用。（使用new就会持有，用工厂避开） 不要让类派生自具体类。（如果不这么做，那就依赖具体类了） 不要覆盖基类中已实现的方法。（说明不是个好基类） 依赖原则教导我们 尽量避免使用具体类，更加注重如何在设计中避免依赖。 最少知识原则(Least Knowledge)只和你的密友谈话 当设计一个系统，不管任何对象，都需要注意它所交互的类有哪些，并注意它和这些类是如何交互的。该原则需要我们在设计中，不要让太多的类耦合在一起，免得修改系统中一部分，会影响到气他部分。 如果许多类之间相互依赖，那么这个系统会变成一个易碎的系统，它需要花许多成本维护，也会因为太复杂而不容易被其他人了解。 指导方针：就任何对象而言，在该对象的方法内，我们只应该调用属于以下范围的方法： 该对象本身 被当做方法的参数而传递进来的对象 此方法所创建或实例化的任何对象 对象的任何组件(成员变量) NOTE：另外有个原则叫 Law of Demeter 跟该原则意思相同，但是该原则的称呼更为恰当。 最少知识原则的缺点：会出现更多的『包装』，可能会导致 复杂度和开发时间的增加，并降低运行时的性能。 好莱坞原则别调用(打电话给)我们，我们会调用(打电话给)你。 好莱坞原则 可以给我们一种防止『依赖腐败』的方法。 当高层组件依赖地层组件，而地层组件又依赖高层组件，而高层组件又依赖边侧组件，而边侧组件又依然低层组件时，依赖腐败就发生了。（好恐怖- -） NOTE：要尽量做到避免环状依赖。 在该原则的指导下，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎么样使用这些低层组件。(换句话说就是，高层对待低层组件的方式是『别调用我们，我们会调用你』) NOTE：当然，并不是绝对的不能调用。 实际应用于：工厂方法，观察者，模板方法等模式 单一职责一个类应该只有一个引起变化的原因 告诉我们：尽量让每个类保持单一责任。 内聚(cohesion)，用来度量一个类或模块紧密地达到单一目的或责任。 当一个模块或一个类被设计成只支持一组相关的功能时，我们说它具有高内聚；反之，当被设计成支持一组不相关的功能时，我们说它具有低内聚。 遵守这个原则容易具有高的凝聚力，更容易维护。 难点：区分责任。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式]]></title>
    <url>%2FStrategy%2F</url>
    <content type="text"><![CDATA[设计模式专题系列: 设计模式 策略模式定义了算法族，分别封装起来，让它们之间可以相互转换，此模式让算法的变化独立于使用算法的客户。 其实就是利用多态的特性，使用面向接口的编程方式来做。 特点： 定义算法族 分别封装 算法可以相互替代 可以动态切换算法 策略模式通常通过定义 一个Interface，再写不同的实现类去实现的。 体现的设计原则： 开闭原则，针对接口编程]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出设计模式]]></title>
    <url>%2Fdesign-patterns%2F</url>
    <content type="text"><![CDATA[前言 于 2016.8.3 更新 今年的目标里有整理设计模式知识点,一直没有整理,最近效率还可以,希望能整理完. 有部分内容(面向对象基础,设计原则)是一年多以前写的,那时候还非常稚嫩,还需慢慢加深理解。 NOTE:主要目的是给自己看,如果你想学设计模式,推荐看书,后面资料有给出. 笔记目录: 面向对象基础-2015 设计原则(旧-2015版) 设计原则(新-2016版) UML 类图知识 策略模式 观察这模式 装饰者模式 工厂模式 单例模式 命令模式 适配器模式 外观模式 模板方法模式 迭代器模式 组合模式 状态模式 代理模式 复合模式 桥接模式 生成器模式 责任链模式 蝇量模式 解释器模式 中介者模式 备忘录模式 原型模式 访问者模式 需要注意的是，从桥接模式开始,&lt;&lt;深入浅出设计模式&gt;&gt;一书对它们的讲解就非常少了（大概每个设计模式就只有两页的篇幅）,需要自己再买其他书看,学习. 另外这些读书笔记我在Github放了一份,跟其他书籍的读书笔记一起做成了一份Gitbook,阅读体验更好一些!—&gt;ReadingNotes 感悟 不需要严格遵照设计模式，可以适当调整以符合需求(模式是死的，人是活的) 保持简单（KISS原则） 设计、重构的时候考虑设计模式 现在不需要，就别做 可能一直都不需要设计模式（helloworld就不要扯什么设计模式了） 过度使用设计模式可能导致代码被过度工程化。应该总是用最简单的解决方案完成工作，并在真正需要模式的地方才使用它。 实际上在开发过程中，自己已经不知不觉使用了不少设计模式，设计模式从实践中来，也特别需要在实践中去体会，不遇到困难，就不能真切深入的理解它。 有句话说的好，『没写过一万行代码，就别提什么设计模式』 设计模式只停止于阅读是远远不够的，还需努力！ 设计模式推荐资料HeadFirst设计模式设计模式：可复用面向对象软件的基础wiki:Design PatternsAndroid源码设计模式解析与实战EffectiveJava]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML类图知识整理]]></title>
    <url>%2Flearn-uml%2F</url>
    <content type="text"><![CDATA[UML类图UML，进阶必备专业技能，看不懂UML就会看不懂那些优秀的资料。 这里简单整理 类之间的关系泛化关系(generalization) 泛化（generalize）: 一条带空心箭头的线表示 实现（realize） : 一条带空心箭头的虚线表示 泛化在Java中表现为继承（extends） ，is-a的关系 实现在Android中表现为implements 接口，或者extends抽象类 依赖关系(dependency)用一条带箭头的虚线表示；箭头的指向为调用关系 简单来说，类A用到了类B，就可以说A依赖于B 依赖关系是一种临时性的偶然性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化 代码中的表现：比如方法的入参，构造方法的参数 关联关系(association)用一条直线表示 它描述不同类的对象之间的结构关系；体现的是两个类、或者类与接口之间语义级别的一种强依赖关系 代码中的表现：关联对象通常是以成员变量的形式实现的 聚合关系（aggregation）一条带空心菱形箭头的直线表示 聚合关系是关联关系的特例，它用于表示实体对象之间的关系，表示整体由部分构成的语义；是has-a的关系； 例如一个部门由多个员工组成； 与组合关系不同的是，整体和部分不是强依赖的，整体与部分之间是可分离的，即使整体不存在了，部分仍然存在； 例如， 部门撤销了，人员不会消失，他们依然存在 组合关系(composition)用一条带实心菱形箭头直线表示 组合关系是一种强依赖的特殊聚合关系，是contains-a的关系，比聚合更强，也称为强聚合，如果整体不存在了，则部分也不存在 注意点 聚合跟组合其实都属于关联 关系强度：组合&gt;聚合&gt;关联&gt;依赖 类的方法与属性类可以拥有多个方法和属性 属性的表达方式：可见性 名称:类型 [ = 缺省值 ]方法的表达方式：可见性 名称(参数列表) [ : 返回类型] 可见性： + public - private # protected ~ package 另外：UML图中的斜体表示抽象 示例 释义：ViewGroup是一个View，也是一个ViewParent，依赖于MotionEvent（在onTouch（MotionEvent）等方法） 释义： 员工与工号相关联，员工聚合成部门，部门组成公司。 部门解散了员工依然存在（所以是聚合），而公司倒闭，部门也就不存在了（所以是组成）。 资料看懂UML类图和时序图UML类图关系 深入浅出UML类图]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android程序猿学Css(中)]]></title>
    <url>%2Flearn-css-2%2F</url>
    <content type="text"><![CDATA[前言上篇Android程序猿学Css(上) 资料]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步一步深入理解CoordinatorLayout]]></title>
    <url>%2F%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CoordinateLayout%2F</url>
    <content type="text"><![CDATA[一步一步深入理解CoordinatorLayoutGoogle推出Design库已经一年了，国内也出过一些文章关于CoordinatorLayout，但是都是教你怎么使用用，或者简单的自定义一些Behavior,并没有一篇文章深入去了解它的原理。 刚好这两天为了实现一个UI效果，看了CoordinatorLayout（后面简称Col）的官方文档以及源码，搞懂了它的原理，于是想着拿出来分享，特在此记录分享如何一步一步深入理解Col，希望可以填补这个空缺。 补充说明： Col等源码基于23.2.1版本 本文侧重在于Col与Behavior之间的交互，侧重于原理，并选择要点进行讲解，所以可能会有一些点被我忽略，不过看完后我相信你对Col会有更深一层的了解。 初步了解学习最好的习惯就是看官方文档，来看看Col的定义以及官网的介绍： 12public class CoordinatorLayoutextends ViewGroup implements NestedScrollingParent 官网介绍: CoordinatorLayout is a super-powered FrameLayout.CoordinatorLayout is intended for two primary use cases: As a top-level application decor or chrome layout As a container for a specific interaction with one or more child views 从定义可以看到Col继承自ViewGroup，并且它被设计成一个top-level的根布局，它本身只是一个ViewGroup，实现了NestedScrollingParent接口，看似非常普通，但是说CoordinatorLayout是Design库最为重要的控件也不为过。 这里额外需要注意的是: 由于Col只实现了NestedScrollingParent，所以当Col嵌套（作为一个子View）的时候会得不到你想要的效果，需要自己写一个Col去实现NestedScrollingChild接口！ 没有实现NestedScrollingChild接口的子View如：ListView，ScrollView在5.0以下版本跟Col是配合不了的需要使用RecyclerView，NestedScrollView才行 why？它super-powered在哪里呢？ Col最为重要的作用是：提供给子View实现各种交互的极大便利直观的表现是我们可以使用Col非常方便地实现很多交互效果,具体效果可以看cheesesquare这个项目。 要知道，在没有Col的日子要实现简单的交互也不是件容易的事，需要通过各种回调/Event，相互回调，相互通知，甚至相互持有引用，复杂而且难以复用，但是现在有了Col，一切都变得方便了~ How？它是怎么做到的呢？说到这里，不得不提到Col的静态内部类—&gt;Behavior接下去来了解一下它,老司机要开车了，快上车~ 拦截一切的BehaviorBehavior是什么，有什么作用？ Interaction behavior plugin for child views of CoordinatorLayout. A Behavior implements one or more interactions that a user can take on a child view. These interactions may include drags, swipes, flings, or any other gestures. 简单说，Behavior可以负责所有的交互甚至测量以及布局。 其实官网资料说得挺含蓄的，官方在Medium有一篇文章，叫:Intercepting everything with CoordinatorLayout Behaviors ，私以为用这个标题来形容Behavior，再合适不过，intercepting-everything！（这篇文章讲得很好也很全面，极力推荐阅读） 拦截一切！！迫不及待进一步了解！！ 深入了解如何实例化指定Behavior 通过构造方法实例,并在代码中设置到LayoutParams里 Xml里指定，比如app:app:layout_behavior=&quot;me.yifeiyuan.demo.HeaderBehavior&quot; 通过DefaultBehavior注解指定，比如`@CoordinatorLayout.DefaultBehavior(AppBarLayout.Behavior.class)` 第一种方式很简单，不多说，这里针对其他两种方式讲解一下，有一些注意点我们需要知道： Xml方式先撇一下Behavior的定义以及其构造方法如下： 123456//定义 V 为泛型，可指定针对哪种类型的Viewpublic static abstract class Behavior&lt;V extends View&gt;//默认的构造方法public Behavior() &#123;&#125;// xml里使用public Behavior(Context context, AttributeSet attrs) &#123;&#125; 当我们在Xml里指定的时候，在LayoutParams的构造方法里会去调用parseBehavior这个方法，parseBehavior关键代码如下(不贴代码不行了，已尽量精简): 12345678910111213static Behavior parseBehavior(Context context, AttributeSet attrs, String name) &#123; //...省略了很多代码，只留下关键的部分 try &#123; //获取构造方法 Map&lt;String, Constructor&lt;Behavior&gt;&gt; constructors = sConstructors.get(); //... // 注意这一行，这里传递了attrs，所以我们必须要有第二个构造方法！！！ return c.newInstance(context, attrs); &#125; catch (Exception e) &#123; //否则会报错 crash throw new RuntimeException("Could not inflate Behavior subclass " + fullName, e); &#125;&#125; 这里我们需要注意的是: 如果要在xml里使用Behavior 那么第二个构造方法必不可少，所以我们自定义Behavior的时候需要注意;另外你在xml定义的属性会传递到第二个构造方法里去，可以获取你在xml里配置的属性，非常方便，可以说考虑还是非常周到的 注解方式第三种通过注解的方式，又是在什么时候，怎么去实例化的呢？ 在Col中的onMeasure中会去调用prepareChildren方法，而prepareChildren方法又调用了一个叫getResolvedLayoutParams的方法如下: 1234567891011121314151617181920212223LayoutParams getResolvedLayoutParams(View child) &#123; final LayoutParams result = (LayoutParams) child.getLayoutParams(); //如果没有解析过 则去解析 if (!result.mBehaviorResolved) &#123; Class&lt;?&gt; childClass = child.getClass(); DefaultBehavior defaultBehavior = null; while (childClass != null &amp;&amp; (defaultBehavior = childClass.getAnnotation(DefaultBehavior.class)) == null) &#123;//如果 有DefaultBehavior这个注解 childClass = childClass.getSuperclass(); &#125; if (defaultBehavior != null) &#123; try &#123; //实例化Behavior并把这个Behavior赋值给result result.setBehavior(defaultBehavior.value().newInstance()); &#125; catch (Exception e) &#123; Log.e(TAG, "Default behavior class " + defaultBehavior.value().getName() + " could not be instantiated. Did you forget a default constructor?", e); &#125; &#125; result.mBehaviorResolved = true;//标记已经解析过 &#125; return result;&#125; 所以注解方式是在onMeasure中通过getResolvedLayoutParams去实例化的。 另外还需要知道的是，Behavior是Col.LayoutParams的成员变量，那么也就是说只有当你的Behavior设置给Col的 直接子View 才会有效果，这点要记住，不然徒劳无功。(Col的子View的子View就不要给它设置Behavior啦，没效果的) 以上需要牢记，不过仅仅知道这些显然是不够的！至少我不会到这里就停~ 接下去继续深入阅读Behavior的源码一探究竟（一言不合就看源码） 在我阅读了Behavior的源码后，我觉得非常有必要先搞清楚几个非常重要的概念。 child与dependency child，the child view associated with this Behavior它是一个View，是该Behavior的关联对象，也即Behavior所要操作的对象 dependency，也是个View，是 child的依赖对象，同时也是Behavior对child进行操作的根据 弄清楚这些个概念后看源码会比较简单了，Behavior除了构造方法外，有23个方法，限于篇幅与精力，我挑选几个最重要的方法来讲解，当然我不会死板的一个一个毫无逻辑地解释过去。 那些不能不懂的方法layoutDependsOn之前提到了child与dependency有着依赖关系，那么问题来了： 这个依赖关系是如何建立的？ 在Behavior类中有个方法： 1public boolean layoutDependsOn(CoordinatorLayout parent, V child, View dependency) 它会被Behavior的LayoutParams的dependsOn方法调用： 1234boolean dependsOn(CoordinatorLayout parent, View child, View dependency) &#123; return dependency == mAnchorDirectChild || (mBehavior != null &amp;&amp; mBehavior.layoutDependsOn(parent, child, dependency)); &#125; 而LayoutParams的dependsOn方法会被Col调用，dependsOn方法就是用来确定依赖关系的。 所以，最简单的确定依赖关系的方法是重写layoutDependsOn方法，并在一定条件下返回true即可确立依赖关系。 那为什么说一定条件呢？ 比如FAB依赖于SnackBar，是因为它在SnackBar出现以及消失的时候需要改变自身的位置，所以FAB的layoutDependsOn方法中对Snackbar.SnackbarLayout返回了true，而没有依赖其他的控件： 12345@Overridepublic boolean layoutDependsOn(CoordinatorLayout parent,FloatingActionButton child, View dependency) &#123; // We're dependent on all SnackbarLayouts (if enabled) return SNACKBAR_BEHAVIOR_ENABLED &amp;&amp; dependency instanceof Snackbar.SnackbarLayout;&#125; 另外需要注意的是：当确定依赖关系后，当dependency被布局（或测量）后child会紧接着被布局（或测量），Col会无视子view的顺序(原因是Col内有个ComparatormLayoutDependencyComparator会按照依赖关系对所有的子View进行排序),这会影响它们的测量以及布局顺序 可以说layoutDependsOn方法是自定义Behavior最为重要的方法 onDependentViewChanged建立起依赖关系之后呢？ 想要做交互，似乎还缺点什么，我想在dependency发生变化的时候改变一下child，我该如何知道这个改变的时机呢？ 其实不需要我们去主动获取去判断，Col跟Behavior已经帮我们做好了这一切，onDependentViewChanged登场。 onDependentViewChanged方法的定义： 123456789/** * Respond to a change in a child's dependent view * This method is called whenever a dependent view changes in size or position outside * of the standard layout flow. A Behavior may use this method to appropriately update * the child view in response. */public boolean onDependentViewChanged(CoordinatorLayout parent, V child, View dependency) &#123; return false;&#125; 简单来说就是，当我们的dependency发生改变的时候，这个方法会调用，而我们在onDependentViewChanged方法里做出相应的改变，就能做出我们想要的交互效果了！ 可能你也注意到了onDependentViewChanged方法是有返回值的 当我们改变了child的size或者position的时候我们需要返回true，差不多可以理解为 当我们的dependency发生了改变，同样的，child也需要发生改变，这个时候我们需要返回true 提一下：onDependentViewChanged方法是在Col的dispatchOnDependentViewChanged里调用的 其他除了以上两个特别重要的方法外，Nested系列方法也非常重要,如onStartNestedScroll和onStopNestedScroll来监听嵌套滚动的开始和结束，不过限于篇幅，想再另外开篇去写，这里就不写了 另外还有onMeasureChild，onLayoutChild这个后面会讲。 为什么Behavior可以拦截一切？我们知道，ViewGroup的测量，布局，事件分发都是需要自己处理的，那么Col究竟给了Behavior什么特权，让它能够让它拦截一切？ 让我们挨个一点一点看下去 onMeasure直接备注在源码里了，不多说啦！~ 12345678910111213141516171819202122232425262728293031@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //之前已经提到过了 解析Behavior，并按依赖顺序重排子View顺序 prepareChildren(); //用于addPreDrawListener，OnPreDrawListener里会调用 dispatchOnDependentViewChanged(false) ensurePreDrawListener(); //... // 计算 padding width height 处理 fitSystemWindow等 //... final int childCount = mDependencySortedChildren.size(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = mDependencySortedChildren.get(i); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); int keylineWidthUsed = 0; //...处理keyline childWidthMeasureSpec等 final Behavior b = lp.getBehavior(); //当behavior的onMeasureChild方法返回true的时候，我们就可以拦截Col默认的measure if (b == null || !b.onMeasureChild(this, child, childWidthMeasureSpec, keylineWidthUsed, childHeightMeasureSpec, 0)) &#123; onMeasureChild(child, childWidthMeasureSpec, keylineWidthUsed, childHeightMeasureSpec, 0); &#125; //... &#125; //... final int width = ViewCompat.resolveSizeAndState(widthUsed, widthMeasureSpec, childState &amp; ViewCompat.MEASURED_STATE_MASK); final int height = ViewCompat.resolveSizeAndState(heightUsed, heightMeasureSpec, childState &lt;&lt; ViewCompat.MEASURED_HEIGHT_STATE_SHIFT); setMeasuredDimension(width, height);&#125; onLayout123456789101112131415@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; final int layoutDirection = ViewCompat.getLayoutDirection(this); //mDependencySortedChildren 在 onMeasure里已经排过序了 final int childCount = mDependencySortedChildren.size(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = mDependencySortedChildren.get(i); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final Behavior behavior = lp.getBehavior(); //可以看到，当behavior.onLayoutChild()返回true的时候，就可以拦截掉Col的默认Layout操作！ if (behavior == null || !behavior.onLayoutChild(this, child, layoutDirection)) &#123; onLayoutChild(child, layoutDirection); &#125; &#125;&#125; 原理其实跟onMeasure方法一样的。 onInterceptTouchEvent &amp; onTouchEvent在处理touch事件中，Col重写了onInterceptTouchEvent和onTouchEvent，另外，它们都调用了Col里定义的一个处理拦截的方法，performIntercept（关键代码都在这方法之中），就看一下它们的实现吧： onInterceptTouchEvent的实现： 1234567891011121314151617181920@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; MotionEvent cancelEvent = null; final int action = MotionEventCompat.getActionMasked(ev); // Make sure we reset in case we had missed a previous important event. if (action == MotionEvent.ACTION_DOWN) &#123; //down的时候，跟大部分ViewGroup一样，需要重置一些状态以及变量，比如 mBehaviorTouchView resetTouchBehaviors(); &#125; //这里看performIntercept TYPE_ON_INTERCEPT标记是 onInterceptTouchEvent final boolean intercepted = performIntercept(ev, TYPE_ON_INTERCEPT); if (cancelEvent != null) &#123; cancelEvent.recycle(); &#125; //当事件为UP和Cancel的时候去重置（同down） if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) &#123; resetTouchBehaviors(); &#125; return intercepted;&#125; onTouchEvent的实现： 12345678910111213141516171819202122@Overridepublic boolean onTouchEvent(MotionEvent ev) &#123; boolean handled = false; boolean cancelSuper = false; MotionEvent cancelEvent = null; final int action = MotionEventCompat.getActionMasked(ev); // mBehaviorTouchView不为null（代表之前有behavior处理了down事件） 或者 performIntercept返回true 那么事件就交给mBehaviorTouchView if (mBehaviorTouchView != null || (cancelSuper = performIntercept(ev, TYPE_ON_TOUCH))) &#123; // Safe since performIntercept guarantees that // mBehaviorTouchView != null if it returns true final LayoutParams lp = (LayoutParams) mBehaviorTouchView.getLayoutParams(); final Behavior b = lp.getBehavior(); if (b != null) &#123; // 交给 behavior去处理事件 handled = b.onTouchEvent(this, mBehaviorTouchView, ev); &#125; &#125; // Keep the super implementation correct // 省略调用默认实现 up&amp;cancel的时候重置状态 //... return handled;&#125; 可以看到，其实这两个方法做的事情并不多，其实都交给performIntercept方法去做处理了！ performIntercept的实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// type 标记是intercept还是touchprivate boolean performIntercept(MotionEvent ev, final int type) &#123; boolean intercepted = false; boolean newBlock = false; MotionEvent cancelEvent = null; final int action = MotionEventCompat.getActionMasked(ev); final List&lt;View&gt; topmostChildList = mTempList1; //按Z轴排序 原因很简单 让最上面的View先处理事件 getTopSortedChildren(topmostChildList); // Let topmost child views inspect first final int childCount = topmostChildList.size(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = topmostChildList.get(i); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final Behavior b = lp.getBehavior(); //当前事件已经被某个behavior拦截了（or newBlock），并且事件不为down，那么就发送一个 取消事件 给所有在拦截的behavior之后的behavior if ((intercepted || newBlock) &amp;&amp; action != MotionEvent.ACTION_DOWN) &#123; // Cancel all behaviors beneath the one that intercepted. // If the event is "down" then we don't have anything to cancel yet. if (b != null) &#123; if (cancelEvent == null) &#123; final long now = SystemClock.uptimeMillis(); cancelEvent = MotionEvent.obtain(now, now, MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0); &#125; switch (type) &#123; case TYPE_ON_INTERCEPT: b.onInterceptTouchEvent(this, child, cancelEvent); break; case TYPE_ON_TOUCH: b.onTouchEvent(this, child, cancelEvent); break; &#125; &#125; continue; &#125; // 如果还没有被拦截，那么继续询问每个Behavior 是否要处理该事件 if (!intercepted &amp;&amp; b != null) &#123; switch (type) &#123; case TYPE_ON_INTERCEPT: intercepted = b.onInterceptTouchEvent(this, child, ev); break; case TYPE_ON_TOUCH: intercepted = b.onTouchEvent(this, child, ev); break; &#125; //如果有behavior处理了当前的事件，那么把它赋值给mBehaviorTouchView,它其实跟ViewGroup源码中的mFirstTouchTarget作用是一样的 if (intercepted) &#123; mBehaviorTouchView = child; &#125; &#125; // Don't keep going if we're not allowing interaction below this. // Setting newBlock will make sure we cancel the rest of the behaviors. // 是否拦截一切在它之后的交互 好暴力-0- final boolean wasBlocking = lp.didBlockInteraction(); final boolean isBlocking = lp.isBlockingInteractionBelow(this, child); newBlock = isBlocking &amp;&amp; !wasBlocking; if (isBlocking &amp;&amp; !newBlock) &#123; // Stop here since we don't have anything more to cancel - we already did // when the behavior first started blocking things below this point. break; &#125; &#125; topmostChildList.clear(); return intercepted;&#125; 通过分析源码，可以知道，Col在关键的方法里把处理权优先交给了Behavior，所以才让Behavior拥有了拦截一切的能力，所以，原来是Col放任了Behavior！！~ 结语Col以及Behavior的重要的几个环节分析完毕，相信大家看完后能够对它们有更深层次的了解，而不是仅仅停留在使用上面。 这篇文章断断续续写了快一个月，思路断断续续，也有几次推翻重来，原本也打算想讲得更多更细一些，只是限于篇幅与精力，最终的效果跟我最初的预期有所差距，可能也有些错误或者讲解不清晰的地方。 如果你发现任何错误，或者写得不好的地方，或者不理解的地方，非常欢迎批评指正，也非常欢迎吐槽！！！！ 其实我还顺带看了AppBarLayout等的源码，如有可能，我还想把Design库下的所有控件都分析一遍。 感谢你的阅读。 资料Intercepting everything with CoordinatorLayout Behaviors CoordinatorLayout.Behavior http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0224/3991.html 推荐阅读ViewStub是如何实现懒加载的Space源码分析LayoutInflater源码分析（一）之inflate深度分析]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RTFSC</tag>
        <tag>CoordinatorLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客收到第一次打赏的喜与悲]]></title>
    <url>%2F%E5%8D%9A%E5%AE%A2%E6%94%B6%E5%88%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%93%E8%B5%8F%2F</url>
    <content type="text"><![CDATA[前言今天微信突然收到一个 面对面收钱的到账通知 , 楞了一下,谁给我转的钱?仔细一看,显示的名字是 Major,在我的记忆中,我并没有这么一个好友. 我一搜,确实不是我的好友. 刚开始还没反应过来,后来仔细一想,好像我在我的博客开放着我的微信二维码,那他应该是我的读者,这应该是对我博客的一份支持了! 非常激动,非常感激,想加他微信亲自表示感谢,但是搜索不到微信号,很是可惜. 后面是废话和牢骚,不看也罢 也因此,回想起自己写博客的经历,两年前开始写博客,一路以来自己 坚持原创,坚持授人以鱼 不如授人以渔,写博客这么久以来,写了约100篇左右,在博客上从来没有收到过打赏支持(说心里话,其实内心是比较失望的,那时候博客的图片放在七牛,连服务费都付不起呢,oh,现在依然如此). 因为自己深知写博客写文章的不易,写一篇文章通常比自己学习知识花费的时间更多. 特别是随着时间的增长,随着自己能力的提升,担当更多更重的任务,同时也发现自己更多的不足,要不断地去学习更多的知识,(比如什么OkHttp,RxJava,Retrofit,Glide,Dagger2,RN等等等等),被更多的知识Push着,以至于停下脚步来写维护博客的时间越来越少. 以前写一篇文章我还同步到简书,慕课网等,还在各个平台分享出去,还去发微博at一大堆大V,甚至还开通了微信公众账号希望分享给更多的朋友,而现在,即使写了,都懒得去折腾这些了. 以前开的坑 比如 群英传,艺术探索,EJ,设计模式等系列也都因为时间与精力的关系更新缓慢,再比如最近定的一篇&lt;&lt;一步一步深入理解CoordinatorLayout&gt;&gt;(看了3天源码准备总结的),断断续续写了两个礼拜了,才写了1600字,估计才完成一半,但是始终没有将它完结,分享到博客来! 再加上写博客其实是一件十分吃力不讨好的事,花费极大的精力,可能换来的是几十或者一两百的PV,甚至被那些恶心的傻逼网站全文爬走,连个出处都不给你,再加上我自己的拖拉,很多文章以及系列都只存在我的脑海蓝图中,有的甚至还没提笔就已胎死腹中. 所以,我想,可能没有人比我更懂坚持写原创博客的艰辛了. 所以,我特别佩服那些在百忙之中还能写出精彩文章的作者. 而对于优秀的文章,我向来是非常支持的,我本人经常会打赏那些好的文章,特别是在简书上,我打赏出去的钱是我收进来的几十倍! 并且在国内现在这个环境下,鸡汤文,垃圾文遍地,各种抄袭,爬文章各种猖狂,我总怕,坚持写优秀博客的人越来越少,我能支持就支持一下. 另外,在别人支持我的时候,我总是非常感激,非常非常感激那些给予我支持的人,你们每个人的每一份打赏,我都会在这里记录 ,虽然写文章并不是为了钱,但是不可否认的是,这是其中一个动力来源. 如果可以,我希望我的读者,屏幕前的你,能够与我多一些互动,多给我一些建议,如果我写得烂,请喷我,如果写得好,可以支持我一下 我会非常感激,如果你能这么做的话! 我依然会坚持写博客 希望你依然会光顾 希望你会喜欢 但行好事 莫问前程 就这样 祝好 安]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android程序猿学Css(上)]]></title>
    <url>%2Flearn-css%2F</url>
    <content type="text"><![CDATA[前言前面学习了Html,现在接下去学习一下Css. CSS全称为“层叠样式表 (Cascading Style Sheets)”，它主要是用于定义HTML内容在浏览器内的显示样式，如文字大小、颜色、字体加粗等。 我觉得可以把CSS理解为Android的Style&amp;Theme css 样式由选择符和声明组成，而声明又由属性和值组成,如下: 选择符：又称选择器，指明网页中要应用样式规则的元素 例子如下: 12345p&#123; font-size:12px; color:red; font-weight:bold;&#125; 意思是修改&lt;p&gt;标签的相关属性. CSS中的注释:/*注释语句*/ 跟Java一样HTML中的注释:&lt;!--注释语句--&gt; 跟Xml一样 CSS的写法 内联式:直接写在标签里,感觉直观方便,但是不容易统一维护,不方便管理. 1&lt;p style="color:red"&gt;这里文字是红色。&lt;/p&gt; 嵌入式css样式: 在&lt;style&gt;标签里定义,嵌入在head里1234567&lt;head&gt;&lt;style type="text/css"&gt;span&#123;color:red;&#125;&lt;/style&gt;&lt;head&gt; 外部式css样式(也可称为外联式)): 1&lt;link href="base.css" rel="stylesheet" type="text/css" /&gt; 注意： css样式文件名称以有意义的英文字母命名，如 main.css。 rel=”stylesheet” type=”text/css” 是固定写法不可修改。 标签位置一般写在标签之内。 感觉像是include和import一样,将独立的CSS文件引入进来,可以解耦,方便维护~~我想,用得更多的是这一种方式吧. 三种方式的优先级内联式 &gt; 嵌入式 &gt; 外部式 跟在Android中Xml给某个View定义属性一样,在里的属性总是优先于外部的Style跟Theme的,很好理解 选择器 标签选择器,选择器是标签名字 1p&#123;&#125; 类选择器作用于Class,语法(前面有.): 1.类选器名称&#123;css样式代码;&#125; 比如:1234.stress&#123; color:red;&#125;&lt;span class="stress"&gt;胆小如鼠&lt;/span&gt; .stress就是个类选择器 ID选择器作用于id,语法(前面是#): 1#setGreen&#123;color:green;&#125; 例子同类选择器. 类选择器和ID选择器的异同 相同点：可以应用于任何元素不同点： ID选择器只能在文档中使用一次。与类选择器不同，在一个HTML文档中，ID选择器只能使用一次，而且仅一次。而类选择器可以使用多次。 可以使用类选择器词列表方法为一个元素同时设置多个样式。 子选择器即大于符号(&gt;),用于选择指定标签元素的 第一代子元素. 1.food&gt;li&#123;border:1px solid red;&#125; //居然没有分号? 通用选择器通用选择器是功能最强大的选择器，它使用一个 （*）号指定，它的作用是 匹配html中所有标签元素 如下使用下面代码使用html中任意标签元素字体颜色全部设置为红色： 1* &#123;color:red;&#125; 伪类选择符更有趣的是伪类选择符，为什么叫做伪类选择符，它允许给html不存在的标签（标签的某种状态）设置样式，比如说我们给html中一个标签元素的鼠标滑过的状态来设置字体颜色： 1a:hover&#123;color:red;&#125; CSS属性 属性 单位 意义 font-size px 字体大小 color red or #rgb 字体颜色 font-weight bold(加粗) 字体 border px 边框 solid red or#rgb 填充色 //to do 估计也有很多很多其他属性吧,以后知道了再补充 小结按照Android的相关知识去理解,发现CSS也挺简单的,很容易理解嘛~当然,入门总是简单的… 资料http://www.imooc.com/learn/9]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html入门学习]]></title>
    <url>%2Flearn-html%2F</url>
    <content type="text"><![CDATA[前言前几天玩了React Native,(文章),发现如果想真的学好的话,还需要学习一下Html,Css,JavaScript,Node,ES6什么的,感觉东西好多好多一样一样来吧,从Html开始涉猎吧! Html基础Html似乎都是标签,数量有不少,但是估计常用的就那么些个,比如img,a什么的,所以打算粗略的都过一遍,了解了解,不打算深究 因为不知道怎么去学,也没有买书看,所以暂时在慕课网上挑了个基础课程学习,有空闲时间的时候看看,发现还不错!!~~ 暂时记录一点笔记吧!毕竟还在写Android,容易忘记,还是笔记靠谱!~~ 固定结构:12345678910&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;Html&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello Html!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; &lt;html&gt;为根标签 &lt;head&gt;标签用于定义文档的头部，它是所有头部元素的容器。头部元素有 &lt;title&gt;、&lt;script&gt;、&lt;style&gt;、&lt;link&gt;、 &lt;meta&gt; 等标签。 在&lt;body&gt;和&lt;/body&gt;标签之间的内容是网页的主要内容,在这里的标签中的内容会在浏览器中显示出来。 html,yml都跟xml差不多一样的语法格式,看起来也不难,恩,这是好事!~~ 希望自己能触类旁通!~ 基本标签PS:这主题的表格丑的不能看啊!排版都乱套了~ 标签名 作用 更多属性 样例 备注 &lt;h1&gt;&lt;/h1&gt; 标题 h2-6 h1最大 &lt;p&gt;&lt;/p&gt; 段落 &lt;img src=“imageUrl”&gt; 显示图片 width=”200” height=”200”,alt=&quot;失败后显示的文本&quot;;title=&quot;鼠标hover显示的文本&quot; &lt;a&gt;&lt;/a&gt; 链接 href指定链接;title属性,当鼠标hover的时候显示的文字;target=&quot;_blank&quot;表示连接在新的网页打开;mailto发送邮件 &lt;a href=&quot;http://yifeiyuan.me&quot;&gt;点我跳转到我的博客&lt;/a&gt; &lt;em&gt;斜体效果&lt;/em&gt; &lt;strong&gt;加粗效果&lt;/strong&gt; &lt;span&gt;&lt;/span&gt; 标签是没有语义的，它的作用就是为了设置单独的样式用的。 &lt;q&gt;引用的文本&lt;/q&gt; 表示对文本的引用(少量) 会自动加上双引号,不需要自己再加了! &lt;blockquote&gt;引用文本&lt;/blockquote&gt; 表示对文本的引用,不过是大量的文本 浏览器对&lt;blockquote&gt;标签的解析是缩进样式,并且也不需要双引号 &lt;br&gt; 分行/换行 &amp;nbsp; 空格 在Html里直接输入空格/换行是不支持的 &lt;address&gt;地址(默认自动斜体)&lt;/address&gt; 地址 默认斜体 &lt;code&gt;代码&lt;/code&gt; &lt;pre&gt;语言代码段&lt;/pre&gt; 大段代码 预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符 &lt;ul&gt;&lt;li&gt;无序列表信息item&lt;/li&gt;&lt;/ul&gt; 无序列表 &lt;ol&gt;&lt;li&gt;有序列表信息item&lt;/li&gt;&lt;/ol&gt; 有序列表,从1开始 table、tbody、tr、th、td 表格 summary 摘要;caption 标题(显示在表格上方),方便搜索引擎 th表头,tr-行,td列 div似乎在Html中div的作用挺大,就分开记录了,也不知道对不对. 在网页制作过程过中，可以把一些独立的逻辑部分划分出来，放在一个&lt;div&gt;标签中，这个&lt;div&gt;标签的作用就相当于一个容器。 相当于Android中的ViewGroup? 可以给div设置id 表单标签&amp;表单控件12345678&lt;form method="post" action=""&gt; &lt;/form&gt;&lt;form method="post" action="save.php"&gt; &lt;label for="username"&gt;用户名:&lt;/label&gt; &lt;input type="text" name="username" /&gt; &lt;label for="pass"&gt;密码:&lt;/label&gt; &lt;input type="password" name="pass" /&gt;&lt;/form&gt; 属性action ：浏览者输入的数据被传送到的地方,比如一个PHP页面(save.php)属性method ： 数据传送的方式（get/post）。 label,input都是表单控件 下面稍微记录一下,肯定会忘记… label 用于显示文字,差不多相当于TextViewfor: 表示应用给哪个控件,?name: 控件名,跟id一样? input 输入文本框type: 值为submit的时候是提交,当用户需要提交信息给服务器的时候使用;reset为重置;text时是文本;password是密码;radio单选;checkbox复选框;value: 可以用作默认值 textarea:文本域，支持多行文本输入,支持配置行列cols=”10”,rows=”10” select:下拉列表框option可以表示一个选项,如&lt;option value=&quot;看书&quot; selected=&quot;selected&quot;&gt;看书&lt;/option&gt; selected属性表示默认选中select的multiple属性,multiple=&quot;multiple&quot;可以支持多选 标签的一些属性class属性,可以为一个标签设置多个class属性,中间用空格隔开,比如class=&quot;people knight&quot;,可以理解为接口,一个标签可以实现多个接口(class),拥有不同接口(class)的样式. id属性,为一个标签设置一个id属性,同Android,css里的id是唯一的,即不能为不同的标签设置同一个id 例子:1&lt;p class="dev bloger" id="yifeiyuan"&gt;程序亦非猿&lt;/p&gt; 小结&amp;感想html还算是很好理解的嘛!~ 感觉写起来有点麻烦,内容多了估计排版会很乱吧!!! 以后能看得懂Html的代码了 😄~ 有没有发现,我的博客右边的SideBar部分,多了个 打赏支持 的模块,那就是我自己改的,哈哈哈,学以致用的感觉真棒!!!! 资料HTML+CSS基础课程]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章-IPC机制]]></title>
    <url>%2F%E7%AC%AC2%E7%AB%A0-IPC%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[// todo 尚未完成 前言IPC是 Inter-Process Communication的缩写,含义为进程间通信或者跨进程通信是指两个进程之间进行数据交互的过程. 在Android系统中IPC非常非常重要,需要掌握!!! 线程是 CPU调度的最小单元,同时线程是一种有限的系统资源,而进程一般指 一个执行单元,在PC和移动设备上指一个程序或者一个应用. 一个进程可以包含多个线程,一次进程和线程是 包含和被包含的关系 Linux上可以通过 命名管道 共享内容 信号量等进行进程间通信,而在Android中使用Binder 四大组件可以通过android:process属性开启多进程模式(另外一个方式,在JNI里fork一个新进程) adb shell ps可以查看进程信息 每个进程都拥有独立的虚拟机 进程名指定方式有两种:假设包名为me.yifeiyuan.android 一种以:开头,表示在当前的进程名前加上包名,比如指定android:process=&quot;:remote&quot;,那么当前组件的进程名为me.yifeiyuan.android.remote,并且该进程属于当前应用的 私有进程,其他应用的组件不可以和他跑在同一个进程 另一种是完整的方式,如指定为&quot;com.a.b.remote&quot;,那么当前组件的进程名就是com.a.b.remote,其他应用通过sharedUID(每个应用的UID唯一)方式可以和它跑在同一个进程 多进程的问题每个进程都分配 一个独立的虚拟机,不同的虚拟机在内存分配上有不同的地址空间,这就导致 在不同的虚拟机中访问同一个类的对象会产生多份副本.也就是说只要是通过内存来共享数据,都会失败! 静态成员和单例模式完全失效(内存不共享了) 线程同步机制完全失效(同上,锁的不是同一个对象了) SharedPreferences的可靠性下降(SP底层通过读写XML文件来实现的,并发会出问题) Application会多次创建(当一个组件需要运行在新的进程里,系统需要在创建新的进程同时分配独立的虚拟机,也会创建新的Application,这就相当于启动一个应用,)]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android开发艺术探索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些做Android开发必须知道的ADB命令]]></title>
    <url>%2FADB%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[那些必须知道的ADB命令 科普: ADB的全称是Android Debug Bridge 熟练掌握ADB命令可以提高开发效率以下记录一些比较常用的命令: adb start-server启动adb服务,如果它没启动的话 adb kill-server关闭服务 adb devices查看所连接的设备以及设备所对应的序列号 adb install -r xxxx.apk安装app,需要注意的是如果连接了两台设备,则会报错,此时可以添加-s &lt;serialNumber&gt;来处理 adb uninstall packagename卸载app,有时候在手机上卸载App会出现数据清理不干净,导致App再也装不上了,这个时候可以敲命令来卸载 adb shell进入shell环境 adb shell pm clear packagename清除应用的数据,很常用吧? adb shell am start -n packagename/packagename.activityname 启动某个应用的某个Activity(以前调试老年机,那种Launcher上没有APP的机器,全靠它啊!!!!!!!) adb connect &lt;device-ip-address&gt;连接到指定的ip,这个通常配合wifidebug adb shell dumpsys activity top查看栈顶Activity,可以用来获取包名,可以用来查看其它app的包名 adb shell ps查看进程信息 adb shell pm list packages -f查看所有已安装的应用的包名 adb shell dumpsys activitydumpsys系列命令可以帮助我们查看各种信息am的状态 Activity Manager State adb shell dumpsys package包信息 Package Information adb shell dumpsys meminfo内存使用情况Memory Usage adb pull &lt;remote&gt; &lt;local&gt;从手机复制文件出来,比如把Crash日志写在SD卡上,再pull到电脑上 或者 pull ANR的trace日志 adb push &lt;local&gt; &lt;remote&gt;向手机发送文件,比如测试热修复补丁~ eg. adb push foo.txt /sdcard/foo.txt adb shell cat /proc/cpuinfo查看手机CPU,可以看到手机架构(eg.ARMv7) 和几核处理器可以帮助我们选择so库,排查手机cpu架构相关的问题 不太常用的命令 adb shell df获取手机磁盘空间 adb shell getprop ro.build.version.release获取手机系统版本 adb shell dumpsys procstatsMemory Use Over Time adb shell dumpsys gfxinfoGraphics State adb version查看adb版本 adb help进入adb帮助界面 小结其实 am,pm 其实还有很多命令,以后有多的再写吧 资料 adb-官方资料 ADB-Shell adbshell ADB命令大全]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Adb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微博这是要完]]></title>
    <url>%2F%E5%BE%AE%E5%8D%9A%E8%BF%99%E5%82%BB%E9%80%BC%2F</url>
    <content type="text"><![CDATA[前言玩微博有一两年了,老是遇到偷偷摸摸给我关注一些乱七八糟的账号 今天又发现我关注别人了,更可恶的是,tm居然还自动发微博了,还有没有底线了? 360安全浏览器什么鬼? 我用的MAC啊!!!~ iPhone什么鬼? 我用的Android啊!~ 臭不要脸的微博!!! 迟早跟百度一样! 微博这是要完.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初试ReactNative]]></title>
    <url>%2F%E5%88%9D%E8%AF%95ReactNative%2F</url>
    <content type="text"><![CDATA[前言博客写累了，玩玩 ReactNative！~ 环境安装如果没有Homebrew就先安装brew： 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 有的话接下就去安装下面的工具：Node，React Native Command Line Tools，XCode，Watchman，Flow（已有的就不需要了） 1234brew install nodenpm install -g react-native-clibrew install watchmanbrew install flow IDE Nuclide还有IDE需要下载，Nuclide基于Atom（以后Atom不再只是用来写博客了），由于Atom已经安装好了，so，也很简单 1apm install nuclide 安装完后会多出一栏Nuclide： Run Demo所有工具都安装好了，可以跑demo试试了 123react-native init AwesomeProjectcd AwesomeProjectreact-native run-ios 一切成功的话，可以看到下面的效果图： RN作为一个跨平台的语言还是很有吸引力的,跟Kotlin相比,我更愿意去学RN!~ RN以后是趋势,学一点没有坏处!~ 资料ReactNativereact-native-guidereactnative.cn]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1章-Activity的生命周期和启动模式]]></title>
    <url>%2F%E7%AC%AC1%E7%AB%A0-Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Activity的生命周期 正常状态 异常状态(系统杀死/Configuration变化如屏幕旋转) 正常状态 onCreate 表示Activity正在创建,可以做一些初始化操作 onRestart 正在重新启动,onstop后回来会调用 onStart 正在被启动,后台,不可交互 onResume 可见可交互前台,非常重要,许许多多的重要的类在这里初始化 onPause 正在停止 后台(不一定不可见) 不可做太耗时的操作,因为onPause之后新启动Activity的onResume才能被调用 onStop 即将停止,不可见 可以做一些稍微重量级 的回收 onDestroy 即将销毁,可以做一些回收资源,关闭线程,移除Handler消息等操作 生命周期配对去记忆效果更佳:create – destroystart – stopresume – pause 注意点: A 启动 B如果B是透明的Activity,那么A的onStop不会被调用 异常状态Activity的销毁与重建涉及到这两方法: onSaveInstanceState(@Nullable Bundle state) 系统会调用它来保存状态,以便之后恢复 onRestoreInstanceState(@NonNull Bundle state) 为系统恢复所用 当Activity将处于可能被销毁或要被销毁的状态,就会调用onSaveInstanceState而onRestoreInstanceState则是重建的时候被调用 调用时机onSaveInstanceState 在onStop之前调用,而不一定在onPause之后onRestoreInstanceState 在onStart之后,onResume之前 所以,大致的完整的生命周期是这样的:onCreateonRestartonStartonRestoreInstanceStateonResumeonPauseonSaveInstanceStateonStoponDestroy PS:onSaveInstanceState如下情况会调用: 启动了新的Activity 按了Home键等等 另外:可以在onCreate里判断bundle是否为null来判断是新建还是重新创建 关于完整的生命周期,附上一张图,配有fragment的生命周期,可能你在很多地方都看到过,很多人盗用了它,但是并不给出处,这里提一下,它出自android-lifecycle: View 的恢复A系统默认做了一定的恢复,如视图结构,LV的滑动的位置等等(View也有save,restore方法) &gt; PS 看到有的文章说解决Fragment重叠的问题,就是注释掉Activity的onSaveInstanceState方法,简直是误人子弟!!!有机会以后讲 扯远了,保存和恢复View的层次结构,系统的工作流程是这样子的:Activity==&gt;Window==&gt;DecorView==&gt;ContentView==&gt;View一层一层委托保存恢复状态 Activity优先级 前台Activity 正在交互的,onResume状态的Activity 可见但非前台,弹了Dialog,依然可见但是不能交互 后台Activity ,执行onStop之后 Configuration 改变Configuration改变的时候系统默认会重建Activity,如果我不想重建,那么可以选择配置android:configChanges属性,一般常用的就orientation,screenSize,keyboardHidden so,一般给Activity配上这个就行了:android:configChanges=&quot;orientation|screenSize|keyboardHidden&quot; 启动模式Standard标准模式,默认的启动模式,每次启动都会新建一个Activity实例 需要注意的是当使用ApplicationContext去启动Standard模式的Activity的时候会报错,说需要添加NEW_TASK 的标记 为什么呢? 因为Activity启动需要任务栈,而用Standard模式去启动Activity,默认会进入启动它的Activity所属的任务栈中,而非Activity类型的Context并没有所谓的任务栈. AB–启动C-&gt;ABC SingleTop栈顶复用模式,如果新的Activity已位于栈顶,那么不会重新创建Activity,而是回调onNewIntent方法 onNewIntent--&gt;onResume ABC–启动C–&gt; ABC SingleTask栈内复用模式,只要占中存在都不会重新创建,并且也是回调onNewIntent另外需要注意的是,该模式拥有clearTop 的效果,会把位于它顶上的Activity全部出栈(PS:必须同一个栈) 如: ABCDE–启动C(SingleTask)–&gt; ABC SingleInstance单实例模式,栈内单例,一个Activity实例独占一个任务栈,可以说整个手机都只有一个实例 指定启动模式有两种方式: 清单里修改android:launchMode属性 Intent.addFlags() 来指定 Activity的Flags常用的Flags: FLAG_ACTIVITY_NEW_TASK 指定启动模式为singleTask FLAG_ACTIVITY_SINGLE_TOP 指定singleTop启动模式 FLAG_ACTIVITY_CLEAR_TOP 将在它之上的所有Activity移出栈,这个模式一般需要和FLAG_ACTIVITY_NEW_TASK一起出现 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 具有这个标记的Activity不会出现在历史Activity列表中,相当于android:exludeFromRecents=&quot;true&quot; 任务栈TaskAffinity(任务相关性),标识了一个Activity的任务栈名称,默认为应用的包名(万能的包名啊!) 我们可以在清单文件里配置,也可以为每个Activity配置不同的值,但是需要注意的是它不能跟包名相同,并且必须要包含.分隔符! 并且TaskAffinity属性主要和SingleTask或者allowTaskReparenting配对使用,在其他情况下没有意义. TaskAffinity和SingleTask配合: TaskAffinity的值为该模式的任务栈的名字 TaskAffinity和allowTaskReparenting 配合就比较复杂了:当allowTaskReparenting为true时,A应用启动B应用的一个Activity C,然后按Home回到桌面,然后再单击B的桌面图标,这个时候不是启动B的主Activity,而是重新显示被应用A启动的Activity C(原本来说C是A启动的,那么C应该待在A的任务栈里),或者说C从A的任务栈转移到了B的任务栈中(也许这就是re-parenting的含义吧) 补充:allowTaskReparenting需要和FLAG_ACTIVITY_RESET_TASK_IF_NEEDED标记合作才行,而从Home点击图标启动应用的Intent就带有该标记. IntentFilter的匹配规则启动Activity有两种方式:显示调用和隐式调用 显示调用非常简单,明确指定被启动对象的组件信息即可. 而隐式调用需要配合IntentFilter去匹配,一个Activity可以有多个IntentFilter,匹配到了其中一个就能启动,否则启动失败,IntentFilter的过滤信息有action,category,data 当一个Intent同时匹配IntentFilter的action,category,data,才能启动一个Activity action的匹配规则action是个字符串,区分大小写,系统自带一些Action,也可以自定义 规则是:必须要匹配,即Intent的action需要一模一样!有多个action的时候,只需要匹配到一个即可 需要注意的是,Intent必须包含action,否则匹配失败 category的匹配规则category跟action一样,也是个字符串,系统也自带了一些,我们也可以自定义. 它要求Intent中如果含有category,那么所有的category都必须和过滤规则的其中一个相同,即被过滤规则所包含,是它的子集 注意:与action不同的是,它可以不指定category,这是因为startActivity和startActivityForResult会默认给Intent加上android.intent.category.DEFAULT这个categrory,所以如果你的Activity要能够接受隐式调用,就必须在清单文件中为这个Activity的IntentFilter中指定android.intent.category.DEFAULT这个category data的匹配规则data的组成data由两部分组成,mineType和URI mineType指媒体类型,如image/jpeg和video/* URI比较复杂,它的格式:&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;||&lt;pathPrefix&gt;|&lt;pathPattern&gt;] 看例子就简单了,比如:http://yifeiyuan.me:80/about Scheme: 必须 URI的模式,比如http,ftp,如果URI中没有指定scheme,那么整个URI的其他参数无效 Host: 必须 URI的主机名,如果Host没有指定,那么URI无效 Port: URI中的端口号,非必须,仅当URI中指定了scheme和host参数的时候port参数才有意义的. path 表示完整的路径,pathPrefix表示路径前缀,pathPattern表示完整的路径,但是它可以包含通配符 匹配data也是完全匹配,可以在xml里给Activity配置:&lt;data android:mineType=&quot;image/*&quot;&gt;` 启动Activity的时候可以通过intent.setDataAndType()设置 小Tip:隐式启动可能会遇到匹配不到Activity而导致Crash的情况,可以使用`PackageManager`或者`Intent`的`resolveActivity`的方法先判断是否有匹配到的Activity,防止Crash]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android开发艺术探索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第15章-Android性能优化]]></title>
    <url>%2F%E7%AC%AC15%E7%AB%A0-Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言Android性能优化主要包括布局优化、绘制优化、内存泄露优化、响应速度优化、ListView优化、Bitmap优化、线程优化以及一些优化建议. 实际上每个面都可以扩展很多,书中讲的不太多(篇幅少),需要在实际中多去运用. 后面还有MAT的基本使用,我没记,可以去搜,资料不少~ 布局优化 减少布局文件的层级(测量/布局/绘制的时间减少):可以使用RelativeLayout来减少嵌套,从而达到减少层级的目的,另外在相同层级的情况下使用LinearLayout(相比于RelativeLayout更高效) 使用include标签复用,merge标签降低层级,ViewStub来实现懒加载,另外补充一个Space可以用来占位 绘制优化(onDraw)主要是避免执行大量的操作. 不要创建新的局部对象,因为onDraw可能会被频繁调用,会在一瞬间产生大量的临时对象,会导致占用过多内存,系统更加频繁的gc,降低执行效率 不要做耗时的任务 内存泄露优化其实内存泄露有很多种情况,但是书中列举的比较少 静态变量导致的内存泄露(比如静态的context,静态的view) 单例模式持有Activity 属性动画(repeatCount为无限模式) ListView和Bitmap优化ListView使用viewholder模式,Bitmap在12章有讲,这里不重复. 线程优化主要是采用线程池(11章有讲) 避免存在大量的Thread 重用Thread,避免线程创建和销毁所带来的开销 线程池还能控制最大并发数,避免大量线程因互相抢占系统资源从而导致阻塞 其他的一些性能优化建议 避免创建过多的对象 不要过多使用枚举(枚举占用的内存空间要比整型的大) 常量使用 static final来修饰 使用一些Android特有的数据结构,比如SparseArray和Pair等,它们都具有更好的性能(注:减少了自动装箱和拆箱的消耗) 适当使用软引用和弱引用 尽量采用静态内部类(不会持有外部类的实例) 提高可维护性 命名规范 代码排版 给非常关键的代码写注释 代码要有层次性,可扩展 其他的资料推荐10-ways-to-improve-your-android-appAndroid性能优化典范 - 第4季Android性能优化典范 - 第3季Android性能优化典范 - 第2季Android性能优化典范 - 第1季]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android开发艺术探索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步一步教你150行代码实现简书滑动返回效果]]></title>
    <url>%2F%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%99%E4%BD%A0150%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E7%AE%80%E4%B9%A6%E6%BB%91%E5%8A%A8%E8%BF%94%E5%9B%9E%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[前言今天带大家实现简书的滑动返回效果. 先看看效果图: 因为没有具体内容,也没有简书的图片资源,所以稍微简陋了点.但是依然不妨碍我们的效果展示~ OK,接下来惯例,通过阅读本文你能学习到: ViewDragHelper的使用(如果你想学习自定义View,那么ViewDragHelper你绝对不能错过) 好像也没有什么了…. 这个效果,难度不大,会ViewDragHelper的同学应该10分钟就能写出来了吧~如果不会也没关系~ 1. 我们自定义一个SwipeBackFrameLayout继承自FrameLayout1.1 因为看到左边黄色的View是被遮住的,而另外一个View的宽度是MatchParent的,所以FrameLayout是不错的选择.顺便增加一个回调,通知activity去finish1234567public void setCallback(Callback mCallback)&#123; this.mCallback = mCallback;&#125;private Callback mCallback;public interface Callback&#123; void onShouldFinish();&#125; 1.2 Xml布局,非常简单:1234567891011121314151617181920&lt;yifeiyuan.practice.practicedemos.drager.SwipeBackFrameLayoutxmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/swipe_back"android:layout_width="match_parent" android:layout_height="match_parent" tools:context="yifeiyuan.practice.practicedemos.drager.SwipeBackActivity"&gt; &lt;TextView android:layout_width="40dp" android:layout_height="match_parent" android:text="@string/hello_world" android:gravity="center" android:background="#ffff00" /&gt; &lt;View android:layout_width="match_parent" android:layout_height="match_parent" android:background="#ff00ff" /&gt;&lt;/yifeiyuan.practice.practicedemos.drager.SwipeBackFrameLayout&gt; 1.3 实例化一个ViewDragHelper123456789//1f代表灵敏度mDragHelper = ViewDragHelper.create(this, 1f,new ViewDragHelper.Callback() &#123; @Override public boolean tryCaptureView(View child, int pointerId) &#123; return false; &#125;&#125;//因为我们是从左向右滑动 所以设置EDGE_LEFTmDragHelper.setEdgeTrackingEnabled(ViewDragHelper.EDGE_LEFT); 1.4 在SwipeBackFrameLayout里实例化xml里的子View123456789private View mDividerView;private View mContentView;@Overrideprotected void onFinishInflate() &#123; super.onFinishInflate(); mDividerView = getChildAt(0); mDividerView.setAlpha(0f); mContentView = getChildAt(1);&#125; 1.5 让ViewDragHelper处理touch事件 12345678910@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; return mDragHelper.shouldInterceptTouchEvent(ev);&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; mDragHelper.processTouchEvent(event); return true;&#125; 1.6 重写ViewDragHelper的一些处理方法已附上详细注释1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Overridepublic void onEdgeTouched(int edgeFlags, int pointerId) &#123; super.onEdgeTouched(edgeFlags, pointerId); //触摸到左边界的时候 我们capture住mContentView mDragHelper.captureChildView(mContentView, pointerId);&#125; @Override public int getViewHorizontalDragRange(View child) &#123; return 1; &#125;@Overridepublic void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) &#123; super.onViewPositionChanged(changedView, left, top, dx, dy); Log.d(TAG, "onViewPositionChanged() called with left = [" + left + "], top = [" + top + "], dx = [" + dx + "], dy = [" + dy + "]"); //0.0 - 1.0 //Notice 这边可以给个接口回调出去,就可以做各种炫酷的效果了 float alpha = (float) (left*1.0/mDividerWidth); mDividerView.setAlpha(alpha); &#125; @Override public int clampViewPositionHorizontal(View child, int left, int dx) &#123;// Log.d(TAG, "clampViewPositionHorizontal() called with dx = [" + dx + "]"); // 计算left 我们的目标范围是0-dividerwidth的宽度 mLastdx = dx; int newLeft = Math.min(mDividerWidth, Math.max(left,0)); return newLeft;&#125; @Override public void onViewReleased(View releasedChild, float xvel, float yvel) &#123; //&gt;0代表用户想关闭 if (mLastdx&gt;0)&#123; // 还不到关闭条件,我们让view滑动过去,再关闭 if (mDividerWidth != releasedChild.getLeft()) &#123; mDragHelper.settleCapturedViewAt(mDividerWidth,releasedChild.getTop(); invalidate();&#125; else &#123; if (mCallback != null) &#123; mCallback.onShouldFinish(); &#125; &#125; &#125;else&#123; //用户不想关闭 ,则滑动到最左边 if (mDividerWidth != 0) &#123; mDragHelper.settleCapturedViewAt(0, releasedChild.getTop()); invalidate(); &#125;&#125; &#125; @Override public void onViewDragStateChanged(int state) &#123; super.onViewDragStateChanged(state);//滑动停止,并且到达了滑动的判断条件 则回调关闭if(mDragHelper.getViewDragState()==ViewDragHelper.STATE_IDLE&amp;&amp;mCallback != null&amp;&amp;mDividerWidth==mContentView.getLeft()&amp;&amp;mLastdx&gt;0) &#123; mCallback.onShouldFinish(); &#125; &#125; &#125;); 1.7 增加对view滑动事件处理,对于以上mDividerWidth我们在onLayout里获取123456789101112131415private int mDividerWidth;@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); mDividerWidth = mDividerView.getWidth();&#125;//Notice view 刚初始化的时候就会被调用一次 @Override public void computeScroll() &#123; super.computeScroll(); // Log.d(TAG, "computeScroll() called with " + ""); if (mDragHelper.continueSettling(true)) &#123; invalidate(); &#125;&#125; 我们写完自定义view后还需要自定义一下activity的退出动画~ 2.定义activity的finish动画2.1 在anim目录下,创建两个动画xml:123456789101112131415//no_anim&lt;alphaandroid:duration="300" xmlns:android="http://schemas.android.com/apk/res/android" android:fromAlpha="1.0"android:toAlpha="1.0"&gt;&lt;/alpha&gt;//out_to_right&lt;translate xmlns:android="http://schemas.android.com/apk/res/android" android:duration="300" android:fromXDelta="0%" android:toXDelta="100%" &gt;&lt;/translate&gt; 2.2 在activity里设置callback监听,并运用动画1234567mSwipeBack.setCallback(new SwipeBackFrameLayout.Callback() &#123; @Override public void onShouldFinish() &#123; finish(); overridePendingTransition(R.anim.no_anim, R.anim.out_to_right); &#125;&#125;); 好了!!~代码量非常少!~就是这么简单~ 源码在我的Github上 如果你觉得喜欢,举手之劳,给我点个赞吧!~如果有什么不好的,不对的欢迎指出!~如果有什么更好的方式,也欢迎指导!!!! 下次见!~]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android获取本地视频文件的截图]]></title>
    <url>%2FAndroid%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%9C%B0%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E7%9A%84%E6%88%AA%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[前言上次在异步之AsyncTask(一)中我们讲了AsyncTask的基础,这次来再结合新的功能来巩固一下知识点. 阅读本文你需要掌握AsyncTask的基本用法,如果不懂AsyncTask,推荐阅读异步之AsyncTask(一). 通过阅读本文你将能够学到: 如何创建本地视频缩略图 如何AsyncTask使用自带线程池 如何使用回调 如何防止ListView加载多张图片造成位置混乱 如何使用内存/磁盘缓存 由于功能需求要获取本地视频文件的截图,用于显示,而我们所用的图片加载工具为ImageLoader,很不巧,UIL不支持该需求,所以需要我们自己写了.So,动手开始写吧: 1. 获取本地视频截图在尝试过许多方法之后,我最终使用了ThumbnailUtils这个类,使用ThumbnailUtils来获取视频的缩略图比较简单,它有个方法可以用来创建视频的缩略图: 1234567891011/*** Create a video thumbnail for a video. May return null if the video is* corrupt or the format is not supported.** @param filePath the path of video file 文件路径* @param kind could be MINI_KIND or MICRO_KIND 种类,该参数决定了获取到的图片的大小 MINI_KIND:512 x 384 ,MICRO_KIND:96 x 96*/public static Bitmap createVideoThumbnail(String filePath, int kind) ``` 有了这个方法就好办了,我们封装一个方法用于获取: /** * @param videoPath 视频路径 * @param width 图片宽度 * @param height 图片高度 * @param kind eg:MediaStore.Video.Thumbnails.MICRO_KIND MINI_KIND: 512 x 384，MICRO_KIND: 96 x 96 * @return */ private Bitmap getVideoThumbnail(String videoPath, int width, int height,int kind) { // 获取视频的缩略图 Bitmap bitmap = ThumbnailUtils.createVideoThumbnail(videoPath, kind); //extractThumbnail 方法二次处理,以指定的大小提取居中的图片,获取最终我们想要的图片 bitmap = ThumbnailUtils.extractThumbnail(bitmap, width, height, ThumbnailUtils.OPTIONS_RECYCLE_INPUT); return bitmap; }123456789101112## 2.自定义VideoThumbnailLoader方法我们写完了,但是实际运用时候,发现非常的卡,因为**创建bitmap耗时非常严重,达到上百毫秒,按16毫秒1帧算,加载一个缩略图就要卡上好几帧!!卡爆了!!**相信机智的你早已经想到,下一步我们需要把创建缩略图的处理放在异步线程中去.另外我们需要考虑一个问题,我们不停地去加载,会发现,**同一个视频我们加载了好几次缩略图,这个时候怎么办?**这个时候就需要引入缓存了,使用过UIL等图片加载工具的同学应该知道了**一级缓存(内存缓存)**,**二级缓存(文件/磁盘缓存)**这些概念.刚好,我们项目中使用了UIL,所以为了进一步提高加载效率,我顺带加了缓存.写了一个单例VideoThumbnailLoader类,来负责加载.那么问题又来了,我用的单例,那么多图片在加载,我怎么通知界面我加载完成了呢?这个时候回调就派上大用场了,在VideoThumbnailLoader中我增加了一个回调,通过回调方式告诉外部,我加载完成了,你可以显示了: //自己定义一个回调,通知外部图片加载完毕public interface ThumbnailListener{ void onThumbnailLoadCompleted(String url,ImageView iv,Bitmap bitmap);}1234好了,思考完毕,准备完毕,上代码!~最终代码如下: public class VideoThumbnailLoader { private static final String TAG = &quot;VideoThumbnailLoader&quot;; private MemoryCache mMCache;//一级缓存,内存缓存 private static VideoThumbnailLoader ins = new VideoThumbnailLoader(); public static VideoThumbnailLoader getIns(){ return ins; } private VideoThumbnailLoader() { mMCache = ImageLoader.getInstance().getMemoryCache(); } public void display(TLLiveEntity mEntity,String url,ImageView iv,int width,int height,ThumbnailListener thumbnailListener){ new ThumbnailLoadTask(mEntity,url,iv,width,height,thumbnailListener).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);//使用AsyncTask自带的线程池 } private class ThumbnailLoadTask extends AsyncTask&lt;Void, Void, Bitmap&gt; { private String url; private ImageView iv; private ThumbnailListener thumbnailListener; private int width; private int height; public ThumbnailLoadTask(String url,ImageView iv,int width,int height,ThumbnailListener thumbnailListener){ this.url = url; this.iv = iv; this.width = width; this.height = height; this.thumbnailListener = thumbnailListener; } @Override protected Bitmap doInBackground(Void... params) { /** * 注意,由于我们使用了缓存,所以在加载缩略图之前,我们需要去缓存里读取,如果缓存里有,我们则直接获取,如果没有,则去加载.并且加载完成之后记得放入缓存. */ Bitmap bitmap = null; if (!TextUtils.isEmpty(url)) { String key = getMemoryKey(url); bitmap = mMCache.get(key);//先去内存缓存取 if (bitmap == null||bitmap.isRecycled()) { File file = TLFileUtils.getExternalFile(path, &quot;xxx.png&quot;);//创建文件,这里由于项目原因,我就随便写一个,实际情况不是这样,大家留意一下 if (null != file &amp;&amp; file.exists()) {//去磁盘缓存取 bitmap = BitmapFactory.decodeFile(file.getPath()); if (null==bitmap) { bitmap = getVideoThumbnail(url, width, height, MediaStore.Video.Thumbnails.MICRO_KIND); //将图片保存到磁盘文件,作为缓存 BitmapUtils.saveBitmapToFile(file, bitmap,Bitmap.CompressFormat.PNG); } } else { bitmap = getVideoThumbnail(url, width, height, MediaStore.Video.Thumbnails.MICRO_KIND); if (null==bitmap) { bitmap = getVideoThumbnail(url, width, height, MediaStore.Video.Thumbnails.MICRO_KIND); //将图片保存到磁盘文件,作为缓存 BitmapUtils.saveBitmapToFile(file, bitmap,Bitmap.CompressFormat.PNG); } } if (null != bitmap) { mMCache.put(key, bitmap);//存入内存缓存 } } } return bitmap; } @Override protected void onPostExecute(Bitmap bitmap) { super.onPostExecute(bitmap); thumbnailListener.onThumbnailLoadCompleted(url, iv, bitmap);//回调 } } /** * @param videoPath 视频路径 * @param width * @param height * @param kind eg:MediaStore.Video.Thumbnails.MICRO_KIND MINI_KIND: 512 x 384，MICRO_KIND: 96 x 96 * @return */ private Bitmap getVideoThumbnail(String videoPath, int width, int height, int kind) { // 获取视频的缩略图 Bitmap bitmap = ThumbnailUtils.createVideoThumbnail(videoPath, kind); bitmap = ThumbnailUtils.extractThumbnail(bitmap, width, height, ThumbnailUtils.OPTIONS_RECYCLE_INPUT); return bitmap; } /** * imageloader 的内存缓存的 key 以_ 结尾 截取key比较的时候如果没有加_ 会报错崩溃,所以自己自定义 * @param filePath 文件地址 * @return */ private String getMemoryKey(String filePath) { String key ; int index = filePath.lastIndexOf(&quot;/&quot;); key = filePath.substring(index + 1, filePath.length())+&quot;_&quot;; return key; } //自己定义一个回调,通知外部图片加载完毕 public interface ThumbnailListener{ void onThumbnailLoadCompleted(String url,ImageView iv,Bitmap bitmap); }} 123在需要加载的地方使用: mHolder.ivBg.setTag(imgUrl); //这里注意,我们给imageview设置了一个Tag,后面自有妙用VideoThumbnailLoader.getIns().display(entity,url, mHolder.ivBg,mImgWidth,mImgHeight, new VideoThumbnailLoader.ThumbnailListener() { @Override public void onThumbnailLoadCompleted(String url, ImageView iv, Bitmap bitmap) { //通过判断imageview的tag,和我们加载的图片的url是否是同一个来判断是否显示,这样可以避免滑动造成的位置错乱等问题. String tag = (String) iv.getTag(); if (null != bitmap&amp;&amp;null!=tag&amp;&amp;tag.equals(url)) { iv.setImageBitmap(bitmap); }else{ iv.setImageResource(R.mipmap.defaultvideo); } } });` 至此功能已经实现,并且使用了线程池,缓存,效率比一开始提高不少,不过还是有地方可以优化,至于优化,后面有机会再写吧~ 好了,本文结束,如果有疑问,欢迎提问,如果喜欢,欢迎点赞,欢迎关注我,关注我的专题~~ 谢谢,下次见!]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AsyncTask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InstalMaterial学习笔记之Reveal效果]]></title>
    <url>%2FInstalMaterial%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BReveal%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[前言本文记录开源项目 InstalMaterial学习到的Reveal效果国内有对应博客的翻译 先看一下效果图: 惯例,不过这次是我学到了什么 对自定义属性使用属性动画 属性动画,get方法不一定需要 最重要的是ViewTreeObserver.OnPreDrawListener()的使用,另一种过渡动画的实现方式 OK,开始吧 首先仔细看动画效果,其实就是一个半径不断变大的圆 那么来实现这个效果吧 先定义个类RevealView,重载构造方法 增加一个成员变量 radius 表示圆的半径 增加一个Paint变量 mPaint 用来画 如此后代码如下: 1234567891011121314151617181920212223public RevealView(Context context) &#123; super(context); init();&#125;public RevealView(Context context, AttributeSet attrs) &#123; super(context, attrs); init();&#125;public RevealView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init();&#125;private void init() &#123; mPaint=new Paint(); mPaint.setColor(getResources().getColor(R.color.primary_dark)); mPaint.setAntiAlias(true); mPaint.setStyle(Paint.Style.FILL);&#125;private Paint mPaint;private int radius; #####接下来,我们重写onDraw,画个圆 123456@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //原点是中心 canvas.drawCircle(getWidth() / 2, getHeight() / 2, radius, mPaint);&#125; ####接下去就是让radius得值不断发生变化了到这里,可能有同学会想着起个thread不停去赋值,再invalidate.其实不必这么麻烦,我们使用属性动画即可: 12345//这里我计算了斜对角线的长度,这样可以保证画的圆能够保证覆盖整个viewint maxRadius = (int) (Math.sqrt(Math.pow(getHeight(), 2)+ Math.pow(getWidth(), 2)));ObjectAnimator revealAnimator = ObjectAnimator.ofInt(this, "radius", 0,maxRadius).setDuration(300);revealAnimator.setInterpolator(new AccelerateInterpolator());revealAnimator.start(); 到这里熟悉属性动画的同学可能就知道,还差了getter setter方法Tip:其实事实上getter方法不是必须的,少了setter方法也不会崩溃,只是动画没有效果而已注意:12//Notice 这里传入了两个值 如果只传了一个,则会在动画开始时候去调用gettter方法ObjectAnimator.ofInt(this, "radius", 0,maxRadius).setDuration(300); OK,让我们加入setter方法:1234public void setRadius(int radius) &#123; this.radius = radius; Log.d(TAG, "setRadius "+radius);&#125; 恩,OK,问自己一下,这样,就好了吗?答案是,没有!我们还需要对setter方法加工一下123456public void setRadius(int radius) &#123; this.radius = radius; Log.d(TAG, "setRadius "+radius); //Notice 调用invalidate 之后 onDraw才会被调用 invalidate();&#125; 至此,我们运行一下: 初始效果已经出来了,但是你会发现,动画结束后,我们的revealview把其他View都挡住了. 呵呵,这个还不简单吗?动画结束后给gone了不得了嘛? 123456789101112131415161718//新增一个callback 回调动画结束public void setCallback(Callback callback) &#123; this.callback = callback;&#125;private Callback callback;public interface Callback&#123; void onRevealEnd();&#125;//在activity里设置mVReveal.setCallback(new RevealView.Callback() &#123; @Override public void onRevealEnd() &#123;//隐藏 mVReveal.setVisibility(View.GONE);// todo 其他事情 &#125; &#125;); 然后跑起来试试: 还不错吧? ##接下来我们运用到Activity跳转这个时候我们需要用到ViewTreeObserver.OnPreDrawListener() 123456789//在跳转的activity里mVReveal.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() &#123; @Override public boolean onPreDraw() &#123; //必须remove掉 不然会重复调用 mVReveal.getViewTreeObserver().removeOnPreDrawListener(this); mVReveal.startReveal(); return false; &#125;&#125;); //按钮点击事件1Intent intent = new Intent(this, RevealActivity.class);intent.putExtra("location", location);startActivity(intent);overridePendingTransition(0, 0);//Notice 这个绝对不能省..不然没有效果 好了,差不多介绍到这里..不过其实还有其他的优化扩展,1.比如传坐标,指定圆心开始reveal2.reveal结束后继续其他的动画大家自己试试吧:Github. ###最后总结下 InstalMaterial 是一个值得你认真去学习的开源项目. 时间允许的话一定要动手实践,不要觉得看着简单就以为自己会了,其实没你想的那么简单.就像我,看着这个效果很简单,原本觉得不用这么麻烦就可以实现,结果,最后还是一步一步照着frogermcs的代码写了下去,这样才能真正学到东西. 自学不易,请坚持!]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步一步教你实现Periscope点赞效果]]></title>
    <url>%2F%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0Periscope%E7%82%B9%E8%B5%9E%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[前言现在视频应用越来越火,Periscope火起来后,国内也出现了不少跟风者,界面几乎跟Periscope一模一样.Periscope确实不错,点赞的效果也让人眼前一亮,很漂亮,于是乎,我就想着自己实现一下. 最终的效果图如下: 录制的效果不太好,手机运行起来还是挺好看的.不能说一模一样,但是也差不多了吧!~ 惯例:通过本文你将学习到什么? 自定义view的一些基础方法以及一些注意点 随机数的使用 插补器的使用 属性动画的高级用法 贝塞尔曲线在Android中的实现以及应用 OK,如果感兴趣,那么跟着我来看看这个效果是如何实现的吧! ##仔细看看,这个效果中包含了什么细节? 爱心出现在底部并且水平居中 爱心的颜色/类型 随机 爱心进入时候有一个缩放的动画 缩放完毕后,开始变速向上移动,并且伴随alpha渐变效果 爱心移动的轨迹光滑,是个曲线 OK,接下去我们一个一个去实现它 1.第一步,底部,水平居中这个我相信大家很容易想到使用RelativeLayout,对,没错,那么我们先定义一个类姑且叫FavorLayout吧,继承自RelativeLayout,并且重载构造函数,并定义一些变量.12345678910111213141516171819202122232425262728293031public class FavorLayout extends RelativeLayout&#123;private Random random = new Random();//用于实现随机功能 private int dHeight;//爱心的高度 private int dWidth;//爱心的宽度private int mHeight;//FavorLayout的高度 private int mWidth;//FavorLayout的宽度public FavorLayout(Context context) &#123; super(context); &#125;public FavorLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); //为了显示区域,我设置了一个背景颜色,随意 setBackgroundColor(getResources().getColor(R.color.bg));//init里做一些初始化变量的操作 init();&#125;//重写onMeasure 获取控件宽高@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); //注意!! 获取本身的宽高 需要在测量之后才有宽高 mWidth = getMeasuredWidth(); mHeight = getMeasuredHeight(); &#125;&#125; 定义完毕后我们来实现底部,水平居中:12345678//定义一个LayoutParams 用它来控制子view的位置 private LayoutParams lp; //底部 并且 水平居中 lp = new LayoutParams(dWidth, dHeight); lp.addRule(CENTER_HORIZONTAL, TRUE); //这里的TRUE 要注意 不是true lp.addRule(ALIGN_PARENT_BOTTOM, TRUE); //好了,之后只要给子view设置LayoutParams就可以实现了 2.接下来实现第二步,随机爱心在Android实现随机数可以使用Random类,这里我只准备了3种不同的爱心,来看看代码如何实现吧:12345678910111213141516//首先定义 3个代表不同爱心的drawable,以及他们的和drawables private Drawable red ; private Drawable yellow ; private Drawable blue ; private Drawable[] drawables ; //接下去我们初始化: //初始化显示的图片 drawables = new Drawable[3]; red = getResources().getDrawable(R.mipmap.red); yellow = getResources().getDrawable(R.mipmap.yellow); blue = getResources().getDrawable(R.mipmap.blue); //赋值给drawables drawables[0]=red; drawables[1]=yellow; drawables[2]=blue; 这样,下次取值时候只要使用如下代码,就能随机获取到爱心了:1drawables[random.nextInt(3)]//表示0-2的随机数,注意,3是取不到的,是个开区间 3.好了随机的爱心问题搞定,接下去让我们做缩放动画吧~说到Android动画,我们以前常用Animation,它通常情况下能满足我们的需求,但是它的功能比较弱,并不是很好用.好在3.0后,强大的属性动画的出现,让动画在Android中实现起来变得非常容易.如果你还不知道属性动画怎么使用,赶紧去了解一下吧!(以前在eoe上发过一篇帖子,很基础,ObjectAnimator的运用,有兴趣可以看下,提前说下,那是很久以前写的!) 废话不说了,那么具体怎么做呢,来看代码吧:1234567891011121314//我封装了一个方法 利用ObjectAnimator AnimatorSet来实现 alpha以及x,y轴的缩放功能//target就是爱心private AnimatorSet getEnterAnimtor(final View target) &#123; ObjectAnimator alpha = ObjectAnimator.ofFloat(target,View.ALPHA, 0.2f, 1f); ObjectAnimator scaleX = ObjectAnimator.ofFloat(target,View.SCALE_X, 0.2f, 1f); ObjectAnimator scaleY = ObjectAnimator.ofFloat(target,View.SCALE_Y, 0.2f, 1f); AnimatorSet enter = new AnimatorSet(); enter.setDuration(500); enter.setInterpolator(new LinearInterpolator()); enter.playTogether(alpha,scaleX, scaleY); enter.setTarget(target); return enter; &#125; OK,缩放功能已经加了,第一个阶段也算是完成了,我们来看看效果吧: 偶,忘记说了,我们给外面的按钮设置点击事件,并且提供外部一个方法调用:12345678910111213141516171819202122mBtnStartAnim.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mFavorLayout.addFavor(); &#125; &#125;);public void addFavor() &#123; ImageView imageView = new ImageView(getContext()); //随机选一个 imageView.setImageDrawable(drawables[random.nextInt(3)]); // 设置底部 水平居中 imageView.setLayoutParams(lp); addView(imageView); Log.v(TAG, "add后子view数:"+getChildCount()); Animator set = getEnterAnimtor(imageView); set.start();&#125; 好了这下可以运行看看效果啦: 可以看到,爱心的颜色是随机的,并且也有了缩放动画. 到此,简单的功能我们已经完成了,那么接下去就是大头了. 4.实现贝塞尔曲线效果我们怎么让爱心按照曲线移动?而且还有随机呢? OK,接下去就是本文的主角贝塞尔曲线登场的时刻啦,这也是我实现这个效果学到的最重要的知识. 我是看这篇文章学习了解贝塞尔曲线的,推荐一下.简单来说,就是给定几个点,计算出一个曲线.(其实复杂得我看不懂) 简单了解贝塞尔曲线后,发现三次方贝塞尔曲线 符合我们的要求公式: 拿到了公式,先不要着急,我们先思考一下,明确一下它的参数是干什么的:公式中需要四个P,P0,是我们的起点,P3是终点,P1,P2是途径的两个点而t则是我们的一个因子,取值范围是0-1,熟悉动画的同学应该就明白,0-1,对动画的作用有多么重大!!!所以看到这个,真是笑了~~ 因为需要自己实现贝塞尔,所以我想到了属性动画中的TypeEvaluator,它就是我们需要的. 好了,接下来,我们来实现吧~ 12345678910111213141516171819202122232425262728293031323334//我们自定义一个BezierEvaluator 实现 TypeEvaluator//由于我们view的移动需要控制x y 所以就传入PointF 作为参数,是不是感觉完全契合??public class BezierEvaluator implements TypeEvaluator&lt;PointF&gt; &#123; private PointF pointF1;//途径的两个点 private PointF pointF2; public BezierEvaluator(PointF pointF1,PointF pointF2)&#123; this.pointF1 = pointF1; this.pointF2 = pointF2; &#125; @Override public PointF evaluate(float time, PointF startValue, PointF endValue) &#123; float timeLeft = 1.0f - time; PointF point = new PointF();//结果 PointF point0 = (PointF)startValue;//起点 PointF point3 = (PointF)endValue;//终点 //代入公式 point.x = timeLeft * timeLeft * timeLeft * (point0.x) + 3 * timeLeft * timeLeft * time * (pointF1.x) + 3 * timeLeft * time * time * (pointF2.x) + time * time * time * (point3.x); point.y = timeLeft * timeLeft * timeLeft * (point0.y) + 3 * timeLeft * timeLeft * time * (pointF1.y) + 3 * timeLeft * time * time * (pointF2.y) + time * time * time * (point3.y); return point; &#125;&#125; 到这一步,只要我们传入两个PonitF就能得到一个贝塞尔曲线了.接下来我们在FavorLayout中定义获取一个贝塞尔动画的方法:123456789101112131415161718192021222324252627private ValueAnimator getBezierValueAnimator(View target) &#123; //初始化一个BezierEvaluator BezierEvaluator evaluator = new BezierEvaluator(getPointF(2),getPointF(1)); //这里最好画个图 理解一下 传入了起点 和 终点 ValueAnimator animator = ValueAnimator.ofObject(evaluator,new PointF((mWidth-dWidth)/2,mHeight-dHeight),new PointF(random.nextInt(getWidth()),0));//随机 animator.addUpdateListener(new BezierListenr(target)); animator.setTarget(target); animator.setDuration(3000); return animator; &#125;//这里涉及到另外一个方法:getPointF(),这个是我用来获取途径的两个点// 这里的取值可以随意调整,调整到你希望的样子就好/** * 获取中间的两个 点 * @param scale */ private PointF getPointF(int scale) &#123; PointF pointF = new PointF(); pointF.x = random.nextInt((mWidth - 100));//减去100 是为了控制 x轴活动范围,看效果 随意~~ //再Y轴上 为了确保第二个点 在第一个点之上,我把Y分成了上下两半 这样动画效果好一些 也可以用其他方法 pointF.y = random.nextInt((mHeight - 100))/scale; return pointF; &#125; 眼尖的你一定发现了我给动画加了一个监听,只有在回调里使用了计算的值,才能真正做到曲线运动,否则没有效果哦:1234567891011121314151617private class BezierListenr implements ValueAnimator.AnimatorUpdateListener &#123; private View target; public BezierListenr(View target) &#123; this.target = target; &#125; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; //这里获取到贝塞尔曲线计算出来的的x y值 赋值给view 这样就能让爱心随着曲线走啦 PointF pointF = (PointF) animation.getAnimatedValue(); target.setX(pointF.x); target.setY(pointF.y); // 这里偷个懒,顺便做一个alpha动画,这样alpha渐变也完成啦 target.setAlpha(1-animation.getAnimatedFraction()); &#125; &#125; 好了这个方法写完,让我们来测试一下效果如何吧!对了,需要修改一下addFavor方法12345678910public void addFavor() &#123; ImageView imageView = new ImageView(getContext()); //随机选一个 imageView.setImageDrawable(drawables[random.nextInt(3)]); imageView.setLayoutParams(lp); addView(imageView); Log.v(TAG, "add后子view数:"+getChildCount()); getBezierValueAnimator(imageView).start(); &#125; 好了,点击一下,看看效果吧!!! 怎么样?还不错吧??? 缩放的效果我们做了,曲线效果也有了那么接下去把他们连起来即可!!~ 5.收尾,最终效果5.1 实现变速1234567891011121314151617181920212223242526272829303132333435363738// 我为了实现 变速效果 挑选了几种插补器private Interpolator line = new LinearInterpolator();//线性 private Interpolator acc = new AccelerateInterpolator();//加速 private Interpolator dce = new DecelerateInterpolator();//减速 private Interpolator accdec = new AccelerateDecelerateInterpolator();//先加速后减速 // 在init中初始化 private Interpolator[] interpolators ;// 最终 init方法长这样:private void init() &#123; //初始化显示的图片 drawables = new Drawable[3]; red = getResources().getDrawable(R.mipmap.red); yellow = getResources().getDrawable(R.mipmap.yellow); blue = getResources().getDrawable(R.mipmap.blue); drawables[0]=red; drawables[1]=yellow; drawables[2]=blue; //获取图的宽高 用于后面的计算 //注意 我这里3张图片的大小都是一样的,所以我只取了一个 dHeight = red.getIntrinsicHeight(); dWidth = red.getIntrinsicWidth(); //底部 并且 水平居中 lp = new LayoutParams(dWidth, dHeight); lp.addRule(CENTER_HORIZONTAL, TRUE);//这里的TRUE 要注意 不是true lp.addRule(ALIGN_PARENT_BOTTOM, TRUE); // 初始化插补器 interpolators = new Interpolator[4]; interpolators[0] = line; interpolators[1] = acc; interpolators[2] = dce; interpolators[3] = accdec; &#125; 5.2 合并前俩种动画,做成最终动画123456789101112private Animator getAnimator(View target)&#123; AnimatorSet set = getEnterAnimtor(target); ValueAnimator bezierValueAnimator = getBezierValueAnimator(target); AnimatorSet finalSet = new AnimatorSet(); finalSet.playSequentially(set); finalSet.playSequentially(set, bezierValueAnimator); finalSet.setInterpolator(interpolators[random.nextInt(4)]);//实现随机变速 finalSet.setTarget(target); return finalSet; &#125; 5.3 最后修改addFavor方法:123456789101112131415public void addFavor() &#123; ImageView imageView = new ImageView(getContext()); //随机选一个 imageView.setImageDrawable(drawables[random.nextInt(3)]); imageView.setLayoutParams(lp); addView(imageView); Log.v(TAG, "add后子view数:"+getChildCount()); Animator set = getAnimator(imageView); set.addListener(new AnimEndListener(imageView)); set.start(); &#125; 在修改addFavor方法的同时我增加了一个监听,目的是为了在动画结束后,把爱心移除,不然,子view只增不减!!!!1234567891011121314private class AnimEndListener extends AnimatorListenerAdapter &#123; private View target; public AnimEndListener(View target) &#123; this.target = target; &#125; @Override public void onAnimationEnd(Animator animation) &#123; super.onAnimationEnd(animation); //因为不停的add 导致子view数量只增不减,所以在view动画结束后remove掉 removeView((target)); Log.v(TAG, "removeView后子view数:"+getChildCount()); &#125; &#125; 6. 总结呼!呼!~好了,最终的效果我们也实现了. 实际上,实现这个效果,我遇到了不少困难与问题,逐个击破后才迎来了最后的这个效果,收获颇丰. 希望大家看完后都能亲自动手去实现一下,相信你会学到更多东西! 写到这里,我发现,写文章比敲代码难多了啊!!!写文章花费的时间不少于我实现这个功能花费的时间!!!!真心的!!!!!(不知不觉,到端午了) So,在这里无耻的请求大家,如果喜欢,请点赞,帮忙分享一下吧!~ 欢迎关注我,第一时间获取新消息~ 最后,祝大家端午快乐! 下次见~~ 更新源码已经上传至jcenter,集成超级方便—&gt;走起]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App研发录读书笔记]]></title>
    <url>%2FApp%E7%A0%94%E5%8F%91%E5%BD%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言书的title都取得很高端,但是内容比较一般,特别是讲开发的,知识点分散,又不具体,不深入,差不多就是告诉你有XX东西,很有必要,但是又不教你怎么去做,所以几乎等于没讲啊。（很失望）作者可能在开发领域有挺长的时间,积累了很多开发和管理经验,但是这书的内容不太行.（针对Android方面，针对个人而言） 这里记录一些我还觉得还算有用的知识点 高效App框架设计与重构 自定义一些基类(如BaseActivity) 采取一定的方式在客户端模拟API返回数据,用于测试 启用Cookie Http数据要加密 公共参数可以存放到Header里 时间校准(返回服务器时间与本地时间比较(非常有必要)) HTTP请求开启gzip压缩来减少传输量(省流量,加快速度),如果用Okhttp,gzip挺简单的,不过需要服务端的支持 根据网络状况去下载不同尺寸的图片 急速模式(比如不显示图片,提供开关) 城市列表增量更新(本地保留版本号,与服务器对照,下发需要修改的数据,CURD进行操作) H5跳转Activity,可以传递一个String,按照约定的协议去解析,再跳转(一般传递Activity的全称,再 key-value来传递参数) 命名规范和代码规范(我推荐checkstyle) App开发中的高级技巧同上一章节,关于Crash竟然没写Android具体应该怎么做,却写了一堆数据库代码,真是醉了~然后分析Crash,没什么软用,crash什么的碰到一次,你就知道了,提前看也没什么作用,而且,很多作者自己也根本没弄懂,呵呵. 持续集成章节基于Eclipse,Ant,这能看?(反正我是不用Eclipse也不用Ant的直接跳过了)单元测试差不多就是讲了有这么东西,然而并不教你怎么做. 诶~忍不住又吐槽了~ 通过实现UncaughtExceptionHandler去捕获异常 异常分析时出现Unknown Source,丢失了文件名和行号,这比较蛋疼,可以在ProGuard文件中增加-keepattributes SourceFile,LineNumberTable(umong分析是上传mapping文件,这个方法还有待验证,扩展阅读-&gt;bugly and 精神哥) App竞品技术分析利用 AXMLPrinter2.jar可以还原被压缩过后的xml (这个对反编译有帮助,尝试有效)1java -jar AXMLPrinter2.jar AndroidManifest.xml 获取最佳服务器 数据采集 ABTest Android打包META-INF目录的妙用 拆分classes.dex 模块化 热修复 插件化 项目管理和团队建设这章我差不多就浏览了一遍,内容很日常化,也就不想多记录什么了,自有体会. 不能没有测试团队(赞同!我司没有,深感痛苦 自测测出的bug很少,而且会占用开发大量的时间) 模块化分工 每天例会 … 推荐阅读:所有的读书笔记]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>App研发录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第4章 类和接口]]></title>
    <url>%2F%E7%AC%AC4%E7%AB%A0-%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[第4章 类和接口类和接口是Java程序设计语言的核心，它们也是Java语言的基本抽象单元。 初学Java的时候感觉类和接口都好简单，后续慢慢发现类和接口的设计并非是想象总的那么简单的，还有好多需要学习。 而这一章作者就阐述了一些指导原则，指导我们设计出更加有用、健壮和灵活的类和接口，很有意义。 第13条 使类和成员的可访问性最小化设计良好的模块对外部而言总是隐藏了所有的细节 模块之间中通过它们的API进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装，是软件设计的基本原则之一（还是封装好听啊，信息隐藏好low啊） 封装可以有效解除各个模块之间的耦合关系，是现在模块化开发的基础，使模块可以独立地开发、测试、优化、使用、理解和修改。 尽可能地使每个类或者成员不被外界访问。Java中可以通过包、访问修饰符（private protected public）控制类、接口和成员的可访问性（accessibility） 除了应该暴露的API之外，我们应该尽可能少的开放访问权。因为一旦暴露给外界，可能会有风险，另外还需要保证一直维护与兼容。 可以想象一下，当我们使用一个第三方库的时候，如果它暴露了一个不该暴露的类（假设为BitmapUtil），而我们恰好用了它里面的方法，结果它一升级，把方法改了，或者把方法去掉了，那我们不是懵了？ 所以不要去暴露那些不该暴露的类、接口、成员 小结作者在最后给了小结：应该始终尽可能地降低可访问性。应该防止把任何散乱的类、接口和成员变成API的一部分。除了公有静态final域的特殊情形之外，共有类都不应该包含公有域。并且要确保公有静态final域所引用的对象都不是可变的 第14条 在共有类中使用访问方法而非公有域假设有一个类：1234public class Point&#123; public double x; public double y;&#125; 作者的意思是不应该直接暴露x y,要为它们提供getter、setter方法，这样有利于添加约束条件，辅助行为。 本人表示道理我懂，但是现在一般的类都不愿意去写getter setter了，真心觉得好烦啊，虽然方法可以用AS自动生成，我还是不太愿意去写，直接public就是那么任性 第15条 使可变性最小化 不可变类：实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变。如：String、基本类型的包装类、BigInteger和BigDecimal不可变类比可变类更加易于设计、实现和使用。它们不容易出错，且更加安全。 不可变类的五条规则： 不要提供任何会修改对象状态的方法。 保证类不会被扩展。 一般用final修饰 使所有的域都是final的。 使所有的域都成为私有的。（降低访问权限） 确保对于任何可变组件的互斥访问。（什么意思呢？） 不可变类的优缺点线程安全不要求同步，无惧多线程并发访问 不可变对象可以被自由地共享所以不需要保护性拷贝（如String类的拷贝构造器）也可以重复利用，如:Boolean.FALSE/TRUE 不可变对象为其他对象提供了大量的构建（building blocks）不是很懂 唯一的缺点：对于每个不同的值都需要一个单独的对象如FALSE TRUE ，不过如果值少，到也没什么关系但是如String这样的不可变类，我们需要注意，多用StringBuilder（可变，性能好） 小结除非有很好的理由要让类成为可变的类，否则就应该是不可变的。如果类不能被做成是不可变的，仍然应该尽可能地限制它的可变性。（降低出错的可能性） 第16条 复合优先于继承在读HeadFirstDesignPattern的时候已经看到太多次了 这里的继承是指 实现继承（implementation inheritance）也即extends 而不是接口继承 复合（composition）也应该是常听到的组合 继承打破了封装性 子类依赖于超类中特定功能的实现细节 当超类发生改变，子类可能会遭到破坏 比如随着版本的发布，超类需要新增方法，但是这些方法不是所有子类需要的，那么就破坏了子类！ 复合（组合）复合，即使用包装类（wrapper class），其实这也就是设计模式中的装饰者模式 另外值得一提的是，复合以及转发并不是委托（delegation） 装饰者模式的优缺点不多说了，可以看设计模式的笔记 小结继承功能确实强大，但它也存在很多问题，比如违背了封装原则（是不是很矛盾？），对于两个类，它们确实有is-a的关系时候才使用继承！ 所以使用继承的时候要考虑清楚 第17条 要么为继承而设计，并提供文档说明，要么就禁止继承好的API文档应该描述一个给定的方法做了什么工作,而不是描述它是如何做到的 如标题，恩，我可是连注释都懒得写的人，怎么会写文档。。。 第18条 接口优于抽象类Java提供两种机制用来定义允许多个实现的类型:接口和抽象类。 区别接口和抽象类的区别有很多，其中 最为明显 的区别是： 抽象类可以包含某些方法的实现，而接口不允许，即接口都是抽象方法 而另外还有一个 更重要 的区别是：为了实现由抽象类定义的类型，类必须成为抽象类的一个子类。而Java是单继承的，所以抽象类作为类型定义受到了极大的限制，而接口没有这个限制。 接口的优势 现有的类可以很容易被更新，以实现新的接口当需要增加方法的时候只需要implements具体的接口即可,非常方便,而如果通过抽象类来实现,则需要在抽象类里新增方法,而这会导致其他继承该抽象类的类也被强制加上额外的方法! 接口是定义mixin(混合类型)的理想选择mixin是指主要的类型: 类除了实现它的”基本类型”之外,还可以实现这个mixin类型(一脸懵逼!这翻译的什么玩意?) Comparable是一个mixin接口 我的理解是:一个类,利用实现多个接口可以达到混合类型的目的,而利用抽象类只能继承一个类,则不能达到混合类型的效果! 接口允许我们构造非层次结构的类型框架 第19条 接口只用于定义类型我们知道当类实现接口时,我们可以把该类的类型当做是接口的类型来使用,这是我们定义接口的唯一目的,也即接口 只应该用来定义类型 看到这里,可能你会跟我一样奇怪,接口不就是用来定义类型的吗,还能用来干嘛? 有一种接口被称为 常量接口 ,就是没有方法,只有常量的接口,这常量接口模式是对接口的不良使用,因为它没什么卵用还会污染实现类 Java中有几个常量接口,如java.io.ObjectStreamConstants,千万别学啊!~建议常量用工具类或者枚举或者@IntDef注解来实现 第20条 类层次优于标签类标签类，书中对它的定义说得很拗口。我的理解是一个类，拥有多个风格，通过一个属性来区分不同的风格，类里充斥着if else或者switch case 举个例子：12345678910class Person&#123; boolean isMan; String sayHi()&#123; if (isMan) &#123; return "Yo hi man!~"; &#125;else&#123; return "Hello"; &#125; &#125;&#125; Person类，通过isMan属性来区分是男的还是女的，sayHi()方法针对男女有不同的表现，这个就是一个非常简单的标签类 标签类的缺点非常明显，当你要表现的风格非常多样的时候，你需要写大量的判断语句，非常容易出错，而且当你需要修改某一个风格的时候，你需要在一大堆代码里找出你要改的地方，很有可能引入bug，非常难以维护。 这个时候，将标签类转变成类层次就非常方便了： 123456789101112131415abstract class Person&#123; abstract String sayHi();&#125;class Man extends Person&#123; @Override String sayHi() &#123; return "Yo hi man!~"; &#125;&#125;class Woman extends Person&#123; @Override String sayHi() &#123; return "Hello"; &#125;&#125; 抽象出一个Person类，定义Man和Woman类继承它，根据自己的需求实现sayHi()方法，当需要修改Man的行为时，你不需要也不用担心会破坏Woman的代码，代码可读性，可维护性一下子高了很多，有木有？！ 第21条 用函数对象表示策略函数对象的概念:如果一个类仅仅导出这样的一个方法(执行其他对象(这些对象被显示传递给这些方法)上的操作),它的实例实际上就等同于一个指向该方法的指针.这样的实例被称为函数对象(function object). 如:12345class StringLengthComparator&#123; public int compare(String s1,String s2)&#123; return s1.length()-s2.length(); &#125;&#125; StringLengthComparator类即是一个典型的函数对象,指向StringLengthComparator对象的引用可以被当做是一个指向该比较器的函数指针(function pointer),它也是一个用于字符串比较操作的具体策略,这个策略为策略模式中的策略,并且函数指针的主要用途就是实现策略模式.(关于策略模式这里就不多讲,推荐看&lt;&gt;,如果你不着急,可以等我出笔记~) PS:指针的英语是 pointer 第22条 优先考虑静态成员类嵌套类(nested class)是指被定义在另一个类的内部的类,它存在的目的应该只是为它的外围类(enclosing class)提供服务. 嵌套类分为四种: 静态成员类(static member class) （不是内部类） 非静态成员类(nonstatic member class) 匿名类(anonymous class) 局部类(local class) 除了第一种之外,其他三种都被称为 内部类(inner class) 静态成员类 &amp; 非静态成员类最简单的嵌套类，最好把它看成普通的类，只是碰巧被声明在另一个类的内部而已（挺不错的解释），所以它可以脱离外部类单独存在。 它可以访问外部类的所有成员，包括private修饰的,也可以被访问修饰符修饰，来控制它的可见性。 作用：静态成员类一般是用来辅助外部类的，比如CoordinatorLayout类中的Behavior类，它定义了一系列的行为用于辅助它的外部类CoordinatorLayout，例子有很多，不多说了。 静态成员类 &amp; 非静态成员类 的差别虽然它们只差了一个static修饰符，但是其实它们差别巨大。 非静态成员类的实例都隐含持有一个外部类的实例（enclosing instance） 这不仅仅会消耗更多的空间，还可能会导致外部类的实例泄漏，内存泄漏，而静态成员类并不会。 这在Android中很常见，比如我们使用Handler的时候，AS都会提示我们这可能造成内存泄漏，让我们使用静态成员类。 所以通常情况更推荐静态成员类，书中有一句话：如果声明成员类不要求访问外围实例，就要始终把static修饰符放在它的声明中，使它成为静态成员类，而不是非静态成员类 匿名类 &amp; 局部类匿名类，没有名字，也不是外部类的成员，它是在使用的同时被声明和实例化 需要注意的是：当匿名类出现在非静态的环境中时，它会持有外部类的实例，所以它可能引起内存泄漏。 匿名类的作用：通常用于创建函数对象（见21条），比如Thread，Runnable 局部类非常少用，自己没用过，在源码里也没留意到它的存在，就不多写了。 小结虽然本条推荐静态成员类，不过每个嵌套类都有自己的用途，还是得按实际情况去抉择。 本章小结本章的内容在Java中非常重要，如果要提升架构能力，那么本章的学习必不可少！ 本系列作品所有的读书笔记第2章 创建和销毁对象第3章 对于所有对象都通用的方法第4章 类和接口]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>EffectiveJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给博客添加PV和UV统计啦]]></title>
    <url>%2F%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0PV%E5%92%8CUV%E7%BB%9F%E8%AE%A1%E5%95%A6%2F</url>
    <content type="text"><![CDATA[上次给博客添加了文章的统计,这次利用不蒜子给站点增加统计功能~~ 使用起来也非常简单,按照不蒜子官方的教程一步一步走就行, 这里稍微记录一下 修改next/layout/_partials/footer.swig”文件,在里面新增一些代码即可: 脚本:12&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 显示效果(其中 PV,UV字样可以自己修改): 1234567&lt;span id="busuanzi_container_site_pv"&gt; PV:&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;&lt;/span&gt;&lt;span id="busuanzi_container_site_uv"&gt; UV:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;&lt;/span&gt;&#123;% block footer %&#125;&#123;% endblock %&#125;//注意 这行原来就有 这样就能在博客的首页底部显示PV和UV啦!~ 很可惜的是,我在刚搭建博客的时候没有去统计,现在才开通,非常吃亏-0-~~ 2016年6月14日 21:18]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3章 对于所有对象都通用的方法]]></title>
    <url>%2F%E7%AC%AC3%E7%AB%A0-%E5%AF%B9%E4%BA%8E%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%83%BD%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言Object的设定是为了扩展,它的所有非final方法(equals hashCode toString clone finalize)都有明确的通用约定,因为它们被设计是要被覆盖(override)的而在覆盖这些方法时,都有责任遵守这些通用的约定,否则,其他依赖这些约定的类(如HashMap&amp;HashSet)就无法结合该类一起正常运作. 第8条 覆盖equals时请遵守通用约定不覆盖equals不覆盖equals的情况下,类的每个实例都与它自身相等,如果满足以下任何一个条件,就是所期望的结果: 类的每个实例本质上都是唯一的 不关心类是否提供了”逻辑相等”的测试功能 超类已经覆盖了equals,从超类继承过来的行为对于子类也是合适的(要小心) 类是私有的或是包级私有的,可以确定它的equals方法永远不会被调用 (不懂为什么) 讲得怪怪的 PS: 逻辑相等,就是逻辑上是相等的,比如id一样,判定它们相等,即使它们是两个不同的对象 什么时候应该覆盖equals当类需要逻辑相等这个概念的时候就应该覆盖equals比如要判断两个student是否是同一个人,这个时候我们就需要按需重写equals 通用约定重写equals的时候就必须要遵守它的通用约定equals方法实现了等价关系(equivalence relation): 自反性(reflexive) 对于任何非null的引用值x,x.equals(x)必须返回true 对称性(symmetric) 对于任何非null的引用值x和y,当且仅当y.equals(x)返回true时,x.equals(y)必须返回true 传递性(transitive) 对于任何非null的引用值,x,y,z,如果x.equals(y)为true,并且y.equals(z)也返回true,那么x.equals(z)也必须返回true 一致性(consistent) 对于任何非null的引用值x和y,只要equals的比较操作在对象中所用的信息没有被修改,多次调用x.equals(y)就会一致地返回true,或者false 对于任何非null的引用值,x,x.equals(null)必须返回false 感觉又回到了学数学交换律什么的的时候了~ 有些类(如集合,HashMap)与equals方法息息相关,所以重写的时候要仔细小心 高质量的equalsej对equals提了几点建议: 使用==操作符检查”参数是否为这个对象的引用” 如果是,则返回true. 这只不过是一种性能优化,如果比较操作有可能很昂贵,就值得这么做 (平时没有用过,怎么样的比较操作算是昂贵的呢?) 使用instanceof操作符检查”参数是否为正确的类型” 如果不是,则返回false。 把参数装换成正确的类型。(这个比较好理解,instanceof检测后,一般都会强转成所需类型) 对于该类中的每个『关键』域,检查参数中的域是否与对象中对应的域相配。(比如学生类有学号，班级，姓名这些重要的属性，我们都需要去比对) 当你编写完成了equals方法之后，应该问自己是哪个问题:它是否是对称的、传递的、一致的？ 另外EJ还告诫我们覆盖equals的时候总要覆盖hashCode（见第9条） 小结最后按照上诉建议，用一个Student类来总结一下equals的写法： 1234567891011121314151617181920public class Student &#123; public String name; public String className; @Override public boolean equals(Object obj) &#123; //对于一个null的对象 我们总是返回false if (null == obj) &#123; return false; &#125; // 利用instanceof检查类型后,强转 if (obj instanceof Student)&#123; Student other = (Student) obj; //再对关键的属性做比较 得出结论 if (name.equals(other.name) &amp;&amp; className.equals(other.className)) &#123; return true; &#125; &#125; return false; &#125;&#125; equals是一个看上去简单,实则是个比较容易犯错的方法,需要小心仔细 第9条 覆盖equals时总要覆盖hashCode覆盖了equals方法,也必须覆盖hashCode方法,if not,就违反了hashCode的通用约定,会导致无法跟基于散列的集合正常运作. Object通用约定(在Object类中的注释即是): 在应用程序的执行期间,只要对象的equals方法的比较操作所用到的信息没有被修改,那么对这同一个对象调用多次,hashCode方法都必须始终如一地返回同一个整数.在同一个应用程序的多次执行过程中,每次执行所返回的整数可以不一致. 如果两个对象根据equals方法比较是相等的,那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果.(即equals相等,那么hashCode一定相等,需要注意的是,反过来不一定成立,即hashCode相等不代表equals相等) 如果两个对象根据equals方法比较是不相等的,那么调用这两个对象中任意一个对象的hashCode方法,则不一定要产生不同的整数结果.但是程序员应该知道,给不相等的对象产生截然不同的证书结果,有可能提高散列表(hash table)的性能. 不重写hashCode带来的问题正如之前提到的,hashCode其实主要用于跟基于散列的集合合作如HashMap会把相同的hashCode的对象放在同一个散列桶(hash bucket)中,那么即使equals相同而hashCode不相等,那么跟HashMap一起使用,则会得到与预期不相同的结果. 具体是怎么样的不同的效果？来看一段代码：PS：Student类是第8条里的类，重写了equals 12345678public static void main(String[]args) &#123; Student lilei = new Student("lilei","class1"); HashMap&lt;Student, String&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(lilei, lilei.className); String className = hashMap.get(new Student("lilei","class1"));//值与之前的lilei相同，即equals会为true System.out.println(className);&#125; className的值为多少呢？class1?NO！是null！！！！(诶？) 为什么呢？因为我们并没有重写hashcode，所以即使我们去get的时候传入的Student的name以及classname与put的时候的对象值是一样的，也即它们是equals的(我重写了equals！)，但是要注意，它们的hashcode是不一样的，这样就违反了上面所说的equals相等，hashCode也要相等的原则，所以当我们期望get到的是class1的时候，我们需要重写hashCode方法，让它们的hashcode相同！ 那么问题来了，如何去重写hashCode呢？返回一个固定值?比如1？NO!!!So,how? 如何重写hashCodeEJ给出的解决办法： 把某个非零的常数值，比如17，保存在一个名为result的int类型的变量中。 对于对象中每个关键域f(指equals方法中涉及的每个域)，完成以下步骤： 步骤(a) 为该域计算int类型的散列码c： 如果f是boolean，则计算 f?1:0 如果是byte，char，short或int，则计算 (int)f 如果是long，则计算(int)(f^(f&gt;&gt;&gt;32)) 如果是float，则Float.floatToIntBits(s) 如果是double，则计算Double.doubleToLongBits(f),再按long类型计算一遍 如果是f是个对象引用，并且该类的equals方法通过递归地调用equals的方式来比较这个域，则同样为这个域递归调用hashCode。如果需要更复杂的比较，则为这个域计算一个‘范式’，然后针对这个范式调用hashCode。如果这个域的值为null，则返回0(或者其他某个常数，但通常是0)。 如果是个数组，则需要把每个元素当做单独的域来处理。也就是说，递归地应用上述规则，对每个重要的元素计算一个散列码，然后根据步骤b中的做法把这些散列值组合起来。 如果数组域中的每个元素都很重要，可以利用发行版本1.5中增加的其中一个Arrays.hashCode方法。 步骤(b) 按照下面公式，把(a)步骤中计算得到的散列码c合并到result中：result = 31*result+c (为什么是31呢？) 返回result 测试，是否符合『相等的实例是否都具有相等的散列码』 OK，知道怎么写之后，我们重写Student类的hashCode方法：1234567@Overridepublic int hashCode() &#123; int result = 17;//非0 任选 result = 31*result + name.hashCode(); result = 31*result + className.hashCode(); return result;&#125; 这下之前的代码输出的结果为class1了！！！~ 为什么要选31？ 因为它是个奇素数，另外它还有个很好的特性，即用移位和减法来代替乘法，可以得到更好的性能：31*i == (i&lt;&lt;5)-i 小结终于学会如何写hashCode了！老实说，我并没有做到这条要求!因为一般来说我不会把Student这样的类当做一个Key去处理 PS：书中讲到的知识点很多，光看这个笔记是不够的，如果可以，自己去阅读书籍吧！ 其他资料dim提供：浅谈Java中的hashcode方法 第10条 始终要覆盖toStringObject类默认toString的实现方法是这样的： 123public String toString() &#123; return getClass().getName() + '@' + Integer.toHexString(hashCode());&#125; 它只有类名+‘@’+散列值，toString的通用约定指出，被返回的字符串应该是一个『简洁的，但信息丰富，并且易于阅读的表达形式』虽然够简单，但是信息并不丰富，而且更多时候我们更希望toString返回对象中包含的所有值得关注的信息,当属性多了，只显示信息重要的即可 toString倒没有特别大的约束 第11条 谨慎地覆盖cloneclone说到clone(protected)就必须提及一下Cloneable接口，这个接口很奇怪，没有方法： 12public interface Cloneable &#123;&#125; 而Object的clone方法，当我们尝试调用一个没有实现Cloneable接口的类的clone方法数时，clone会抛出CloneNotSupportedException，是不是很坑爹？ 1234567protected Object clone() throws CloneNotSupportedException &#123; if (!(this instanceof Cloneable)) &#123; throw new CloneNotSupportedException("Class " + getClass().getName() + " doesn't implement Cloneable"); &#125; return internalClone();&#125; 为什么不把clone方法放Cloneable接口里面去却偏偏塞给了Object？这个设计我真的想不明白！！！！！ clone方法自己没怎么用过,不过可以看看其他优秀的库的设计,比如Retrofit中的OkHttpCall: 123@Override public OkHttpCall&lt;T&gt; clone() &#123; return new OkHttpCall&lt;&gt;(serviceMethod, args);&#125; PS:在使用优秀的开源库的时候,如果可以,多看看它的源码,你会学到很多!相信我! 第12条 考虑实现Comparable接口注意compareTo不是Object的方法,而是Comparable接口的方法: 123public interface Comparable&lt;T&gt;&#123; int compareTo(T t);&#125; compareTo的约定跟equals类似： PS：符合sgn（表达式）表示数学中的signum函数，它根据表达式（expression）的值为负值、零、和正直，分别返回-1、0或1 确保sgn(x.compareTo(y))== -sgn(y.compareTo(x)) 可传递：x.compareTo(y)&gt; 0 &amp;&amp; y.compareTo(z) 暗示 x.compareTo(z)&gt; 0 确保x.compareTo(y)==0暗示所有z都满足sgn(x.compareTo(z)）== sgn(y.compareTo(z)） 强烈建议(x.compareTo(y)==0)，但这并非绝对重要（个人觉得还是遵守更好一些！） 如果不想写compareTo或者类并没有实现Comparable接口的可以自定义一个Comparator类来进行比较。 需要注意,排序是不允许出现逻辑漏洞的,否则会crash! 本章完结题外话:Object一共有12个方法,其中7个是native方法 本系列作品所有的读书笔记第2章 创建和销毁对象第3章 对于所有对象都通用的方法第4章 类和接口]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>EffectiveJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EditText使用小技巧]]></title>
    <url>%2FEditText%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[设置回车/send/..通过setImeOptions(EditorInfo.IME_ACTION_SEND) 方法我们可以设定输入法的Action,即经常看到的Enter/Send/回车等. 屏蔽长按事件长按EditText会弹出复制/黏贴等功能栏,而Android自带的界面很丑,而且会挤压我们的UI(MIUI的不会),所以我们需要屏蔽它: 实现ActionMode.Callback接口在onCreateActionMode方法返回false 123456789101112131415161718192021private class MyActionModeListener implements ActionMode.Callback &#123; @Override public boolean onCreateActionMode(ActionMode mode, Menu menu) &#123; return false; &#125; @Override public boolean onPrepareActionMode(ActionMode mode, Menu menu) &#123; return false; &#125; @Override public boolean onActionItemClicked(ActionMode mode, MenuItem item) &#123; return false; &#125; @Override public void onDestroyActionMode(ActionMode mode) &#123; &#125; &#125; 通过setCustomSelectionActionModeCallback设置1mEdtInput.setCustomSelectionActionModeCallback(new MyActionModeListener());//屏蔽长按事件 对话框中有ET,弹不出输入法当我们需要弹出一个有EditText的同时,弹出输入法,我们需要做如下处理: 12345678dialog.setOnShowListener(new DialogInterface.OnShowListener() &#123; @Override public void onShow(DialogInterface dialog) &#123; InputMethodManager inputMethodManager = (InputMethodManager) mActivity.getSystemService(Context.INPUT_METHOD_SERVICE); inputMethodManager.showSoftInput(editText, InputMethodManager.SHOW_IMPLICIT);//用 SHOW_FORCED 来打开的话 对话框消失后输入法不会自己消失 &#125;&#125;); 焦点问题清除焦点123mEdtNick.clearFocus();mEdtNick.setFocusableInTouchMode(false);mEdtNick.setFocusable(false); 重新能够获取焦点12mEdtNick.setFocusable(true);//光这句不行 点击之后不能输入mEdtNick.setFocusableInTouchMode(true);// 动态修改drawable12345Drawable right = getResources().getDrawable(R.drawable.bg_change_name);//setbounds 不能少 right.setBounds(0,0,right.getIntrinsicWidth(),right.getIntrinsicWidth());//l t r b mEdtNick.setCompoundDrawables(null,null,right,null);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Tip</tag>
        <tag>EditText</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java泛型]]></title>
    <url>%2FJava%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[前言泛型程序设计意味着编写的代码可以被很多不同的类型的对象所重用 泛型在集合框架里拥有着非常广泛的运用,如果没有泛型估计是一大堆Object以及强转代码吧! 想想都可怕啊! 泛型类(generic class)泛型类就是具有一个或多个类型变量的类,如 12345public class Pair&lt;T,V&gt;&#123; T first; T second; V value;&#125; 什么是类型变量? 上诉代码中的 T和V 就是类型变量 ,用&lt;&gt;括起来,放在类名后面 类型变量使用大写形式,且比较短 一些常用的: E 表示集合的元素类型 K和V 分别表示表的关键字与值的类型 T(U或者S) 表示任意类型 泛型方法1234567public Class A&#123; public static &lt;T&gt;T test(T t)&#123; return t; &#125; public static &lt;T&gt; void hi(T t)&#123; &#125;&#125; 类型变量放在修饰符(public static等)的后面,返回类型的前面 类型变量的限定当我们想要对类型变量加以约束的时候我们就需要用到限定符 子类型限定1public static &lt;T extends Comparable&gt;T min(T[] a)... 表示T需要实现或继承Comparable接口,值得注意的是这里是extends 这里的extends表示T必须是子类型(实现或继承) 当然也可以用多个限定符来限制类型变量(用&amp;): T extends Comparable&amp;Serializable 通配符 的超类型限定通配符用?来表示,超类型限定(supertype bound)用super关键字表示 值得注意的是超类限定只能用于通配符 Pair&lt;? extends Employee&gt;表示任何泛型Pair类型,它的类型参数是Employee的子类 ? super Manager 将通配符限制为Manager的所有超类型 ==== 实例写了个练习的小例子,总结一下: 123456789101112131415161718192021222324252627282930313233public class GenericPractice &#123; public static void main(String[]args)&#123; Person person = new Person(); Hero hero = new Hero(); Knight knight = new Knight(); attack(person);// wrong !!! attack(hero); attack(knight); List&lt;Person&gt; persons = new ArrayList&lt;&gt;(); List&lt;Hero&gt; heros = new ArrayList&lt;&gt;(); List&lt;Knight&gt; knights = new ArrayList&lt;&gt;(); group(persons); group(heros); group(knights);//wrong !!! &#125; public static &lt;T extends Hero&gt; void attack(T t)&#123; &#125; public static void group(List&lt;? super Hero&gt; group)&#123; &#125; public static class Person&#123; &#125; public static class Hero extends Person&#123; &#125; public static class Knight extends Hero&#123; &#125;&#125; 留点笔记: 前提:Knight extends Hero,Hero extends Person attack方法使用&lt;T extends Hero&gt;来限定,即T必须是Hero类本身或者子类,所以attack(person)不能通过编译. group方法使用&lt;? super Hero&gt;来限定,即?必须是Hero类的本身或者父类,所以group(knights)不能通过编译.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HotFix的抉择]]></title>
    <url>%2FHotFix-%E7%9A%84%E6%8A%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[HotFix 的抉择现有框架 ： AndFix dexposed Xposed Nuwa HotFix qq空间的暂时还没开源 AndFixalibaba出品 功能：method body&#39;s replacing 即支持方法级别修复 SupportAndroid Version :2.3-6.0dalvik &amp; art runtime 优缺点无需重启 andfix只能替换方法而不能增减新的字段，也不能下发类 issue（122个）查看了一些issue，记录一些可能存在的问题以及缺陷： 兼容性问题 部分手机奔溃 部分手机ANR 不能改变量的值，不过方法的添加修改，删除，都可以 需要注意多进程 ART下模式无法对同一个方法进行多次更新 只是说可能，因为很多issue都没人回复 Nuwa贾吉鑫（原点评）出品 Supportdalvik &amp; art runtimeproductFlavor &amp; buildTypeproguard &amp; multidex纯Java 实现 优缺点基于类级别的修复，不仅仅只是修复方法 需要重启 issue(46个) ART环境支持的不好 i50 nuwa只支持 4.0以上，并不是作者所描述的2.3~6.0,作者使用的BaseDexClassLoader这个4.0才有的API，导致4.0以下的手机用Nuwa就必定崩溃，特此提醒 同AndFix Comparedexposed 不支持art(5.0+) 比较致命，所以最开始就被排除了 Nuwa HotFix DroidFix 都基于ClassLoader,兼容性以及稳定性好，支持2.3~6.0,对于启动速度有影响，补丁重启后才能生效 AndFix,支持2.3~6.0，但是兼容性以及稳定性较差，关键是不需要重启 原本想画个表，但是时间有限，不画了，就是这么任性。。。 HotFix Reboot Version LastUpdateTime AndFix No 0.4.0 2016.4 Nuwa Yes 1.0.0 五个月之前 结果虽然我原本从各个维度去考虑如何选择，比如Star数，版本号，更新频率，issue解答率等等，但是到最后其实可选的余地就两个，想要不重启即可生效，就选AndFix，否则可以考虑Nuwa 另外据小道消息听闻，QQ空间团队的热补（ClassLoader的鼻祖）会在qcan结束后开源，时间未知 我这个只是简单的比较，较为详细的可以看看大帅的『各大热补丁方案分析和比较』一文 系列HotFix调研HotFix的抉择AndFix简单使用教程AndFix从入门到放弃 AndFix从放弃到捡起 另外提供了些许资料，有兴趣的可以看看 资料Android热更新实现原理各大热补丁方案分析和比较 安卓App热补丁动态修复技术介绍]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>HotFix</tag>
        <tag>AndFix</tag>
        <tag>Nuwa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章 创建和销毁对象]]></title>
    <url>%2F%E7%AC%AC2%E7%AB%A0-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[第2章 创建和销毁对象何时以及如何创建对象,何时以及如何避免创建对象如何确保适时销毁,如何管理对象销毁前必要的清理 第1条 考虑用静态工厂方法代替构造器静态工厂方法是一个返回类的实例的静态方法,对它其实只是一个普通的静态方法而已,需要注意的是它与设计模式中的工厂方法不同,不要弄混淆了 Java源码中的例子:123public static Boolean valueOf(boolean b)&#123; return b?Boolean.TRUE:Boolean.FALSE;&#125; 优势列举静态工厂方法与构造器相比,有哪些优势 静态工厂方法有名称构造方法没有名称,给静态工厂取一个适当的方法名称会更易于阅读,也更易于客户端使用. 特别是在面对有多个参数或者多个构造方法的类的时候,会让客户端不知道如何选择构造方法(自行脑补一个大写的懵B). 不必在每次调用它们的时候都创建一个新对象我们知道构造方法每次都会创建一个新的实例,而当我们需要避免重复创建不必要的对象(或者不可变的类)时通过构造方法去做是做不到的,而静态方法可以为重复的调用返回相同的对象(比如返回的对象需要是一个单例) 它们可以返回原返回类型的任何子类型的对象构造方法只能返回类本身,而静态方法可以返回它的子类,利用多态的特性使得静态方法更加灵活比如Executors类的各种newxxx方法返回ExecutorService的子类 在创建参数化类型实例的时候,它们使代码变得更加简洁调用参数化构造器时,即使类型参数很明显也必须指明.书中列举了实例化HashMap的例子:1Map&lt;String,List&lt;String&gt;&gt;m = new HashMap&lt;Stirng,List&lt;String&gt;&gt;(); 如果用静态工厂可以这么写:123public static &lt;K,V&gt;HashMap&lt;K,V&gt;newInstance()&#123; reutrn new HashMap&lt;K,V&gt;();&#125; 想想以前也确实烦这些类型指定,一写一长串,但是现在(Java1.7)已经实现了类型推导,所以其实也没那么复杂了. 劣势静态工厂方法的劣势 类如果不含公有的或者受保护的构造器,就不能被子类化它们与其他的静态方法实际上没有任何区别确实,静态方法真的只是一个静态的方法而已,如果文档上不提到创建该类的实例可以使用静态方法的时候,很容易被忽略 所以能我们需要遵守一定的命名习惯: 静态方法推荐的命名名称 valueOf 返回的实例与参数具有相同的值,一般用于类型转换(如String Boolean Double等等) of valueOf的简洁代替 getInstance 返回的实例工具参数而定,对于单例,则一般没有参数,并且每次返回的都是同一个实例 newInstance 每次返回一个新的实例 getType newType 不能很好的扩展到大量的可选参数当参数非常多的时候静态方法的可读性,维护性等就非常差了,这个后面会说 实际运用现在在我们新建一个Fragment的时候,AS会自动生成一个newInstance(String ,String )的一个方法,这个就是静态工厂方法了,可见官方也推荐我们使用静态工厂方法. 另外Java源码中也有非常多的静态工厂方法的运用,比如上面提及的Executors,自己去体会~ 小结静态工厂方法与构造器各有优势,不过一般来说静态工厂通常更加合适,所以以后多考虑使用静态工厂吧. 第2条 遇到多个构造器参数时要考虑用构建器(Builder)当实例化一个类时有很多可选参数的时候,我们或许会写很多不同参数的构造方法,可读性会非常差,并且客户端也不知道在什么时候用什么构造器,这是非常非常糟糕的,同样静态方工厂也不能避免,这个时候我们需要用到构建器,也即设计模式里的Builder模式 Builder模式非常常见了,列举个列子就过了: 12345AlertDialog dialog = new AlertDialog.Builder(this) .setCancelable(true) //...各种可选参数 想要什么设置什么 .setMessage("Builder模式") .create(); Builder模式虽然能解决多参数遇到的问题,但是它也有缺点:为了创建对象,我们必须先创建一个Builder,这是一个多余的开销,虽然开销并不明显,但确实存在. 小结当有多个参数的时候,Builder模式是非常不错的选择. 第3条 用私有构造器或者枚举类型强化Singleton属性所谓Singleton即单例,指仅仅被实例化一次的类,这一条与单例息息相关. 私有构造器强化写过单例的一定知道,构造器一定要私有,否则别人随便new,怎么保证单例呢? 书中还讲到了单例如何防反射,防反序列化,这里就不提了 枚举强化java 1.5 版本之后,单例多了一个实现方法(包含单个元素的枚举类型):1234public enum Elvis&#123; INSTANCE; public void leaveTheBuilding()&#123;...&#125;&#125; 优势: 无偿提供序列化机制 绝对防止多次实例化 防反射 简洁 书中说:单元素的枚举类型已经成为实现Singleton的最佳方法,可惜的是我没在实际中用过,也没见过这种实现方式. 小结单例有很多实现方式,也是不容易的~ 第4条 通过私有构造器强化不可实例化的能力首先理解什么是不可实例化?不可实例化是指只包含静态方法和静态域的类比如BitmapUtil等各种Utils,它们包含各种静态方法,但是实际上我们不会也不需要去实例化它! 静态域(static-field) 比如:` public static Object obj` 既然工具类不希望被实例化,那么如何做呢? 提供一个私有构造器,并在里面抛出异常即可 eg: 123456public class Util&#123; private Util&#123; // Suppress default constructor for noninstantiability throw new AssertionError(); &#125;&#125; 相信都会感觉这多此一举,谁tm没事去实例化工具类啊,以前我也这么觉得,直到我的膝盖中了… 偶不,直到我在优秀的库中看到这写法,比如RxJava中的Subscriptions类: 12345public final class Subscriptions &#123; private Subscriptions() &#123; throw new IllegalStateException("No instances!"); &#125;&#125; 又如Jake大神的RxBinding中各种RxXXXX也是如此： 123private RxAppBarLayout() &#123; throw new AssertionError("No instances."); &#125; 优秀的项目，细节处理都非常优秀 小结有时候有些东西非常有道理,只是自己太弱小,悟不到而已,虚心学习,keep growing PS: EffectiveJava是本好书,RxJava是个优秀的库,Jake是真大神！！ 第5条 避免创建不必要的对象一般的讲,最后能重用对象而不是在每次需要的时候创建一个相同功能的新对象.另外对于一个不可变的对象(immutable 后面会讲),它始终可以被重用. 作者举了几个例子来说明: 创建String实例用String s = &quot;stringette&quot;;替代String s = new String(&quot;stringette&quot;)因为后者的参数其实就是一个实例,每一次调用都会多创建一个没用的对象. Boolean12public static final Boolean TRUE = new Boolean(true);public static final Boolean FALSE = new Boolean(false); Boolean.valueOf()方法重用了FALSE和TRUE来避免重复创建相同功能的对象 自动装箱autoboxing自动装箱允许我们将基本类型和装箱基本类型(Boxed Primitive Type)混用,按需自动装箱和拆箱 它们俩之间性能是有明显的差别的(基本类型更优) eg: 1234567public static void main(String[] args)&#123; Long sum = 0L; for(long i=0;i&lt;Integer.MAX_VALUE;i++)&#123; sum += i; &#125; System.out.println(sum);&#125; sum 的类型为Long,这样会比long多创建约2的31次方的Long实例,影响性能,所需时间大约是long的6倍多,非常可怕啊 so,记住,优先使用基本类型! PS 这里要说的不是创建对象非常昂贵,因为小对象的创建和回收是非常廉价的 对象池(object pool)维护对象池来避免创建对象只针对非常重量级的对象,如数据库连接池 Android中对象池有很多,如Message类,又如Glide中的Bitmap池 对象池的缺点 代码更乱 涉及到回收、重用必然会增加许多代码 增加内存占用,损害性能 小结当需要重用的时候,就不要创建 第6条 消除过期的对象引用首先需要明确,Java即使有GC,我们依然要自己考虑内存管理的事情. 当一个数组扩容后又缩减,比如size从0-&gt;200-&gt;100(一个栈先增长,后收缩),那么元素的index&gt;=100的那些元素(被pop掉的)都算是过期元素,那些引用就是过期引用(永远不会再被解除的引用) 过期引用导致了内存泄露 虽然对于自己来说pop掉的元素我们不会去用,但是由于过期引用的存在,GC并不会去回收它们,所以需要我们手动清空这些引用. eg: 123456public Object pop()&#123; if(size==0) throw new EmptyStackException(); Object result = elements[--size]; elements[size] = null; //Eliminate obsolete reference return result;&#125; PS:书中还提到了 *磁盘交换*(Disk Paging)--[wiki](https://en.wikipedia.org/wiki/Paging) 备注:*[虚拟内存](https://en.wikipedia.org/wiki/Virtual_memory)* 第7条 避免使用终结方法终结方法:finalizer (老实说,这个真没用过) 没看懂,记录一些点.. 终结方法会导致行为不稳定,降低性能,以及可移植性问题 不能保证会被及时地执行,而且根本不保证它们会被执行(这..好过分..) 还是没看懂,被自己蠢哭了.. 本系列作品所有的读书笔记第2章 创建和销毁对象第3章 对于所有对象都通用的方法第4章 类和接口]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>EffectiveJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我又开始更新博客了,棒]]></title>
    <url>%2F%E6%88%91%E5%8F%88%E5%BC%80%E5%A7%8B%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E4%BA%86%2C%E6%A3%92%2F</url>
    <content type="text"><![CDATA[公司给配置了电脑,所以每天用的都是公司的电脑,很多笔记文章也都放github了 而博客在自己的电脑上,导致博客长时间没更新了,也有很多以前的TODO都没有完成 去NexT官网看了,又更新了好多东西 比如给博客新增了阅读次数,好棒,添加了一下该功能~ 为了什么呢?明明没什么人看—-为了打自己脸 呵呵,开心就好 恩 我又更博客了,这是个好消息]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git规范]]></title>
    <url>%2FGit%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[分支模型每个项目必须要有master、develop分支。每个开发人员拥有一个自己的分支，如czn、mrfu。 master 分支master 分支只能存在release版本的代码，并需要对每个release打对应的tag。 develop 分支develop 由master分支检出，它作用主要是日常开发合并代码，并与master分支做交互。当参与开发的人员较多时，可指定一个人管理develop分支，专门负责合并代码，便于管理，避免多人同时使用develop分支而出现问题。 另外当功能开发完毕后，代码合并入develop分支，测试完成通过后，merge到master分支，并在master上打tag。 开发人员自己的分支开发人员自己的分支，由develop分支检出，是自己负责的功能分支的上游 工作流程Feature （新需求开发）当有新需求需要开发时： 每个开发人员在自己的分支上检出一个新的feature分支，如在czn上检出feature_search分支 在新的feature分支上进行开发 新功能开发完毕后合并到自己的分支 所有人员的分支合并到develop分支，并进行测试 测试通过后合并到master，并打tag Hotfix （紧急修复bug）当有紧急bug需要修复时 从master 拉分支hotfix_xxx 修复完毕后合并到develop分支 测试完毕后合并到master分支，并打tag 小结分支模型已经工作流程大约如图所示： Gitflowgitflow是git的一个辅助工具，可以简化我们新建分支，合并分支，删除分支的操作，也可以减少人工误操作而出错的概率 举个例子：新功能能开发，使用gitflow之前： 123456git checkout czngit checkout -b feature_search...developing...git checkout czngit merge feature_searchgit branch -d feature_search 使用gitflow之后： 123git flow feature start search...developing...git flow feature finish search 是不是省去了很多繁琐的操作？ gitflow 的功能不止如此~ gitflow虽好，但是考虑到大家刚开始使用git，需要熟悉git以及git命令，所以它现在不是强制的，如果有兴趣或者你也懒得敲那么多命令的话，建议看看 git-flow 备忘清单 PS: 事实上git最开始是没有gitflow的，它是用户实际经验的总结，so，希望我们团队最终能拥有最适合我们自己的gitflowgitf 最后规范是死的，人是活的，上诉所说都是比较理想化的，实际情况可能更加复杂，大家可以根据实际情况调整。 如果有疑问或更好的建议，欢迎反馈~~~]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git分享]]></title>
    <url>%2FGit%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[控制版本系统(VCS)版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统 集中化控制系统(CVCS)集中化控制系统都有一个单一的集中管理的服务器,保存所有文件的修订版本,客户端通过这台服务器获取文件或提交更新. 缺点很明显,中央服务器是个中心,一旦它出了问题就会影响整个系统. 中央服务器单点故障,如果服务器一挂,那么整个系统就挂了,无法工作 甚至,中央服务器磁盘故障,很可能导致数据丢失,丢失所有历史更改记录等重要信息. 分布式版本控制系统(DVCS)客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份 Git–控制版本之神简史作者,大神 Linus Torvalds 优点: 速度 简单的设计 对非线性开发模式的强力支持（允许上千个并行开发的分支） 完全分布式 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量） Git常用命令configgit config –global 12git config --global user.name "alan"git config --global user.email alancheen06@gmail.com git config --list 查看配置列表 initgit init用来初始化项目 它会创建一个.git目录,它包含所有初始化git的所有文件 clone12git clone urlgit clone url name #重命名成name 文件的状态接下去的命令跟 adduntracked===&gt;staged 12git add filegit add . staged===&gt;untracked 1git reset HEAD file commit123git commit -m "init"git commit -a -m "init"git commit -am "init" branch创建分支1git branch branchname PS:当init一个仓库时,master需要先commit一遍才能新建其他分支,否则会得到一个错误fatal: Not a valid object name:&#39;master&#39;. 切换分支1git checkout branchname 创建并切换分支1git checkout -b branchname 查看分支1git branch -r -a -l 删除分支12git branch -d banchname #删除本地分支 git branch --delete branchname #删除远程分支 远程协作pull1git pull origin master push1git push origin master 其他git log git reflog git reset git stash/pop git help add …. gitignoregitflowiTerm+oh my zshGit学习资料推荐git学习资料太多,但是鱼龙混杂,很多都是抄来抄去,错误百出,这里收集一些优秀的资料. GitPro2内容很多,很详细,堪称权威,而且还有中文版,还有pdf等下载,一定要看看. git-简明指南(很棒)非常棒的指南,极力推荐 githug一个git的游戏,现在一共有54个关卡,从init开始,让你在玩的过程中学习git,挺有意思 learnGitBranching又是一个学习git的游戏,不过这个是针对分支的游戏,非常棒~非常推荐]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git分支常用命令]]></title>
    <url>%2FGit%E5%88%86%E6%94%AF%2F</url>
    <content type="text"><![CDATA[创建分支git branch &lt;branchname&gt; git checkout -b &lt;branchname&gt; 创建并检出到新分支 删除分支删除本地分支git branch -d branchname 删除远程分支git 1.7之前 :git push origin :branchname 注意origin后面有个空格,而:后面不能跟空格,什么鬼语法!还好git 1.7之后可用 :git push origin --delete branchname,这个好容易理解 查看分支git branch [options] -r 查看远程分支 -l 查看本地分支 注意当init一个仓库时,master需要先commit一遍才能新建其他分支,否则会得到一个错误fatal: Not a valid object name: &#39;master&#39;.]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android屏幕适配]]></title>
    <url>%2FAndroid%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[屏幕适配Android设备众多,虽然Android会自动缩放,重新定尺寸来适应,但是you should make the effort to optimize your application for different screen sizes and densities 概念 Screen size 屏幕大小(屏幕的对角线长度,单位为英寸,1英寸=2.54cm),按屏幕大小可分:small, normal, large, and extra-large. Screen density(dpi) 屏幕密度,某个尺寸区域内的像素密度(跟数学题求密度差不多,即面积/数量),它通常就是dpi (dots per inch),根据屏幕密度可分为low, medium, high, extra-high, extra-extra-high, and extra-extra-extra-high.,与我们项目中的mdpi,hdpi,xhdpi等对应,可以看出x是extra的缩写,h是high的缩写~ Resolution分辨率,整个屏幕所包含的物理像素,如经常听到的10801920,480800,屏幕大小一定,分辨率越高越清晰,这相信大家都知道 Density-independent pixel (dp/dip)密度独立像素,我们布局的时候最常用也最推荐的单位就是这个了! Android按160dpi为标准,在160dpi的设备中,1dp=1px,由此也可以得知dp与px的换算公式:px = dp * (dpi / 160) 非常值得注意的是,在Android中有个DisplayMetrics类,它存放了部分displayer的信息,当我们在PX与DP之间转换时,我们可能已经见到过如下方法: 1234567891011public static int dip2px(Context context, float dpValue)&#123; final float density = context.getResources().getDisplayMetrics().density; return (int) (dpValue * scale + 0.5f);&#125;public static int px2dip(Context context, float pxValue)&#123; final float density = context.getResources().getDisplayMetrics().density; return (int) (pxValue / scale + 0.5f);&#125; 注意,代码中的density与我们之前所说的screen density不同,这个density是 (screen density)/160 的值!!!所以把它代入到之前的换算公式中去就得到了px=dp*density,那么为什么代码中出现了0.5f呢?那是为了避免精度损失. PS:如果你需要知道当前设备的dpi,可以用metrics.densityDpi来获取,另外其实Android系统还有一个类提供了各种单位之间的转换–&gt;TypedValue sw/sh/w/hsw,sh是3.2开始出现的限定词:如: layout-sw600dp, values-sw600dp swdp 表示smallestwidth,当最下宽度大于N时采用,如sw600dp表示设备的宽度大于600dp时采用 shdp 表示smallestheight PS: sw,sh不会随着屏幕变化而变化, wdp,hdp 与之前的不同,它们随着屏幕的变化而变化的 值得一说的是,并不推荐用这种方式! 资料Supporting Multiple Screens]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>屏幕适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android MutilDex解决方案]]></title>
    <url>%2FAndroid-MutilDex%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[前言最近也遇到了mutildex的问题,原因是一个dex.class不能超过65536,根据官网的指示Building Apps with Over 65K Methods 解决了,记录一下步骤 step1添加依赖 compile &#39;com.android.support:multidex:1.0.0&#39; step2配置app的build.gradle,新增multiDexEnabled true如下: 123defaultConfig &#123; multiDexEnabled true&#125; step3让App继承MultiDexApplication step4重写App的attachBaseContext方法如下:12345@Overrideprotected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); MultiDex.install(this); &#125; 获取当前项目的方法数 现在有个gradle插件可以检测当前项目所占的总方法数–&gt;dexcount,使用很简单. step1 配置app/build.gradle12345678910buildscript &#123; repositories &#123; mavenCentral() // or jcenter() &#125; dependencies &#123; classpath 'com.getkeepsafe.dexcount:dexcount-gradle-plugin:0.3.1' &#125;&#125;apply plugin: 'com.getkeepsafe.dexcount' step2 build项目即可编译项目,如./gradlew assembleDebug就可以得知结果了:1234567:app:assembleInternalDebugTotal methods in app-Internal-debug.apk: 58359Total fields in app-Internal-debug.apk: 31843Methods remaining in app-Internal-debug.apk: 7176Fields remaining in app-Internal-debug.apk: 33692BUILD SUCCESSFUL 后续后来另外一个项目也到了需要使用mutildex的情况,然而当我配置完后,发现出现了另外的问题,java.lang.OutOfMemoryError: GC overhead limit exceeded,仔细检查,发现并没有配置错误,于是内心是崩溃的… 搜索之后,发现这里有个讨论—&gt;stackoverflow,最后添加了个配置到app/build.gradle文件即可 123dexOptions &#123; javaMaxHeapSize "4g" &#125; 呵呵,又学了一招!~~ More 艺术探索中也有提到,可以看看 Android 使用android-support-multidex解决Dex超出方法数的限制问题,让你的应用不再爆棚]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Mutildex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom学习笔记]]></title>
    <url>%2FAtom%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[#Atom官网 常用快捷键 cmd+shift+p 打开命令窗口,可以运行各种菜单功能 cmd+t 快速多文件切换 ctrl+g 文件内跳转到指定行 cmd+f 文件内查找和替换 cmd+shift+f 多文件查找和替换 cmd+[ 对选中内容向左缩进 cmd+] 对选中中内容向右缩进 ctrl+shift+m 开关cmddown实时预览 cmd+w 关闭tab 插件推荐资料]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[岁月是一场有去无回的旅行]]></title>
    <url>%2F%E5%B2%81%E6%9C%88%E6%98%AF%E4%B8%80%E5%9C%BA%E6%9C%89%E5%8E%BB%E6%97%A0%E5%9B%9E%E7%9A%84%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[时间是让人猝不及防的东西谁能想到原来在学校打着LOL,学的是ps,ai,3dmax本该做个美工的我,竟然学了一年多的Android了. 岁月是一场有去无回的旅行,好的坏的都是风景 坏: 遇到坏房东,人在异乡,尝到了无家可归的滋味. 加班严重,带来很多负面影响,如身子变差,没时间陪女朋友,没时间常回家看看. 外公去世,这世界又少了一个最疼爱我的人. 好: 跟女朋友依然相爱,并没有毕业分 学习android虽然坎坎坷坷,但是一路坚持过来了,度过了小白的阶段 为Android开源贡献了一点绵薄之力 参加了杭州GDG,杭州线下聚会 认识了许许多多的良师益友,志同道合的好友 排名不分先后:教父,凯哥,Ail,晓峰,代码家,马琳,医生,刚哥,百万,梁飞,Asha,老穆,泡在网上的日子,蛤蟆,T大,Simple,lightsky,笔记,凯子哥,信,邓子,黑燕,Nick,MrFu,杨辉,轻微,小龙,启超,菲菲,小黑屋干货群,github交流群,艺术探索群等群友,当然还有自己KeepGrowing的群友,不一一列举了 走过的那些曲折,原来留下的都是真的 感谢我女朋友的陪伴,感谢各路朋友的支持,2016有很多很多想做的事情,希望我能够顺利达成心愿.]]></content>
      <categories>
        <category>人生路上</category>
      </categories>
      <tags>
        <tag>2015总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令之Tag]]></title>
    <url>%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B9%8BTag%2F</url>
    <content type="text"><![CDATA[标签 tag标签的作用不言而喻,一般当我们release一个版本的时候打个tag. 查看标签 查看已有标签git tag 特定的搜索模式列出符合条件的标签git tag -l &#39;v1.4.2.*&#39; 查看指定taggit show [tagname] 新建tagGit 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated） 一般用包含信息的-a: $ git tag -a v1.4 -m &#39;这里写些信息&#39; 给指定的commitId 打taggit tag -a [tagname] -m [msg] commitid eg.git tag -a v0.1 -m &quot;add tag v0.1&quot; 6c46c1 push tagtag需要单独push git push origin [tagname] git push --tags OK,常用的tag命令就这样! 资料推荐Pro Git]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javadoc_generation_failed]]></title>
    <url>%2FJavadoc-generation-failed%2F</url>
    <content type="text"><![CDATA[今天在升级Utils,把Utils升级,上传到JCenter的时候遇到了一个错误: 搜索后发现原因是代码里包含了Html格式的代码,我表示很疑惑,因为我并没有写过Html格式的代码呀,我写的是Java,怎么会有这个错误呢? 然后百般寻找,发现格式化代码的时候,AS自动生成了一个&lt;/p&gt;的标签,删除后就可以了!!! 又长见识了!~~ 资料http://stackoverflow.com/questions/26552279/gradle-build-fails-with-javadoc-nullpointerexception]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>jcenter</tag>
        <tag>javadoc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推特分享后续]]></title>
    <url>%2F%E6%8E%A8%E7%89%B9%E5%88%86%E4%BA%AB%E5%90%8E%E7%BB%AD%2F</url>
    <content type="text"><![CDATA[前言之前写过一篇做Twitter登录与分享功能的,那时候分享是通过调用客户端的,然而现在需要改成调用Twitter的API实现分享,诶,相当于之前做的都白做了,心里万头草泥马奔腾啊. 资料media/uploadstatuses/update]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>todo</tag>
        <tag>Twitter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glide]]></title>
    <url>%2FGlide%2F</url>
    <content type="text"><![CDATA[GlideAn image loading and caching library for Android focused on smooth scrolling Glide专注于顺畅滑动的一个图片加载缓存库. 12compile 'com.github.bumptech.glide:glide:3.6.1'compile 'com.android.support:support-v4:19.1.0' 基本使用与UIL的使用方式不同,Glide的API与Picasso类似,链式调用,非常舒服.123456Glide.with(myFragment) .load(url) .centerCrop() .placeholder(R.drawable.loading_spinner) .crossFade() .into(myImageView); 其他方法混淆12345-keep public class * implements com.bumptech.glide.module.GlideModule-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** &#123; **[] $VALUES; public *;&#125; 第一句是自定义GlideModule添加的混淆,具体可以看这里 优缺点任何一款框架都有自己的优缺点,Glide也不例外. 优点: 功能强大,能获取解析并显示视频预览图片(video stills?),图片,GIF. 灵活、易用的API 自带淡入淡出动画,比较美观 可以与OKHttp Volley结合 一般使用无需配置,立即上手 响应Activity以及Fragment的生命周期,在stop时停止加载(已经启动的任务不能停止),onStart时继续加载 Item重用时会自动取消图片加载(所以滑动的时候才那么流畅) 解决列表加载图片错乱问题 缺点: 2882个方法相比较与UIL(1202)来说多了好多 配置项少,而且配置麻烦,不像UIL那么多而方便 setTag方法被占用 小结:正如Glide的口号所说,Glide对列表滑动做了很多优化,所以使得Glide在列表滑动的时候表现非常优秀. 推荐资料Google推荐的图片加载库Glide介绍android学习之路(一)–Glide学习Glide的图片内存优化]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Glide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ContentProvider的authorities属性]]></title>
    <url>%2FContentProvider%2F</url>
    <content type="text"><![CDATA[ContentProviderauthorities属性的唯一性关于ContentProvider,一直都了解不多,最近遇到个问题.我们两个App都用了一个第三方库,当我想同时安装我们的App时,遇到了一个错误:INSTALL FAILED CONFLICTING PROVIDER,一直安装失败. 搜索了一遍后在SF上找到了答案 原来android:authorities must be unique. To avoid conflicts, authority names should use a Java-style naming convention (such ascom.example.provider.cartoonprovider). Typically, it&apos;s the name of the ContentProvider subclass that implements the provider 在xml里配置authorities属性必须唯一,所以当我们两个app配置得一样时,就会失败,于是修改一下这个属性即可. 资料manifest/provider-element.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ContentProvider</tag>
        <tag>authorities</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间复杂度]]></title>
    <url>%2F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[时间复杂度看了时间复杂度的故事做了点摘抄. 线性如果它处理 N 个元素求和所花的时间是 T，那么它处理 N 2 个元素的和所花的时间就是 T 2。所以随着 N 变大，时间 T 的变大是与 N 呈「线性」关系的。 在时间复杂度中，我们用 O(N) 表示这种「线性」时间复杂度。 对数对于类似二分法来说,输入的元素个数虽然翻倍，但是程序运行所花的时间却只增加了 1，我们把这种时间复杂度要叫「对数」时间复杂度，用 O(logN) 来表示。 其他复杂度 「常数」时间复杂度，例如返回一个有序数组中的最小数，这个数因为始终在第一个位置，所以就不会受到数组大小的影响，无论数组多大，我们都可以在一个固定的时间返回结果。 「线性对数」时间复杂度，即 O(N*logN) ，这个复杂度比较常见，因为常见的高效的排序算法，都是这个时间复杂度，比如 快速排序，堆排序，归并排序等。 资料时间复杂度的故事]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中的IPC机制]]></title>
    <url>%2FAndroid%E4%B8%AD%E7%9A%84IPC%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言 关于ShareUID的疑问在Android的清单文件里可以给app配置sharedUserId属性 android:sharedUserId The name of a Linux user ID that will be shared with other applications. By default, Android assigns each application its own unique user ID. However, if this attribute is set to the same value for two or more applications, they will all share the same ID — provided that they are also signed by the same certificate. Application with the same user ID can access each other’s data and, if desired, run in the same process. 资料manifest-shareuid]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发艺术探索</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ADP视频学习笔记]]></title>
    <url>%2FADP%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ADPADP全称 Android Development Patterns,google出的视频,口号是Build better apps本文记录我该系列的学习笔记. Protecting Implicit Intents with Runtime Checks 01问题:当使用隐式Intent去启动activity时,如果没有匹配到符合条件的Activity会crash. 解决:我们需要使用Intent的resolveActivity去判断是否匹配到了Activity,匹配到才去start: 123if (intent.resolveActivity(getPackageManager()) != null) &#123; startActivity(intent);&#125; 完整的例子可以看看以前写的Android调用手机浏览器的正确方式 ,方法是一样的. Using NotificationCompat for Beautiful Notifications 02使用 NotificationCompat 来构建通知有一些小差别,注意最后的from 增加辨识度 样式 扩展通知 接下去是一些Wear auto car的了 WearableExtender Wear your best AndroidAuto&amp;CarExtender Runtime Permissions in Android 6.0 Marshmallow6.0新增的运行时权限流程: 在实际开发中,我们需要先判断是否是6.0,如果是就需要去检测是否有这个权限,如果没有,则去请求权限.另外如果被拒绝过,还可以选择向用户展示我们为什么需要权限,再次请求等等~ 这边讲得有些多了,其实看6.0的官网资料即可. check the platform check the permission ADP018 Navigation DrawersOpen and Close Events1234567891011public void onDrawerClose(View view)&#123; super.onDrawerClosed(view); getActionBar.setTitle(mTitle); invalidateOptionsMenu();//&#125;public void onDrawerOpened(View view)&#123; super.onDrawerOpened(view); getActionBar().setTitle(mDrawerTitle); invalidateOptionsMenu();&#125; 资料优酷]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mou备忘]]></title>
    <url>%2FMou%2F</url>
    <content type="text"><![CDATA[MouMou作为一款免费的md编辑器优秀得让人难以置信,用它来写笔记写文章速度感人~可以说它已经融入我的生活. 在此记录一下Mou的md语法,作为备忘 OverviewMou, the missing Markdown editor for web developers. SyntaxStrong and Emphasizestrong or strong ( Cmd + B ) emphasize or emphasize ( Cmd + I ) Sometimes I want a lot of text to be bold.Like, seriously, a LOT of text Blockquotes Right angle brackets &gt; are used for block quotes. Links and EmailAn email &#101;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#x40;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#109; link. Simple inline link http://chenluois.com, another inline link Smaller, one more inline link with title Resize. A reference style link. Input id, then anywhere in the doc, define the link with corresponding id: Titles ( or called tool tips ) in the links are optional. ImagesAn inline image , title is optional. A reference style image. Inline code and Block codeInline code are surround by backtick key. To create a block code: Indent each line by at least 1 tab, or 4 spaces. var Mou = exactlyTheAppIwant; Ordered ListsOrdered lists are created using “1.” + Space: Ordered list item Ordered list item Ordered list item Unordered ListsUnordered list are created using “*” + Space: Unordered list item Unordered list item Unordered list item Or using “-“ + Space: Unordered list item Unordered list item Unordered list item Hard LinebreakEnd a line with two or more spaces will create a hard linebreak, called &lt;br /&gt; in HTML. ( Control + Return )Above line ended with 2 spaces. Horizontal RulesThree or more asterisks or dashes: HeadersSetext-style: This is H1This is H2atx-style: This is H1This is H2This is H3This is H4This is H5This is H6Extra SyntaxFootnotesFootnotes work mostly like reference-style links. A footnote is made of two things: a marker in the text that will become a superscript number; a footnote definition that will be placed in a list of footnotes at the end of the document. A footnote looks like this: That’s some text with a footnote.[^1] [^1]: And that’s the footnote. StrikethroughWrap with 2 tilde characters: Strikethrough Fenced Code BlocksStart with a line containing 3 or more backticks, and ends with the first line with the same number of backticks: 123Fenced code blocks are like Stardard Markdown’s regular codeblocks, except that they’re not indented and instead rely ona start and end fence lines to delimit the code block. TablesA simple table looks like this: First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell If you wish, you can add a leading and tailing pipe to each line of the table: First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell Specify alignment for each column by adding colons to separator lines: First Header Second Header Third Header Left Center Right Left Center Right # ShortcutsView Toggle live preview: Shift + Cmd + I Toggle Words Counter: Shift + Cmd + W Toggle Transparent: Shift + Cmd + T Toggle Floating: Shift + Cmd + F Left/Right = 1/1: Cmd + 0 Left/Right = 3/1: Cmd + + Left/Right = 1/3: Cmd + - Toggle Writing orientation: Cmd + L Toggle fullscreen: Control + Cmd + F Actions Copy HTML: Option + Cmd + C Strong: Select text, Cmd + B Emphasize: Select text, Cmd + I Inline Code: Select text, Cmd + K Strikethrough: Select text, Cmd + U Link: Select text, Control + Shift + L Image: Select text, Control + Shift + I Select Word: Control + Option + W Select Line: Shift + Cmd + L Select All: Cmd + A Deselect All: Cmd + D Convert to Uppercase: Select text, Control + U Convert to Lowercase: Select text, Control + Shift + U Convert to Titlecase: Select text, Control + Option + U Convert to List: Select lines, Control + L Convert to Blockquote: Select lines, Control + Q Convert to H1: Cmd + 1 Convert to H2: Cmd + 2 Convert to H3: Cmd + 3 Convert to H4: Cmd + 4 Convert to H5: Cmd + 5 Convert to H6: Cmd + 6 Convert Spaces to Tabs: Control + [ Convert Tabs to Spaces: Control + ] Insert Current Date: Control + Shift + 1 Insert Current Time: Control + Shift + 2 Insert entity &lt;: Control + Shift + , Insert entity &gt;: Control + Shift + . Insert entity &amp;: Control + Shift + 7 Insert entity Space: Control + Shift + Space Insert Scriptogr.am Header: Control + Shift + G Shift Line Left: Select lines, Cmd + [ Shift Line Right: Select lines, Cmd + ] New Line: Cmd + Return Comment: Cmd + / Hard Linebreak: Control + Return Editors Auto complete current word: Esc Find: Cmd + F Close find bar: Esc Post Post on Scriptogr.am: Control + Shift + S Post on Tumblr: Control + Shift + T Export Export HTML: Option + Cmd + E Export PDF: Option + Cmd + P And more?Don’t forget to check Preferences, lots of useful options are there. Follow @Mou on Twitter for the latest news. For feedback, use the menu Help - Send Feedback]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>备忘</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttp和Retrofit2学习笔记]]></title>
    <url>%2FOkHttp%E5%92%8CRetrofit2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 OkHttp资料 github wiki OkHttp-完全解析 OkHttp-Https Retrofit添加日志123456789HttpLoggingInterceptor logging = new HttpLoggingInterceptor(); // set your desired log levellogging.setLevel(Level.BODY);OkHttpClient httpClient = new OkHttpClient(); // add your other interceptors …// add logging as last interceptorhttpClient.interceptors().add(logging); // &lt;-- this is the important line! 参考自这里 资料用 Retrofit 2 简化 HTTP 请求 Retrofit 2.0：有史以来最大的改进Retrofit 2 — Upgrade Guide from 1.9 Retrofit 2 — Log Requests and ResponsesLove-working-with-APIS-on-AndroidRetrofit2 源码解析]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Retrofit</tag>
        <tag>OkHttp</tag>
        <tag>开源项目使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android给apk签名那点事]]></title>
    <url>%2FAndroid%E7%BB%99apk%E7%AD%BE%E5%90%8D%E9%82%A3%E7%82%B9%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[前言 前几天老大的6p一打开应用就奔溃,于是与让我给应用适配6.0.后来最后发布内测版本后,发现又是打开立即奔溃,在确定我代码push之后,找了一下原因,最终发现是梆梆加固搞的鬼. 然后老大又让我去尝试其他加固方案,又因为加固后又需要重新加固,所以就有了这篇笔记. 签名签名是为了什么简单来说,签名可以保证我们的应用可以正常升级,并且不被别人覆盖.算是一个标识. 工具 keytool 是个密钥和证书管理工具,可以用来生成证书. jarsigner 工具利用密钥仓库中的信息来产生或校验 Java 存档 (JAR) 文件的数字签名 使用keytool生成证书:1keytool -genkey -keystore test.keystore -alias test -keyalg RSA -validity 10000 参数解释: -genkey 产生证书文件 -keystore 指定密钥库的.keystore文件中 -keyalg 指定密钥的算法,这里指定为RSA(非对称密钥算法) -validity 为证书有效天数，这里我们写的是10000天 -alias 产生别名 网上搜索到的生成证书的方法都尼玛是错的,都是误导人的,具体请看后续!!! 另外keytool还能查看信息: 1test keytool -list -keystore test.keystore 结果:12345678910➜ test keytool -list -keystore test.keystore输入密钥库口令:密钥库类型: JKS密钥库提供方: SUN您的密钥库包含 1 个条目test.keystore, 2015-11-20, PrivateKeyEntry,证书指纹 (SHA1): 21:94:9F:48:7D:38:EE:5A:63:16:8F:46:1B:6E:73:89:53:7D:7B:5C 签名可以使用jarsigner 来签名,例子如下: 1jarsigner -verbose -keystore test.keystore -signedjar -signed.apk unsigned.apk 'test.keystore' 参数说明: -verbose：指定生成详细输出 -keystore：指定数字证书存储路径 -signedjar：该选项的三个参数为 签名后的apk包 未签名的apk包 数字证书别名(注意顺序) (原来用的t.apk,发现不利于理解,于是后面改名了) 遇到坑了,找不到xxx证书链什么鬼!后来搜索了很久之后才看到了一句要跟别名一样,我就在想我原来用的代码是这样的:1keytool -genkey -keystore test.keystore -alias test.keystore -keyalg RSA -validity 10000 诶?好像没问题啊,test.keystore的别名test.keystore,是一样的啊,后来想想不对啊,test.keystore的后缀不应该加入上去吧,于是去掉keystore后再次重新生成一遍1keytool -genkey -keystore test.keystore -alias test -keyalg RSA -validity 10000 然后再次执行签名:1jarsigner -verbose -keystore test.keystore -signedjar signed.apk t.apk 'test' 成功了!~So happy!!~~ 不过其实后面还顺带了一个警告:未提供 -tsa 或 -tsacert, 此 jar 没有时间戳。如果没有时间戳, 则在签名者证书的到期日期 (2043-04-07) 或以后的任何撤销日期之后, 用户可能无法验证此 jar。想来似乎没什么,就没管了. 吐个槽:国内的有些文章真的很坑人,几篇错误的文章尼玛到处复制黏贴,到处都是,真是给跪了 debug.keystore的故事说点小插曲,小知识: AndroidStudio会自动生成一个默认的debug.keystore,它存放在~/.android/目录下. 如果一不小心删了(其实我是rm了它),只要重新run一遍debug版应(不指定signingConfig),AS会再次自动创建 它默认密码为 android 小结一个加固导致崩溃引发的血案~最终让我学会了如何用cmd来签名APK,来装逼,哦哈哈~~~新技能get!~ 后续–如何查看APK的签名呢? update 2016-01-13 将APK改成zip文件(其实APK就是带有签名的zip文件),然后解压,签名放在META-INF目录下名为CERT.RSA的文件里,通过命令行可以获取: 1keytool -printcert -file CERT.RSA 可以获得到信息如下:]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>APK加固</tag>
        <tag>签名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity的生命周期和启动模式]]></title>
    <url>%2FActivity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Android开发艺术探索笔记任玉刚所写,勘误 记录一些笔记 第1章Activity的生命周期和启动模式启动模式标准模式每次启动都会重新创建一个新的Activity SingleTop栈顶复用模式,如果当前任务栈的栈顶有该类型的Activity,那么不重新创建,该Activity的onNewIntent被调用. SingleTaskSingleTask是个特殊的SingleTop,它是栈复用,即栈内有该Activity就不会重新创建,同样的回调onNewIntent,并且它还有一个特性,那便是将在它顶部的所有Activity都pop掉.例如在同一个栈内ABCD,在D启动B–&gt;AB(CD被pop掉了) 注意:启动页面的launchMode不能设置为singleTask,不然打开应用后,按Home键回到桌面,再从桌面点击图标进入,应用会重新打开. SingleInstance资料]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发艺术探索</tag>
        <tag>读书笔记</tag>
        <tag>todo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我也开始面试人了]]></title>
    <url>%2F%E6%88%91%E4%B9%9F%E5%BC%80%E5%A7%8B%E9%9D%A2%E8%AF%95%E4%BA%BA%E4%BA%86%2F</url>
    <content type="text"><![CDATA[前言今天老大让我去面试,呵呵,入行1年多了,以前只有被别人面试的份,第一次面试,还是小紧张的. 第一个,两年的经验.一看两年的经验,比我多,怎么办?我尽量地往深入的地方问,但是结果答得非常模糊,快到了问什么什么不知道的境界.然后,开始问他的工作经历,几个问题下来,感觉他平时工作的态度就是遇到问题就百度,解决了就万幸,也不深入去了解.而且对新的知识一点都不了解,AndroidDesign,MaterialDesign什么都不了解. 反正,给我的感觉是:两年经验,就这水平? 第二个,一年,跟我同一届.原来在河南工作,技术不太行,感觉那边的技术比较落后,他说希望有大牛带,感觉看到我以前的样子了.人不错,但是基础太差,如果招进来,我会很累吧.. 第三个,1年半,原来是在北京,薪资10K,期望10-11K这个是我面第二个的时候老大面的,我半途进去旁听的,后来老大让我问一些技术类问题.看了简历,写了很多熟悉,比如什么面向对象思想啦,handler啦什么的想来基础应该是有的,但是当我问得稍微深入点的时候就不行了,要么不知道要么说不清楚,感觉还是不太够.. 面试收获暗爽了一把.但是老大说面试时要从他们那获取信息,学习自己不会的,而不是一味的问一些东西.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[厦门旅游计划]]></title>
    <url>%2F%E5%8E%A6%E9%97%A8%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[前言初步计划: 2015.11.4-11.8日 11.4号+11.5号白天交通 古荡-&gt;萧山机场 打的-&gt;武林门民航售票处(公交站) 15分一班 厦门高崎飞机场-&gt;码头 最优选择: t4候机楼站上车(空港快线)–&gt;邮轮中心码头 其他全部: 码头-&gt;鼓浪屿 船票 35元/人,往返都要检票!! 景点鼓浪屿,日光岩、菽庄花园、皓月园、郑成功纪念馆,西式别墅建筑群 PS: 可先买一份地图,需要买景点联票 100元/人 联票包括: 日光岩 菽庄花园(含钢琴博物馆) 皓月园 风琴博物馆 国际刻字艺术馆 PS:免费音乐 晚上7点30,鼓浪屿音乐厅免费音乐 吃特产 馅饼 猪肉铺 路线 攻略推荐的店：鼓浪屿海怪先生（龙头路266号）、林记鱼丸（泉州路54号）、黄胜记黄金香肉松店、龙头海蛎煎 十大别墅：八卦楼（俗称小白宫：鼓新路43号）、皇家花园（曾经的中国第一别墅：晃岩路25号）、海天堂构（厦门新天地：福建路38号）、黄荣远堂（一场赌博便易了主：福建路32号）、荣谷别墅（鼓浪屿别墅之王：旗山路5号）、杨家园（欧式建筑群：安海路4号）、林氏府（遭实验烧毁后重建：鹿礁路13号到15号）、金瓜楼（子孙满堂，后人遍布二十多地：泉州路99号）、番婆楼（尽人子之孝的典范：安海路36号）、汇丰银行公馆（行长住在悬崖之上：鼓新路57号） 5号,凌晨看日出 住宿: 记得到店有返现,66元! 联系方式: 11.5 下午-夜晚景点: 中山路,中华城步行街 攻略推荐的店：佳味再添小吃店、月华沙茶面（镇邦路78号）、大中路里脊肉串（大中路，南中广场对面）、大佳香姜母鸭 住宿: 厦门家和快捷酒店地址: 思明区厦禾路244号联系方式: 0592-2022177 11.6景点: 厦大,南普陀寺,炮台 推荐:厦大建筑群、芙蓉隧道、厦大高尔夫球场、厦大情人谷、厦大芙蓉湖畔咖啡厅 地点：厦门南普陀用时：2小时 地点：顶澳仔猫街（厦门大学西门）用时：2小时 地点：沙坡尾避风坞用时：1小时 攻略推荐的店：多吉甜甜圈（厦门市思明区沙坡大学路113号）、晴天见（特色冰淇淋）、喂道餐车（西式糕点） 11.7号景点: 环岛南路, 住宿:曾厝垵 苏林故事客栈豪华大床房 地址:厦门思明区曾厝垵56号房东联系方式: 18150107212 公交,到曾厝垵站下,4 5 分钟就可以到 交通:鼓浪屿/中山路/轮渡：乘坐29路→曾厝垵站下； 厦大/南普陀寺：厦大西村站→29/47/857路→曾厝垵站下 费用 交通: 来回机票 1506 住宿: 318+97+236 = 651; 其他:渡船 70?]]></content>
      <categories>
        <category>人生路上</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment学习笔记备忘]]></title>
    <url>%2FFragment%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%87%E5%BF%98%2F</url>
    <content type="text"><![CDATA[前言// todo 生命周期http://www.codeceo.com/article/android-fragment-circle.html ## 懒加载场景场景前提:Fragment里有个ViewPager,vp里有三个Fragment的情况.我需要的情况是,第一次加载的时候就第一页去请求数据,而其他两页不去请求直到滑动到该界面. 预备知识 public void setUserVisibleHint(boolean isVisibleToUser) isVisibleToUser代表fragment是否可见. 实践动手,先研究一下它在什么时候调用的 第一次加载即app刚启动,刚到这个界面PS:LiveFragment在第一个位置.12345678910111213D/ChildFragment: LiveFragment setUserVisibleHint() called with: isVisibleToUser = [false]D/ChildFragment: FollowFragment setUserVisibleHint() called with: isVisibleToUser = [false]D/ChildFragment: FansFragment setUserVisibleHint() called with: isVisibleToUser = [false]D/ChildFragment: LiveFragment onAttach:D/ChildFragment: LiveFragment setUserVisibleHint() called with: isVisibleToUser = [true]D/ChildFragment: LiveFragment onCreateView:D/ChildFragment: LiveFragment onResume:D/ChildFragment: FollowFragment onAttach:D/ChildFragment: FollowFragment onCreateView:D/ChildFragment: FansFragment onAttach:D/ChildFragment: FansFragment onCreateView:D/ChildFragment: FollowFragment onResume:D/ChildFragment: FansFragment onResume: 可以看到,方法的调用顺序:setUserVisibleHint-&gt;onAttach-&gt;(setUserVisibleHint如果可见)/onCreateView(不可见)-&gt;onResume 需要注意,第一次调用的时候连onCreateView都没执行,即view都没有初始化. 另外,每个Fragment在一开始,都先调用了setUserVisibleHint()并且传入了false,即还是不可见状态. 第二次and more而后,滑动viewpager或者点击tab则会导致相关的fragment调用setUserVisibleHint(这里的相关指的是,即将不可见的fragment与即将可见的fragment,也即可见性会发生变化的fragment) 通过日志也可以看到true,false,成对出现,每次也只有两个相关fragment出现在日志里: 1234567891011D/ChildFragment: FansFragment setUserVisibleHint() called with: isVisibleToUser = [false]D/ChildFragment: FollowFragment setUserVisibleHint() called with: isVisibleToUser = [true]D/ChildFragment: FollowFragment setUserVisibleHint() called with: isVisibleToUser = [false]D/ChildFragment: LiveFragment setUserVisibleHint() called with: isVisibleToUser = [true]D/ChildFragment: LiveFragment onResume:D/ChildFragment: FollowFragment onResume:D/ChildFragment: FansFragment onResume:D/ChildFragment: LiveFragment setUserVisibleHint() called with: isVisibleToUser = [false]D/ChildFragment: FansFragment setUserVisibleHint() called with: isVisibleToUser = [true]D/ChildFragment: FansFragment setUserVisibleHint() called with: isVisibleToUser = [false]D/ChildFragment: FollowFragment setUserVisibleHint() called with: isVisibleToUser = [true] 封装使用大致的流程在这里,可以根据自己调用Fragment的生命周期需求可以适当修改 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public abstract class LazyFragment extends Fragment &#123; /** * 是否可见 */ protected boolean isVisiable; /** * 是否已经调用onCreatView */ protected boolean isViewCreated; /** * 先于onCreateView * @param isVisibleToUser */ @Override public void setUserVisibleHint(boolean isVisibleToUser) &#123; super.setUserVisibleHint(isVisibleToUser); isVisiable = isVisibleToUser; //可以根据需要修改 if (isVisiable) &#123; onVisible(); &#125; else &#123; onInvisible(); &#125; &#125; @Override public void onViewCreated(View view, Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); isViewCreated = true; &#125; /** * 懒加载 在可见的状态下会被调用 */ protected abstract void lazyload(); protected void onVisible() &#123; if (isViewCreated &amp;&amp; isVisiable) &#123; lazyload(); &#125; &#125; protected void onInvisible() &#123; &#125;&#125; 使用,以LiveFragment为例: 1234567891011121314151617181920212223242526272829303132//为了不重复加载数据private boolean isDataLoadedOnce;@Overridepublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; TLLogger.trace("ChildFragment", "LiveFragment onCreateView: "); mRootView = inflater.inflate(R.layout.fragment_life, container, false); EventBus.getDefault().register(this); initData(); findViews(); return mRootView;&#125;@Overridepublic void onResume() &#123; super.onResume(); TLLogger.trace("ChildFragment", "LiveFragment onResume: "); lazyload();&#125;@Overrideprotected void lazyload() &#123; //如果加载过数据 或者不可见,则不再请求 //防止不可见的情况去加载数据,也避免加载多次数据 if (!isDataLoadedOnce&amp;&amp;isVisiable) &#123; isDataLoadedOnce = true; //dosth &#125;&#125; 知识点总结 第一次调用setUserVisibleHint的时候它比onCreateView之前,这时候控件都没有初始化,需要小心. onResume的时候,三个fragment都会调用onResume,但是setUserVisibleHint只涉及到可见性改变的fragment 滑动vp或者点击tab都会触发setUserVisibleHint 需要根据需要处理onResume和lazyload Fragment重叠问题使用add hide show来控制显示fragment,但是一旦activity被回收,那些被hide的Fragment，也全部处于可见状态,并且无法操控,即出现fragment重叠问题. 原因:fragment被回收,然后 变透明了 解决办法重写activity的onSaveInstanceState并且不调用super123@Overrideprotected void onSaveInstanceState(Bundle outState) &#123;&#125; 参考关于Activity被回收，Fragment还在的问题让多个Fragment 切换时不重新实例化 Exceptions记录我遇到的坑 remove(null).commit()当我试图在解决fragment被回收后出现重叠的状况的时候,我试着去移除原先老的fragment,但是发现如果被回收两次,olds虽然有size,但是它所包含的数据都是null!,导致remove(null).commit()报错! 报错日志:12345678910111213141516171819java.lang.NullPointerException at android.support.v4.app.BackStackRecord.run(BackStackRecord.java:707) at android.support.v4.app.FragmentManagerImpl.execPendingActions(FragmentManag at android.support.v4.app.FragmentController.execPendingActions(FragmentContro at android.support.v4.app.FragmentActivity.onStart(FragmentActivity.java:511) at android.app.Instrumentation.callActivityOnStart(Instrumentation.java:1174) at android.app.Activity.performStart(Activity.java:5203) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2198) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2286) at android.app.ActivityThread.access$600(ActivityThread.java:144) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1259) at android.os.Handler.dispatchMessage(Handler.java:99) at android.os.Looper.loop(Looper.java:137) at android.app.ActivityThread.main(ActivityThread.java:5166) at java.lang.reflect.Method.invokeNative(Native Method) at java.lang.reflect.Method.invoke(Method.java:525) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java: at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:584) at dalvik.system.NativeStart.main(Native Method) 场景:activity里有两个fragment,一个fragment里有viewpager+3个fragment Activity的onCreate 部分源码如下: 123456789101112131415161718if (savedInstanceState == null) &#123;//.....dosth&#125;else &#123; //移除原来的fragment避免重叠 FragmentManager manager = getSupportFragmentManager(); List&lt;Fragment&gt; olds = manager.getFragments(); if (null != olds) &#123; int size = olds.size(); for (int i = 0; i &lt; size; i++) &#123; Fragment old = olds.get(i); //但是这里的old可能为null manager.beginTransaction().remove(old).commit(); &#125; &#125; //获取回收之前的存储的当前显示页数,再把它显示出来 int index = savedInstanceState.getInt(KEY_CURR_INDEX); showOrHideFragment(index);&#125; 所以需要再加一层判断:123if (null != old) &#123; manager.beginTransaction().remove(old).commit();&#125; 完美!~ 资料android-fragmentmanager-backstackrecord-run-throwing-nullpointerexception activity被回收,fragment的onActivityCreated调用两次场景:Activity里有两个Fragment,其中一个里有viewpager+3个fagment. 当activity被回收,fragment的onActivityCreated被调用了两次(另外一个fragment也不例外): 第一次 savedInstanceState 不为null 保存的数据还在 第二次 savedInstanceState 为null 丢失了 这导致我在该fragment的onSaveInstanceState(Bundle outState)里保存的数据失效了 日志如:12onActivityCreated: TLToplistFragment&#123;43ceb940 #1 id=0x7f0f0077 top&#125;onActivityCreated: TLToplistFragment&#123;43cf7048 #1 id=0x7f0f0077 top&#125; 找了很久,但是并没有找到原因以及解决办法,原本是用来保存数据的,现在没办法了,最后通过在activity的onSaveInstanceState里获取fragment的数据,然后再在重新创建的时候通过setArguments传入的方式替代. 这个坑的原因还不知道,暂时用其他方法给解决了需求. 参考资料http://stackoverflow.com/questions/12453710/lazy-load-data-for-viewpager-itemshttp://blog.csdn.net/myatlantis/article/details/42643733]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Touch事件分发]]></title>
    <url>%2FTouch%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%2F</url>
    <content type="text"><![CDATA[前言touch事件分发乃自定义View必学技能~ 相关方法 dispatchTouchEvent(MotionEvent ev) 事件来了,第一个被调用,比较特殊,后面再说. onTouchEvent(MotionEvent event) true消费事件,false向上层回传 以上两个方法Activity,ViewGroup,View 都有,而ViewGroup还多一个方法: onInterceptTouchEvent(MotionEvent ev) true为拦截事件,给自己的onTouch dispatchTouchEventdispatchTouchEvent 比较特殊,一般看到的文章都不怎么提这个,但是我想看看,它有什么用. 12345678910/** * Called to process touch screen events. You can override this to * intercept all touch screen events before they are dispatched to the * window. Be sure to call this implementation for touch screen events * that should be handled normally. * * @param ev The touch screen event. * 如果true则消费这个事件 * @return boolean Return true if this event was consumed. */ TouchActivity的dispatchTouchEvent返回true123D/Touch: TouchActivity dispatchTouchEvent() called with: ev = [ action_down]D/Touch: TouchActivity dispatchTouchEvent() called with: ev = [ action_move]D/Touch: TouchActivity dispatchTouchEvent() called with: ev = [ action_up] TouchActivity的 false ,TopViewGroup 的 dispatchTouchEvent返回true123456Touch: TouchActivity dispatchTouchEvent() called with: ev = [ action_down]Touch: TopViewGroup dispatchTouchEvent() true called with: ev = [ action_down]Touch: TouchActivity dispatchTouchEvent() called with: ev = [ action_move]Touch: TopViewGroup dispatchTouchEvent() true called with: ev = [ action_move]Touch: TouchActivity dispatchTouchEvent() called with: ev = [ action_up]Touch: TopViewGroup dispatchTouchEvent() true called with: ev = [ action_up] 返回值影响: false 分发给自己的onInterceptTouchEvent或者其他的dispatchTouchEvent. true 则消费掉这个事件,返回给上层,不再往下层分发该事件. Activity的表现需要注意的是Activity对dispatchTouchEvent的接受消费机制有所不同 返回false/true 那么事件只会传递到Activity不会传递给contentview,也不会传递给Activity的onTouchEvent, 另外与View不同的是,当事件为Down的时候,dispatchTouchEvent返回false,Activity 依然可以接受后续的MOVE,UP事件!!!,或者说所有事件都是首先经过Activity的? 返回 super.dispatchTouchEvent(ev); 事件才会继续分发,而它的值一般为true! 日志如下1234TouchActivity dispatchTouchEvent() called with: ev = [ action_down]TouchActivity dispatchTouchEvent() called with: ev = [ action_move]TouchActivity dispatchTouchEvent() called with: ev = [ action_move]TouchActivity dispatchTouchEvent() called with: ev = [ action_up] 重写touch相关事件,并打印布局重写它们各自拥有的方法,并打印log,看看流程,这是最最方便快捷的方法. 默认情况都返回默认值false:点击SimpleView后的日志:123456789101112Touch: TouchActivity dispatchTouchEvent() called with: ev = [ action_down]Touch: TopViewGroup dispatchTouchEvent() false called with: ev = [ action_down]Touch: TopViewGroup onInterceptTouchEvent() false called with: ev = [ action_down]Touch: MiddleViewGroup dispatchTouchEvent() false called with: ev = [ action_down]Touch: MiddleViewGroup onInterceptTouchEvent() false called with: ev = [ action_down]Touch: SimpleView dispatchTouchEvent() false called with: ev = [ action_down]Touch: SimpleView onTouchEvent() false called with: ev = [ action_down]Touch: MiddleViewGroup onTouchEvent() false called with: ev = [ action_down]Touch: TopViewGroup onTouchEvent() false called with: ev = [ action_down]Touch: TouchActivity onTouchEvent() called with: event = [ action_down]Touch: TouchActivity dispatchTouchEvent() called with: ev = [ action_up]Touch: TouchActivity onTouchEvent() called with: event = [ action_up] 可以看到事件的分发的大致流程如下: 事件流程: 事件从上层传递到下层,即Activity-&gt;ViewGroup-&gt;ViewGroup…-&gt;View 方法流程: dispatchTouchEvent-&gt;onInterceptTouchEvent-&gt;onTouchEvent,事件不消费则再往上层传递. action_down事件从activity-&gt;TopViewGroup-&gt;MiddleViewGroup-&gt;SimpleView,再从底层view传递到activity.并且action_up只传递给了activity. 知识点: 对事件的反馈会被记录,如果对上个事件返回false(不包括dispatchTouchEvent),则下个接着的事件不会再有回调. (比如不处理down,那么move也不会下发回来) 资料]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IntentService教给我什么]]></title>
    <url>%2FIntentService%E6%95%99%E7%BB%99%E6%88%91%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[IntentService前几天学习了Service,是时候来学习一下IntentService了. 一如既往,先看下官网介绍: IntentService is a base class for Services that handle asynchronous requests (expressed as Intents) on demand. Clients send requests through startService(Intent) calls; the service is started as needed, handles each Intent in turn using a worker thread, and stops itself when it runs out of work.This “work queue processor” pattern is commonly used to offload tasks from an application’s main thread. The IntentService class exists to simplify this pattern and take care of the mechanics. To use it, extend IntentService and implement onHandleIntent(Intent). IntentService will receive the Intents, launch a worker thread, and stop the service as appropriate.All requests are handled on a single worker thread – they may take as long as necessary (and will not block the application’s main loop), but only one request will be processed at a time. 简单总结一下:service的子类,用于处理异步请求,并且在工作线程按顺序处理请求,工作完后自己停止.使用也很简单,继承IntentService,实现onHandleIntent(Intent)方法即可.特点: 与Service不同,IntentService是起线程处理任务的 自带队列,每个请求都会排队 任务完成自己会调用stopSelf结束,无需我们操心 一探究竟IntentService源码不多,截取了部分:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public abstract class IntentService extends Service &#123; private volatile Looper mServiceLooper; private volatile ServiceHandler mServiceHandler; private String mName; private boolean mRedelivery; private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; //调用onHandleIntent onHandleIntent((Intent)msg.obj); // 处理完自己停止 stopSelf(msg.arg1); &#125; &#125; public IntentService(String name) &#123; super(); mName = name; &#125; public void setIntentRedelivery(boolean enabled) &#123; mRedelivery = enabled; &#125; @Override public void onCreate() &#123; super.onCreate(); //开启个新的线程 HandlerThread thread = new HandlerThread("IntentService[" + mName + "]"); thread.start(); //getLooper 来获取thread的looper mServiceLooper = thread.getLooper(); //拿looper实例化 handler mServiceHandler = new ServiceHandler(mServiceLooper); &#125; @Override public void onStart(Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; //封装intent的请求 用handler发送 mServiceHandler.sendMessage(msg); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY; &#125; @Override public void onDestroy() &#123; //退出循环 mServiceLooper.quit(); &#125; protected abstract void onHandleIntent(Intent intent);&#125; 成员变量不多,一个looper,一个handler,接下来分析一下:在onCreate里,实例化一个HandlerThread(继承自Thread,HandlerThread后面再说)并且启动线程,并且利用该HandlerThread线程的looper实例化handler.onStart里接受的intent,封装成Message用handler发送,并在handleMessage中调用onHandleIntent((Intent)msg.obj);,再stopSelf.另外在onDestroy里调用了looper.quit();退出looper. 这样intentService的机制原理也差不多看完了,其实不难,但是也能学到不少东西: HandlerThread类–&gt;官方资料 Handy class for starting a new thread that has a looper. The looper can then be used to create handler classes. Note that start() must still be called. 方便我们创建一个拥有looper的线程,可以用来创建handler.注意: start() 必须被调用! 以前也不知道这个类,这次索性来看看HandlerThread的源码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class HandlerThread extends Thread &#123; int mPriority; int mTid = -1; Looper mLooper; public HandlerThread(String name) &#123; super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; &#125; public HandlerThread(String name, int priority) &#123; super(name); mPriority = priority; &#125; protected void onLooperPrepared() &#123; &#125; @Override public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; &#125; /** * This method returns the Looper associated with this thread. If this thread not been started * or for any reason is isAlive() returns false, this method will return null. If this thread * has been started, this method will block until the looper has been initialized. * @return The looper. */ public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper; &#125; public boolean quit() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quit(); return true; &#125; return false; &#125; public boolean quitSafely() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quitSafely(); return true; &#125; return false; &#125; public int getThreadId() &#123; return mTid; &#125;&#125; 我们都知道在线程里实例化handler要调用Looper.prepare();和Looper.loop();,其实就是因为Looper而HandlerThread有个成员变量mLooper,并且在run里面实例化了它,并且已经为我们封装好了Looper相关的方法~ 注意getLooper方法,当mLooper为null时会一直wait,直到run方法里实例化mLooper并notifyAll,可以学习一下. 用法就拿一下IntentService里的代码吧:1234HandlerThread thread = new HandlerThread("IntentService[" + mName + "]");thread.start();mServiceLooper = thread.getLooper();mServiceHandler = new ServiceHandler(mServiceLooper); Handler类的handleMessage方法所在的线程决定于它的Looper所在的线程,这个以前一直没留意. 总结主要学习到了: 可以利用Handler去维护一个队列,很简单 HandlerThread类 Handler的handleMessage方法所在的线程决定于它的Looper所在的线程 IntentService代码虽少,但是非常好.另外,Android还有很多很好的类需要我去发现,去学习!~又学了一招,哈哈!~]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>IntentService</tag>
        <tag>RTFSC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service学习笔记]]></title>
    <url>%2FService%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ServiceService,四大组件之一,是一个可以在后台执行长时间运行操作而不使用用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。 但是必须要提的是,虽然说是后台,但是Service运行在主线程!PS:Service的官方文档有中文翻译了!!真是个大好的消息! 生命周期跟Activity类似,service也有自己的生命周期,但是简单了一些. Service的基本使用上面的生命周期已经提示到了,使用Service有两种方式,启动/停止,绑定/解绑,一一对应: startService stopService(启动) bindService unbindService(绑定) 还有一种就是即调用start,又调用bind(又启动又绑定) 这几个方式都有什么区别呢?不急,咱慢慢来,一一解答. 咱先写个MyService,继承service,重写他的各种方法,并加入打印日志(这是我学习最常用的办法).写几个按钮调用不同方法,再加个ServiceConnection,代码就不给全了,没难度,不过要注意Service要在xml里配置 12345&lt;service android:name=".service.MyService" android:enabled="true" android:exported="false"&gt;&lt;/service&gt; 解释一下xml的属性: enabled: 是否能被系统实例化,false就用不了了 exported: 其他应用的组件是否能跟它交互,false表示私有只能自己应用使用,true表示可以被其他应用调起 对于xml的配置,官方有些建议: 为了确保应用的安全性，请始终使用显式 Intent 启动或绑定 Service，且不要为服务声明 Intent 过滤器。 添加 android:exported 属性并将其设置为 “false”，确保服务仅适用于您的应用。这可以有效阻止其他应用启动您的服务，即便在使用显式 Intent 时也如此。 点击事件:123456789101112131415161718192021222324252627282930313233@OnClick(&#123;R.id.start_service, R.id.stop_service, R.id.bind_service, R.id.unbind_service&#125;)public void onClick(View view) &#123; Intent intent = new Intent(ServiceActivity.this,MyService.class); switch (view.getId()) &#123; case R.id.start_service: startService(intent); break; case R.id.stop_service: stopService(intent); break; case R.id.bind_service: bindService(intent,con, Service.BIND_AUTO_CREATE); break; case R.id.unbind_service: unbindService(con); break; &#125;&#125;//bindservice 需要ServiceConnection con = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Log.d(TAG, "onServiceConnected() called with: " + "name = [" + name + "], service = [" + service + "]"); ((MyService.MyBinder)service).dosth(); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; Log.d(TAG, "onServiceDisconnected() called with: " + "name = [" + name + "]"); &#125;&#125;; PS:bindService的参数BIND_AUTO_CREATE表示在Activity和Service建立关联后自动创建Service，这会使得MyService中的onCreate()方法得到执行，但onStartCommand()方法不会执行。(来自guolin的博客) startService&amp;stopServicestartService使用startService启动service:第一次启动service会调用onCreate,onStartCommand,而后面的则不会再调用onCreate而是onStartCommand,并且每次startId不同. 注意是启动,启动后,这样在手机设置-正在运行界面会显示有MyService存在.1234D/MyService: onCreate:D/MyService: onStartCommand()//第二次startServiceD/MyService: onStartCommand() stopService调用stopService,情况如下: 如果service已经通过startService启动,则onDestroy 如果service没启动,则没什么效果1D/MyService: onDestroy: stopService之后,正在运行界面不会有MyService存在了. PS:如果不调用stop,直接关掉Activity对Service没影响,即两者的生命周期没有关联. bindService&amp;unbindService用到bind跟之前的startService不同,我们还需要重写onBind,添加Bind类: 123456789101112@Overridepublic IBinder onBind(Intent intent) &#123; Log.d(TAG, "onBind: "); return new MyBinder();&#125;public class MyBinder extends Binder&#123; public void dosth()&#123; Log.d(TAG, "dosth: "); &#125;&#125; bindServicebindService作用是跟service进行绑定.文档介绍:绑定服务是客户端-服务器接口中的服务器。绑定服务可让组件（例如 Activity）绑定到服务、发送请求、接收响应，甚至执行进程间通信 (IPC)。绑定服务通常只在为其他应用组件服务时处于活动状态，不会无限期在后台运行。 点击bind按钮,发现MyService调用了onCreate和onBind,并且之前的ServiceConnection里的onServiceConnected也被调用了.注意: 跟startService不同的是,多次调用bindService没有效果,不会再多调用onBind** 如果onBind里我们返回null那么onServiceConnected不会被调用 不同于startService,bind调用后,设置-正在运行里是看不到有Service运行着的.1234D/MyService: onCreate:D/MyService: onBind:D/MyService: onServiceConnected()D/MyService: dosth: unbindServiceunbindService是用于解绑,取消关联 如果没用bindService启动过service(注意:即使是startService启动的也不行),直接调用unbindService,则会崩溃: 1java.lang.IllegalArgumentException: Service not registered: yifeiyuan.practice.practicedemos.service.ServiceActivity$1@535f696c 如果已经用bindService启动过,则会停止service 12D/MyService: onUnbind:D/MyService: onDestroy: PS:如果不调用onUnbind,直接关掉Activity,跟unBind效果一样,也就是说两者生命周期相同,共存亡. 看到这里,我发现很奇怪的是,我们ServiceConnection里的onServiceDisconnected方法并没有被调用.于是跟踪了一下方法的说明:12345Called when a connection to the Service has been lost. This typicallyhappens when the process hosting the service has crashed or been killed.This does &lt;em&gt;not&lt;/em&gt; remove the ServiceConnection itself -- thisbinding to the service will remain active, and you will receive a callto &#123;@link #onServiceConnected&#125; when the Service is next running. 官方文档中也有提到:Android 系统会在与服务的连接意外中断时（例如当服务崩溃或被终止时）调用该方法。当客户端取消绑定时，系统“绝对不会”调用该方法。 自己尝试去设置界面停止服务,强杀应用,也没发现它调用!. startService和bindService组合启动先start后bind:12345D/MyService: onCreate:D/MyService: onStartCommand:D/MyService: onBind:D/MyService: onServiceConnected()D/MyService: dosth: 尝试结束解绑service: 先stop 效果: Service停止了(运行界面看不到Service),但是没有onDestory的日志,即没销毁 再unbind 效果: 输出onUnbind和onDestroy,并销毁 先unbind 效果:输出日志onUnbind,没销毁 后stop 效果:输出日志onDestroy Service停止了,并销毁 结果: unbind后出现onUnbind,stop后出现onDestroy. 那这个是为什么呢?因为:服务有两种状态,一种已启动,另外一种已绑定,并且当且仅当服务没有状态时才会销毁. start和bind的区别 start启动的service与组件生命周期无关,bind的service与组件的生命周期绑定,共存亡 start给service一种已启动的状态,bind给的是绑定状态 广播不能绑定service,但能启动service 另外一些回调我按Home回桌面的时候,回调了onTrimMemory,其他暂时不知.12345D/MyService: onCreate:D/MyService: onBind:D/MyService: onServiceConnected()D/MyService: dosth:D/MyService: onTrimMemory: 在前台运行服务前面说到service是后台,所以呢service可能会被杀死.前台服务被认为是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。前台服务必须为状态栏提供通知! 这种非常常见,比如网易云音乐播放音乐的时候就会有通知在通知栏~ 通过startForeground来让服务运行于前台:12345Notification notification = new Notification(R.drawable.icon, getText(R.string.ticker_text),System.currentTimeMillis());Intent notificationIntent = new Intent(this, ExampleActivity.class);PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);notification.setLatestEventInfo(this, getText(R.string.notification_title),getText(R.string.notification_message), pendingIntent);startForeground(ONGOING_NOTIFICATION_ID, notification); 可以通过stopForeground(boolean removeNotification)来停止.removeNotification代表 是否也删除状态栏通知。需要注意的是: 此方法绝对不会停止服务。 但是，如果您在服务正在前台运行时将其停止，则通知也会被删除。 Service通信Service与Activity通信的除了之前所说的bind进行绑定之外,还可以选择: 发送广播 使用EventBus/Otto等事件订阅发送框架(推荐这个,更加方便) 跨进程通信(IPC): AIDL Messenger 官方资料:使用Messenger是执行进程间通信 (IPC) 的最简单方法,因为 Messenger 会在单一线程中创建包含所有请求的队列，这样您就不必对服务进行线程安全设计。 这些AIDL跟Messenger的例子官网都有,就不写了,官方的资料总是最好的~ PS: Android Interface Definition Language (AIDL) 处理Service的onStartCommand返回值来源于官方文档:onStartCommand() 方法必须返回整型数,用于描述系统应该如何在服务终止的情况下继续运行服务. 从 onStartCommand() 返回的值必须是以下常量之一： START_NOT_STICKY如果系统在 onStartCommand() 返回后终止服务，则除非有挂起 Intent 要传递，否则系统 不会重建服务。这是最安全的选项,可以 避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。 START_STICKY如果系统在 onStartCommand() 返回后终止服务，则会 重建服务并调用 onStartCommand(),但绝对不会重新传递最后一个 Intent.相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过 空Intent 调用 onStartCommand()。这适用于 不执行命令、但无限期运行并等待作业的媒体播放器(或类似服务)。 START_REDELIVER_INTENT如果系统在 onStartCommand() 返回后终止服务，则会 重建服务，并通过 传递给服务的最后一个 Intent 调用 onStartCommand()。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。 小结: START_STICKY,START_REDELIVER_INTENT 会重启服务 START_STICKY 会传递null的intent START_REDELIVER_INTENT 会传递最后一个intent 总结诶,学android一年了才来学习Service也真是给跪了,平时也不怎么用到service就用来下载文件.之前说到service是主线程运行的,还需要自己开线程,而且多线程不安全,很坑,还好我们还有IntentService.接下去就学习IntentService去~ 更多资料 绑定服务 Android Interface Definition Language(AIDL) http://blog.csdn.net/guolin_blog/article/details/11952435 http://blog.csdn.net/guolin_blog/article/details/9797169]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android群英传笔记]]></title>
    <url>%2FAndroid%E7%BE%A4%E8%8B%B1%E4%BC%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Android群英传前言医生写的,适合进阶,不适合初学者,在这里记录一下自己所学到的知识点. 本人是奔着自定义的相关知识点来的,所以对这方面的知识点有所侧重. 第三章 整个界面的控件形成一个控件树,上层控件负责下层子控件的测量与绘制,并传递事件,并且每个控件树的顶点都有一个ViewParent对象,所有交互事件都由它控制 findViewById在控件树中已深度优先遍历来查找对应元素. 每个Activity都包含一个Window对象(通常是PhoneWindow),它将DecorView设为整个应用窗口的根View requestWindowFeature()方法一定要在调用setContentView之前才有效. onResume之后,系统才将DecorView添加到PhoneWindow并显示. MeasureSpec,一个32位的int值,高2位为测量的模式,低30位为测量的大小(位运算提高并优化效率) EXACTLY 精确模式, 具体值/match_parent AT_MOST,最大值模式—wrap_content,表示子控件不允许超过该大小 UNSPECIFIED,想多大多大,通常用于自定义View View默认的onMeasure只支持Exactly,可以响应具体值和match_parent,所以自定义View如果要支持wrap_content则需要重写onMeasure 通过MeasureSpec.getMode和getSize方法获取测量模式与大小. 最终要setMeasuredDimension(width,height)完成测量 Canvas的bitmap与canvas是紧紧联系在一起的,这过程成为装载画布 该bitmap存储所有绘制在Canvas上的像素信息(即canvas.drawXXX()都发生在该bitmap上) mTouchSlop = ViewConfiguration.getScaledTouchSlop() 第四章 使用viewholder提高效率 设置显示第几项setSelection(int n),smoothScrollBy(distance,duration),smoothScrollByOffset(offset),smoothScrollToPosition(index) listview.setEmptyView(view)处理空数据 弹性ListView实现方法:重写overScrollBy(..int maxOverScrollY),重新赋值参数maxOverScrollY即可 第五章 屏幕最左上角顶点作为Android坐标系的原点 getLocationOnScreen(int location[])获取在Android坐标系中的位置 ViewGroup.MarginLayoutParams更方便 通过getLayoutParams可获取LayoutParams对象 ViewDragHelper.smoothSlideViewTo(view,x,y) ViewCompat.postInvalidateOnAnimation(view) 第六章(todo) canvas.save()保存画布,canvas.restore()将我们在save之后绘制的所有图像与save之前的图像进行合并(似PS中的合并图层) canvas.translate(x,y)将原点(0,0)移动到(x,y)并以新的点作为原点 canvas.saveLayer(),saveLayerAlpha()将一个图层入栈,并且后面的操作都发生在这个图层 restore(),restoreToCount()将一个图层出栈,把图层上的图像绘制到上层Canvas上 ColorMatrix,一个4X5的数字矩阵,处理色彩效果. ColorMatrix.setRotate(int rgb,int value)设置色调,0,1,2分别对应RGB 饱和度(饱和度为0时,图像就变成灰度图像了)colorMatrix.setSaturation(float sat) 亮度(亮度为0时,图像就全黑了)colorMatrix.setScale(float rScale, float gScale, float bScale,float aScale) 矩阵的乘法(将矩阵的作用效果混合,从而叠加处理效果):postContact 使用ColorMatrix,paint.setColorFilter(new ColorMatrixColorFilter(colorMatrix))接着canvas.drawxx(...,paint) 6.6 Android图像处理之图形特效处理 变形矩阵Matrix,一个3X3的矩阵,|A B C||D E F||0 0 1|初始为:|1,0,0||0,1,0||0,0,1| Matrix的四类变换: 平移 set.translate 由CF控制 旋转 set.rotate 由ABCD共同控制 缩放 set.scale 由AE控制 错切 set.skew 由BD控制 pre()和post()提供矩阵的前乘和后乘运算,两者不相同(因此,矩阵不满足乘法交换律) drawBitmapMesh(P144) 6.7画笔特效处理 PoterDuffXfermode 最好关闭硬件加速 Shader着色器,渲染器,用来实现一些列的渐变,渲染效果 BitmapShader 位图Shader LinearGradient 线性 RadialGradient 光束 SweepGradient 梯度 ComposeShader 混合 SurfaceView 适用于频繁更新或刷新时数据处理量比较大 lockCanvas()获取Canvas,但是需要drawColor清屏 unlockCanvasAndPost(mCanvas)提交canvas的内容(最好放在finally代码块中) 第七章 视图动画,优点:简单,缺点:不具备交互性 AlphaAnimation RotateAnimation TranslateAnimation ScaleAnimation AnimationSet ​ 属性动画 ObjectAnimator 单一属性 PropertyValuesHolder 多个属性结合 ValueAnimator AnimatorSet ​ Q&amp;A(todo)12345678910void methodA()&#123;Object object;object = new Object();&#125;void methodB()&#123;Object object;object = new Object();object = null;&#125; Q:methodB 中的最后一行是否会让object的堆内存回收掉?还是说依然要等GC? A:要等gc的,gc的时候 会去找对象是否还有ref 如果没有的话 才清除 你=null只是清除了ref]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android群英传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread相关知识点整理]]></title>
    <url>%2FThread%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Thread多线程,举足轻重,记录整理部分相关的重要的知识点,后续应该还需要再学习一下Runnable,线程池. 后面有提到monitor,翻译为 监视器 线程的状态图/生命周期图: Thread.sleep()静态方法,即作用于当前线程 睡眠,睡眠当前线程,睡眠后回到可执行状态,所以并不一定睡眠过会立马执行后面的代码,或许休眠这词更好. PS:sleep,锁并没有被释放 Thread.yield();yield()是个静态方法.Thinking in java 的解释如下:对 线程调度器 的一种建议,它在声明:”我已经执行完生命周期中最重要的部分了,此刻正是切换给其他任务执行一段时间的大好时机” 线程调度器(Java线程机制的一部分,可以将CPU从一个线程转移给另一个线程) 其他理解:让当前线程回到可执行状态,以便让具有相同优先级的线程进入执行状态,但不是绝对的。因为虚拟机可能会让该线程重新进入执行状态。 简单理解就是我重要的事干完了,我可以让出cpu给其他线程(相同优先级). 补充:锁也没有被释放 wait)看下Java文档怎么说: Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. In other words, this method behaves exactly as if it simply performs the call wait(0). The current thread must own this object’s monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object’s monitor to wake up either through a call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution.As in the one argument version, interrupts and spurious wakeups are possible, and this method should always be used in a loop:This method should only be called by a thread that is the owner of this object’s monitor. 当前线程必须拥有这个对象的monitor,当前线程会释放该monitor的拥有权,并且等到别的线程(正在等待这个对象的monitor)调用notify或者notifyAll来唤醒它. wait方法应该被用于一个循环里. 必须拥有该对象的monitor,否则会报错–IllegalMonitorStateException 补充: wait会释放锁 实例,HandlerThread:1234567891011121314public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper;&#125; IllegalMonitorStateException例子:1234567891011121314public static final Object lock = new Object()private boolean open = false;public int test() &#123; synchronized (lock) &#123; //这样会报错 while (!open) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return 1;&#125; 报错日志:123456Exception in thread "Thread-0" java.lang.IllegalMonitorStateException at java.lang.Object.wait(Native Method) at java.lang.Object.wait(Object.java:502) at com.example.concurrent.WaitNotify.test(WaitNotify.java:64) at com.example.concurrent.WaitNotify$1.run(WaitNotify.java:81) at java.lang.Thread.run(Thread.java:745) notify,notifyAllnotify) Wakes up a single thread that is waiting on this object’s monitor.If any threads are waiting on this object, one of them is chosen to be awakened.The choice is arbitrary and occurs at the discretion of the implementation.A thread waits on an object’s monitor by calling one of the wait methods.The awakened thread will not be able to proceed until the current thread relinquishes the lock on this object.The awakened thread will compete in the usual manner with any other threads that might be actively competing to synchronize on this object;for example, the awakened thread enjoys no reliable privilege or disadvantage in being the next thread to lock this object. This method should only be called by a thread that is the owner of this object’s monitor. A thread becomes the owner of the object’s monitor in one of three ways: By executing a synchronized instance method of that object. By executing the body of a synchronized statement that synchronizes on the object. For objects of type Class, by executing a synchronized static method of that class. Only one thread at a time can own an object’s monitor. 理解: 唤醒一个等待这个对象的monitor的线程 这个选择是随意的 这个被唤醒的线程不能执行直到当前线程交出对象锁 这个机会是需要线程去争取的 这个方法跟前面的wait一样,也需要拥有这个对象的monitor 一个线程可以有三种方法拿到对象的monitor: 正在执行该对象的同步方法 正在执行锁住该对象的同步块(synchronized 代码块) 正在执行锁住该类的静态方法 notifyAll跟notify作用一样,当时notify唤醒的只是一个线程,而notifyAll唤醒的是所有. Android中线程的比较: 补充线程除了用户线程外还有一种叫做守护线程,可以通过setDaemon(boolean isDaemon)来设置 守护线程和用户线程的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖 举个简单的例子:如果在main线程中创建了一个守护线程,当main方法运行完毕之后,守护线程也会随着消亡,而用户线程则不会,用户线程会一直运行直到其运行完毕。不过一般我们也不会用到守护线程. 资料 Thinking in Java Object Thread]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符续]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%BB%AD%2F</url>
    <content type="text"><![CDATA[前言RxJava处理数据主要还是靠不同的操作符,在这里对RxJava比较常用的操作符做必要的介绍,附加一些自己的理解. 操作符有难有易,部分操作符非常简单容易理解,只记录些许文字部分操作符复杂,可能会配有弹珠图,它十分有助于对操作符的理解,而理解弹珠图,前提是知道每个元素的意义,特给出下图: OK,准备就绪,开启RxJava操作符之旅吧! 创建这里指的是Observable的创建 create使用一个函数从头创建一个Observable 从头创建意味着onNext onCompleted onError都需要我们自己调用. 定制度最高,也最麻烦,需要时刻判断observer.isUnsubscribed()来判断是否继续处理发射数据. defer只有当订阅者订阅才创建Observable；为每个订阅创建一个新的Observable 当被订阅时,为每个订阅创建一个新的Observable,所以defer可以确保Observable包含最新的数据。 from将一个Iterable, 一个Future, 或者一个数组转换成一个Observable from操作符可以转换Future、Iterable和数组。对于Iterable和数组，产生的Observable会发射Iterable或数组的每一项数据 相对于create,defer,from生成Observable非常方便,加上iterable和数组在Java中的使用率,使得from出场的频率非常高! just 将一个或多个对象转换成发射这个或这些对象的一个Observable,很方便 range 创建一个发射指定范围的整数序列的Observable range(int start,int count) range(int,int,Scheduler) range(3,10)表示从3开始,发射10个数字,即3,4,5….12 interval 创建一个按照给定的时间间隔发射整数序列的Observable interval(long,TimeUnit) interval(long,TimeUnit,Scheduler) 默认在computation调度器上 timer 创建一个在给定的延时之后发射单个数据的Observable empty/never/throw empty 创建一个什么都不做直接通知完成的Observable throw 创建一个什么都不做直接通知错误的Observable never 创建一个不发射任何数据的Observable 暂时没有用到过 小结就创建Observable而言,from,just,defer,create用得多一些,一般来讲掌握这几个即可. 变换操作变换是RxJava处理数据最强大的部分,一定要理解,要活用 buffer buffer(int count) buffer(int count,int skip) buffer是将数据缓存成一个List,再发送 count 集合数量的的大小 skip 每次发射后扔掉数据的个数(看后面例子好理解一些) 举例:1Observable.just(1,2,3,4,5,6,7,8,9,10).buffer(3).subscribe(subscriber); 其实buffer(count)调用的是buffer(count,count)!,所以默认不填,skip=count 结果:12345onNext:[1, 2, 3]onNext:[4, 5, 6]onNext:[7, 8, 9]onNext:[10]onCompleted skip值为1: 1Observable.just(1,2,3,4,5,6,7,8,9,10).buffer(3,1).subscribe(subscriber); 结果:1234567891011onNext:[1, 2, 3]onNext:[2, 3, 4]onNext:[3, 4, 5]onNext:[4, 5, 6]onNext:[5, 6, 7]onNext:[6, 7, 8]onNext:[7, 8, 9]onNext:[8, 9, 10]onNext:[9, 10]onNext:[10]onCompleted 解释:每次缓存了3个,再skip掉第1个,再等凑够3个,再发送,再skip掉1个,如此循环,直至结束. filter过滤,过滤掉不需要的数据 singleSingle类似于Observable，不同的是，它总是只发射一个值，或者一个错误通知，而不是发射一系列的值。因此，不同于Observable需要三个方法onNext, onError, onCompleted，订阅Single只需要两个方法： onSuccess - Single发射单个的值到这个方法 onError - 如果无法发射需要的值，Single发射一个Throwable对象到这个方法 Single只会调用这两个方法中的一个，而且只会调用一次，调用了任何一个方法之后，订阅关系终止。 single 和 filter差不多，但如果为0会报错进入onError firsttosortlistdeferzipmergethrottleFirst放抖动 distinct去重 takedoOnNextfinallyDocontactreduce了解“热”和“冷”的Observable 资料/推荐RxDocs-contentRxDocsRxJava使用场景小结]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Twitter相关功能集成]]></title>
    <url>%2FTwitter%E7%9B%B8%E5%85%B3%E5%8A%9F%E8%83%BD%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[前言app 未来可能有要往国外推的需求,需要做Facebook,Twitter登录,FB用umeng搞定了部分,剩下Twitter需要自己做. Create-App前提是你有账号,去注册TwitterTwitter开发者平台创建开发者账号 这里有个很难搞的坑,就是创建应用需要添加手机号,否则你会得到以下错误: ErrorYou must add your mobile phone to your Twitter profile before creating an application. Please read https://support.twitter.com/articles/110250-adding-your-mobile-number-to-your-account-via-web for more information. 但是令人发指的是,Twitter又不支持中国大陆+86的手机,遇到这个问题后瞬间整个人就不好了…但是还是得完成啊,于是百般搜索,寻找解决方案,无果.最后给twitter support(support@twitter.com)发了邮件,最终,人家给我开通了时间有限的权限.1234567Thank you for reaching out. We’re aware that you are not able to register a mobile phone number to your account. We have enabled access for you to create an app without doing so. Please note that this access will expire 7 days from the date of this email, so you must create your app within this time frame.While developing your application, please review our Developer Agreement and Policy to ensure that your application is compliant with our Rules.Regards,ElliotSamuelsonTwitter Platform Operations finally,我可以创建应用了. FabricTwitter弄了个叫Fabric的插件,AS可用.它会帮忙设置项目,帮忙生成很多必要的代码文件,挺繁琐的,这里省略了,因为已经弄完了,不想再搞了. 大致记录一些,不全,具体看我Github.build.gradle文件:12345678910111213141516171819202122compile('com.twitter.sdk.android:twitter:1.8.0@aar') &#123; transitive = true;&#125;compile('com.twitter.sdk.android:tweet-composer:0.9.0@aar') &#123; transitive = true;&#125;buildscript &#123; repositories &#123; maven &#123; url 'https://maven.fabric.io/public' &#125; &#125; dependencies &#123; classpath 'io.fabric.tools:gradle:1.+' &#125;&#125;apply plugin: 'com.android.application'apply plugin: 'io.fabric'repositories &#123; maven &#123; url 'https://maven.fabric.io/public' &#125;&#125; APP:1234567891011121314public class App extends Application &#123; // Note: Your consumer key and secret should be obfuscated in your source code before shipping. private static final String TWITTER_KEY = "RJjbqTVS5kIseg9q4jsRecf7u"; private static final String TWITTER_SECRET = "dbBgVZYA4oBkmSr5jKaInMzijO2mt3uB82SHviTJ1tgK2Z5P8E"; @Override public void onCreate() &#123; super.onCreate(); TwitterAuthConfig authConfig = new TwitterAuthConfig(TWITTER_KEY, TWITTER_SECRET);// Fabric.with(this, new TwitterCore(authConfig), new Digits()); Fabric.with(this, new TwitterCore(authConfig),new TweetComposer()); &#125;&#125; 集成完后,开始写代码. PS:个人非常讨厌Twitter这种方式,而且搞的AS编译时间非常非常久,夸张的时候1个小时都没成功,不知道什么坑. 登录最简单的方式使用推特提供的TwitterLoginButton,自带UI效果 配置xml12345&lt;com.twitter.sdk.android.core.identity.TwitterLoginButton android:id="@+id/btn_twitter" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt; 代码里设置监听回调调用TwitterLoginButton.setCallback即可监听,不需要设置点击事件 1234567891011121314151617181920private void setUpTwitterButton() &#123; mBtnTwitter.setCallback(new Callback&lt;TwitterSession&gt;() &#123;//userName alancheen06 secret 4H6cMSpc59EbLSlcQ5QI0SzAUXAAZnxDZ40KUqQkJkl7s token 3313987080-L3UPicTGjEZrNjpjsobeDQRCbWGFyczUCV2O408 @Override public void success(Result&lt;TwitterSession&gt; result) &#123; Log.d("Twitter", "success() called with: " + "result = [" + result + "]++++data" + result.data); String name = result.data.getUserName(); long userId = result.data.getUserId();//3313987080 long id = result.data.getId(); TwitterAuthToken token = result.data.getAuthToken(); String secret = token.secret; String strToken = token.token; &#125; @Override public void failure(TwitterException exception) &#123; Log.d("Twitter", "failure() called with: " + "exception = [" + exception.getMessage() + "]"); &#125; &#125;);&#125; 处理onActivityResult 如果有fragment则需要用fragment来处理,否则Activity处理1mBtnTwitter.onActivityResult(requestCode, resultCode, data);//140 requestCode 坑当手机安装了推特客户端,那么以上代码都没有问题,但是如果没有安装,那么就不能授权!解决办法是去推特开发者后台,把app的setting下的callback url设置一下,不论什么,可以访问即可! 相关资料–&gt;戳这里 自定义UI但是我的需求不能使用推特提供的UI,不过貌似没看到哪里文档有提,不过幸好自己摸索出了如下方法. 其实说白了就是掰了一些TwitterLoginButton里的源码12345678910111213141516171819mTvCustom.setOnClickListener(v -&gt; &#123; new TwitterAuthClient().authorize(TwitterActivity.this, new Callback&lt;TwitterSession&gt;() &#123; @Override public void success(Result&lt;TwitterSession&gt; result) &#123; String name = result.data.getUserName(); long userId = result.data.getUserId();//3313987080 long id = result.data.getId(); TwitterAuthToken token = result.data.getAuthToken(); String secret = token.secret; String strToken = token.token; &#125; @Override public void failure(TwitterException e) &#123; &#125; &#125;);&#125;);&#125; 获取更多信息从上文也能看出来,我们只能获取一个name严格来说是screen_name,另外一个是userId,而我还需要头像等信息.于是,还得接下去搞.其实过程异常痛苦,因为推特并没有给出详细的例子,自己也没有弄清楚oauth,找了老半天也没有详细的文档,不过最后还是被我弄出来了. 这里直接给代码了,无非就是拿token去获取数据:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*** * &#123;"id":3313987080,"id_str":"3313987080","name":"\u7a0b\u5e8f\u4ea6\u975e\u733fAlan","screen_name":"alancheen06","location":"","profile_location":null,"description":"An android developer from China.","url":null,"entities":&#123;"description":&#123;"urls":[]&#125;&#125;,"protected":false,"followers_count":1,"friends_count":34,"listed_count":0,"created_at":"Thu Aug 13 05:29:54 +0000 2015","favourites_count":2,"utc_offset":-25200,"time_zone":"Pacific Time (US &amp; Canada)","geo_enabled":false,"verified":false,"statuses_count":13,"lang":"en","status":&#123;"created_at":"Mon Oct 12 04:23:09 +0000 2015","id":653425648577286144,"id_str":"653425648577286144","text":"@Support How to add phone num?Thanks a lot!","source":"\u003ca href=\"http:\/\/twitter.com\" rel=\"nofollow\"\u003eTwitter Web Client\u003c\/a\u003e","truncated":false,"in_reply_to_status_id":null,"in_reply_to_status_id_str":null,"in_reply_to_user_id":17874544,"in_reply_to_user_id_str":"17874544","in_reply_to_screen_name":"Support","geo":null,"coordinates":null,"place":null,"contributors":null,"retweet_count":0,"favorite_count":1,"entities":&#123;"hashtags":[],"symbols":[],"user_mentions":[&#123;"screen_name":"Support","name":"Twitter Support","id":17874544,"id_str":"17874544","indices":[0,8]&#125;],"urls":[]&#125;,"favorited":false,"retweeted":false,"lang":"en"&#125;,"contributors_enabled":false,"is_translator":false,"is_translation_enabled":false,"profile_background_color":"C0DEED","profile_background_image_url":"http:\/\/abs.twimg.com\/images\/themes\/theme1\/bg.png","profile_background_image_url_https":"https:\/\/abs.twimg.com\/images\/themes\/theme1\/bg.png","profile_background_tile":false,"profile_image_url":"http:\/\/pbs.twimg.com\/profile_images\/631699830872498176\/yThxaLUe_normal.jpg","profile_image_url_https":"https:\/\/pbs.twimg.com\/profile_images\/631699830872498176\/yThxaLUe_normal.jpg","profile_link_color":"0084B4","profile_sidebar_border_color":"C0DEED","profile_sidebar_fill_color":"DDEEF6","profile_text_color":"333333","profile_use_background_image":true,"has_extended_profile":false,"default_profile":true,"default_profile_image":false,"following":false,"follow_request_sent":false,"notifications":false&#125; * @param token */ private void getInfo(final TwitterAuthToken token) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; TwitterAuthConfig authConfig = TwitterCore.getInstance().getAuthConfig(); OAuthSigning oauthSigning = new OAuthSigning(authConfig, token); Map&lt;String, String&gt; authHeaders = oauthSigning.getOAuthEchoHeadersForVerifyCredentials(); URL url = null; try &#123;// url = new URL("https://api.twitter.com/1.1/users/show.json?"); url = new URL("https://api.twitter.com/1.1/users/show.json?screen_name=alancheen06&amp;user_id=3313987080");// url = new URL("http://api.yourbackend.com/check_credentials.json"); HttpURLConnection conn = (HttpsURLConnection) url.openConnection(); conn.setRequestMethod("GET");// for (Map.Entry&lt;String, String&gt; entry : authHeaders.entrySet()) &#123;// connection.setRequestProperty(entry.getKey(), entry.getValue());// &#125;// connection.addRequestProperty("Authorization","OAuth oauth_consumer_key=\"7Ud4sn002Jquc6hR6XFREEqds\", oauth_nonce=\"456e1966e1db379f36f1ea9551ce0ad8\", oauth_signature=\"QWGBWcurKrLd5RvtDwjzmqtasBc%3D\", oauth_signature_method=\"HMAC-SHA1\", oauth_timestamp=\"1444727699\", oauth_token=\"3313987080-h6f0ecdEc100MCQjpKyTuiNVakj6nZ0bdV2HvUw\", oauth_version=\"1.0\""); Map&lt;String, String&gt; par = new HashMap&lt;String, String&gt;(); par.put("screen_name", "alancheen06"); par.put("user_id", "3313987080"); OAuth1aService.signRequest(authConfig, token, conn, par); conn.connect(); int status = conn.getResponseCode(); //得到读取的内容(流) InputStreamReader in = new InputStreamReader(conn.getInputStream()); // 为输出创建BufferedReader BufferedReader buffer = new BufferedReader(in); String inputLine = null; String resultData = ""; //使用循环来读取获得的数据 while (((inputLine = buffer.readLine()) != null)) &#123; //我们在每一行后面加上一个"\n"来换行 resultData += inputLine + "\n"; &#125; JSONObject jo = new JSONObject(resultData); String imgUrl = jo.getString("profile_image_url"); Log.d("Twitter", "run: resultData" + resultData); final String aa = resultData; runOnUiThread(()-&gt;mTvInfo.setText(aa)); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (ProtocolException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; Twitter分享既然登录做了,那么分享也是需要的~ 分享相对来说简单多了,只是需要注意推特分享图片只能是本地文件 12345TweetComposer.Builder builder = new TweetComposer.Builder(context) .text(content) .image(fileUri) .url(url);builder.show(); 稍微解释一下参数: .text(String) 是发推的文本 .image(Uri imageUri) 上面提过是因为只支持本地文件一般Uri.fromFile(file)即可 .url(URL url)) 这个是网页链接,就是别人点击后跳转的地方,会出现在推文里. 分享结果处理上面提供的方法接收不到推特分享的结果,看了一下TweetComposer.Builder的源码后想出来了:builder.createIntent()可以创建一个intent,然后自己调用startActivityForResult,重写onActivityResult来接受结果即可.需要注意的是这样context的类型必须是activity了. 机智如我,搞定~ 总结做推特的功能大概花费了2天的时间,第一步添加手机号码的确实让我崩溃,后面也不顺利,但是幸好还是完成了功能~另外也感慨一下自己的英文实在是烂,全英文的文档实在吃不消.感谢Umeng集成了那么多第三方登录,分享功能,自己做真的累. 希望能给现在有需要or未来需要的人一些参考吧,就这样. 资料API Console ToolLog in with TwitterSignIn-with-Twitter文档APIcannonball-android示例-app]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Twitter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View的onMeasure、onLayout]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%E7%9A%84onMeasure%E3%80%81onLayout%2F</url>
    <content type="text"><![CDATA[前言自定义View有几个非常重要的流程: onFinishInflate() onAttachedToWindow() onMeasure(int widthMeasureSpec, int heightMeasureSpec) onLayout(boolean changed, int l, int t, int r, int b) onDraw(Canvas canvas) onDetachedFromWindow() 这里来学习一下onMeasure(重点讲),onLayout(大致了解),另外这里也侧重ViewGroup,因为vp比较难,如果把vp弄懂了,view应该也不在话下. 先讲几个知识点: onMeasure 负责测量大小,如果是View则测量自己,如果是ViewGroup则测量子View和自己. onMeasure 最终需要调用setMeasuredDimension(int measuredWidth, int measuredHeight)设置大小. onMeasure后,严格来说是setMeasuredDimension调用后,可以通过getMeasuredHeight(),getMeasuredWidth()获得测量的宽高 onLayout 负责布局,即把子View放在哪里. onLayout 后可以调用getWidth,getHeight获取宽高,与之前的getMeasuredXXX不同,他们可能不相等. onMeasure onLayout 都可能执行很多次. MeasureSpec而测量我们需要MeasureSpec来帮助,它字面意思就是测量规则,它包括测量模式以及大小,它是一个32位的int值,它的高2位是测量的模式,低30位是测量的大小. 模式可以通过MeasureSpec.getMode(int measureSpec)获得 大小可以通过MeasureSpec.getSize(int measureSpec)获得 测量模式模式有三种: MeasureSpec.EXACTLY MeasureSpec.AT_MOST MeasureSpec.UNSPECIFIED EXACTLY(精确模式)12* The parent has determined an exact size for the child. The child is going to be* given those bounds regardless of how big it wants to be. EXACTLY值为:0 父View告诉你,你应该多少大小.当XMl里的宽高属性为具体值或者为match_parent,为EXACTLY. 例:12android:layout_width="200dp"android:layout_height="match_parent" AT_MOST(至多模式)1* The child can be as large as it wants up to the specified size. AT_MOST值为:-2147483648 子控件大小最多为多少,在xml里配置的属性为wrap_content的时候. 如果自定义View要支持wrap_content必须重写onMeasure,否则大小可能为0 UNSPECIFIED(不指定模式)12* The parent has not imposed any constraint on the child. It can be whatever size* it wants. 值为 1073741824想多大多大,一般见不到,一般自定义View才用. 测试新建一个ViewGroup,重写onMeasure并打印日志.12345678910111213141516171819202122232425public class MyViewGroup extends ViewGroup &#123; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); logModeAndSize(widthMeasureSpec); logModeAndSize(heightMeasureSpec); Log.d(TAG, "onMeasure: height"+getMeasuredHeight()+";width:"+getMeasuredWidth()); &#125; &#125;//打印测量模式和大小private void logModeAndSize(int measureSpec) &#123; switch (MeasureSpec.getMode(measureSpec)) &#123; case MeasureSpec.UNSPECIFIED: Log.d(TAG, "UNSPECIFIED: "+MeasureSpec.getSize(measureSpec)); break; case MeasureSpec.AT_MOST: Log.d(TAG, "AT_MOST: "+MeasureSpec.getSize(measureSpec)); break; case MeasureSpec.EXACTLY: Log.d(TAG, "EXACTLY: "+MeasureSpec.getSize(measureSpec)); break; &#125;&#125; 测试match_parent和wrap_content1234&lt;yifeiyuan.practice.practicedemos.customview.MyViewGroup android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; 得到日志:123D/MyViewGroup: EXACTLY: 1080D/MyViewGroup: AT_MOST: 1692D/MyViewGroup: onMeasure: height1692;width:1080 可以看到match_parent对应模式是EXACTLYwrap_content对应模式是AT_MOST 顺带一提,如果是继承View,在这里的效果也是一样的. 然而,如果继承LinearLayout,效果则不一样,可以看到测量后,高度为0了123D/MyViewGroup: EXACTLY: 1080D/MyViewGroup: AT_MOST: 1692D/MyViewGroup: onMeasure: height0;width:1080 接下去测试具体值12345&lt;yifeiyuan.practice.practicedemos.customview.MyViewGroup android:layout_width="400dp" android:layout_height="wrap_content" android:background="#00ff00" /&gt; log:123D/MyViewGroup: EXACTLY: 1200D/MyViewGroup: AT_MOST: 1692D/MyViewGroup: onMeasure: height1692;width:1200 可以看到具体值对应EXACTLY模式,这里View和ViewGroup也是一样. 测量方法知道测量的规则后,其实可以得出比较模板化的代码: 适用于自定义View: 123456789101112131415private int measureWidth(int widthMeasureSpec)&#123; int result = 0; int size = MeasureSpec.getSize(widthMeasureSpec); int mode = MeasureSpec.getMode(widthMeasureSpec); if (mode == MeasureSpec.EXACTLY)&#123; result = size; &#125;else&#123; result = 100;// 实际上需要自己计算 if (mode==MeasureSpec.AT_MOST)&#123; //至多模式,别超过了 result = Math.min(result, size); &#125; &#125; return result;&#125; ViewGroup如果是自定义ViewGroup,那就各有不同了,每个ViewGroup都不一样,不过大致流程也差不多,就是测量子View再决定自己的大小. 简单的例子如下,把所有子View的高度之和当做自己的高度:12345678int childcount = getChildCount();int height = 0;for (int i = 0; i &lt; childcount; i++) &#123; View child = getChildAt(i); child.measure(widthMeasureSpec, heightMeasureSpec); height += child.getMeasuredHeight();&#125;setMeasuredDimension(MeasureSpec.getSize(widthMeasureSpec), height); OK,差不多该知道的知识点也知道了,实践一下 实践实现一个类似垂直的LinearLayout. 配置xml在xml里引用之前自定义的ViewGroup,并添加几个宽度高度背景色都不一样的View包括wrap_content,match_parent,xxxdp,可见,不可见各种情况.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;yifeiyuan.practice.practicedemos.customview.MyViewGroup android:layout_width="300dp" android:layout_height="wrap_content" android:background="#0000ff" &gt; &lt;TextView android:id="@+id/tv1" android:layout_width="wrap_content" android:layout_height="60dp" android:background="#88ff33" android:text="我只是个TextView" android:textColor="#ffffff" android:textSize="20sp" tools:background="#333333" /&gt; &lt;TextView android:id="@+id/tv2" android:layout_width="100dp" android:layout_height="wrap_content" android:background="#ff0000" android:text="Hello,ViewGroup" android:textColor="#ffffff" android:textSize="20sp" /&gt; &lt;TextView android:id="@+id/tv3" android:layout_width="match_parent" android:layout_height="200dp" android:background="#ee00ee" android:text="Hello,MatchParent" android:textColor="#ffffff" android:textSize="20sp" /&gt; &lt;TextView android:id="@+id/tv4" android:layout_width="match_parent" android:layout_height="100dp" android:background="#44ff33" android:text="Hello,MatchParent" android:textColor="#ffffff" android:textSize="20sp" android:visibility="gone" /&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="100dp" android:background="#ff00ff" android:text="Hello,MatchParent" android:textColor="#ffffff" android:textSize="20sp" android:visibility="invisible" /&gt; &lt;View android:layout_width="50dp" android:layout_height="20dp" android:background="#000000" /&gt;&lt;/yifeiyuan.practice.practicedemos.customview.MyViewGroup&gt; 重写onMeasure主要的思路是根据LayoutParams,给子View生成MeasureSpec规则,去测量各个子View的宽高,最终决定自己的宽高. 需要注意的是:记得处理不可见的状态,因为GONE掉的View是没有宽高的,所以跳过它,提高效率. Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int height = 0;//group的计算高度 int width = 0;//宽度 int heightSize = MeasureSpec.getSize(heightMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int childcount = getChildCount(); for (int i = 0; i &lt; childcount; i++) &#123; View child = getChildAt(i); //gone 的就无视掉 if (child.getVisibility() == GONE) &#123; continue; &#125; LayoutParams lp = child.getLayoutParams(); int widthSpec = 0; int heightSpec = 0; //根据LayoutParams,给子View生成MeasureSpec规则 if (lp.width == LayoutParams.WRAP_CONTENT) &#123; widthSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.AT_MOST); &#125; else if (lp.width == LayoutParams.MATCH_PARENT) &#123; widthSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY); &#125; else &#123; //其实xml里不会出现这样的情况 widthSpec = MeasureSpec.makeMeasureSpec(lp.width, MeasureSpec.EXACTLY); &#125; if (lp.height == LayoutParams.WRAP_CONTENT) &#123; heightSpec = MeasureSpec.makeMeasureSpec(heightSize, MeasureSpec.AT_MOST); &#125; else if (lp.height == LayoutParams.MATCH_PARENT) &#123; heightSpec = MeasureSpec.makeMeasureSpec(heightSize, MeasureSpec.EXACTLY); &#125; else &#123; heightSpec = MeasureSpec.makeMeasureSpec(lp.height, MeasureSpec.EXACTLY); &#125; child.measure(widthSpec, heightSpec); //把所有的子View的高度加起来,就是高度 height += child.getMeasuredHeight(); // 拿子View中的最大宽度当自己的宽度,保证所有子View能够显示全 width = Math.max(width, child.getMeasuredWidth()); Log.d(TAG, "onMeasure: i:" + i + ",width:" + child.getMeasuredWidth() + ",height:" + child.getMeasuredHeight()); &#125; // 再根据父view给自己的spec,处理自己的宽高 // 这里没有显式处理Unspecified,其实已经计算了宽高,当做UNSPECIFIED的值了 if (MeasureSpec.EXACTLY == widthMode) &#123; width = widthSize; &#125;else if (MeasureSpec.AT_MOST == widthMode) &#123; width = Math.min(width, widthSize); &#125; if (MeasureSpec.EXACTLY == heightMode) &#123; height = heightSize; &#125;else if (MeasureSpec.AT_MOST == heightMode) &#123; height = Math.min(height, heightSize); &#125; //一定要记得调用 setMeasuredDimension(width, height); Log.d(TAG, "onMeasure: height" + getMeasuredHeight() + ";width:" + getMeasuredWidth());&#125; 注意: 要牢记测量模式与xml属性的对应关系 处理View不可见的情况 onLayout测量完毕后我们需要布局.onLayout相对简单,只要记录一下总高度,挨个放就行: 1234567891011121314@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int childcount = getChildCount(); int height = 0; for (int i = 0; i &lt; childcount; i++) &#123; View child = getChildAt(i); if (child.getVisibility() == GONE) &#123; continue; &#125; child.layout(l,t+height,l+child.getMeasuredWidth(),t+height+child.getMeasuredHeight()); height += child.getMeasuredHeight(); Log.d(TAG, "onLayout: i:" + i + ",width:" + child.getMeasuredWidth() + ",height:" + child.getMeasuredHeight()); &#125;&#125; 因为我在onMeasure,onLayout都打印了日志,来看一次循环的日志:1234567891011D/MyViewGroup: onMeasure: i:0,width:486,height:180D/MyViewGroup: onMeasure: i:1,width:300,height:152D/MyViewGroup: onMeasure: i:2,width:900,height:600D/MyViewGroup: onMeasure: i:4,width:900,height:300D/MyViewGroup: onMeasure: i:5,width:150,height:60D/MyViewGroup: onMeasure: height1292;width:900D/MyViewGroup: onLayout: i:0,width:486,height:180D/MyViewGroup: onLayout: i:1,width:300,height:152D/MyViewGroup: onLayout: i:2,width:900,height:600D/MyViewGroup: onLayout: i:4,width:900,height:300D/MyViewGroup: onLayout: i:5,width:150,height:60 可以看到测量的效果还是符合实际情况的~ run起来看看: OK,挺好,跟预期效果一样~~ 总结这里已经讲了onMeasure,onLayout的用法,其实并不难,只是需要耐心,仔细. 看完了,相信对大家掌握自定义ViewGroup也有所帮助.虽然没有处理padding,margin值,但是相信这些你可以搞定. 推荐书籍Android群英传]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
        <tag>ViewGroup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Swiftype做搜索引擎]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8Swiftype%E5%81%9A%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[前言为Hexo-Next 博客配置一个搜索引擎. Swiftype先去注册个账号,但是先别急着创建引擎. 在Sitemap.xml Support看Installing Your Sitemap小节. 按着步骤来,在博客根目录下新建一个robots.txt文件,填入内容123User-agent: *Sitemap: http://www.yourdomain.com/sitemap1.xmlSitemap: http://www.yourdomain.com/sitemap2.xml 拿我的为例:1Sitemap: http://yifeiyuan.me/sitemap.xml 添加完后,push到github.然后创建引擎,一步一步走,拿到 swiftype_key.最后,编辑站点配置文件，新增字段 swiftype_key,配置好即可.:12# Swiftype Search Keyswiftype_key: xxxxxxxxx done. NexT-配置NexT-Github]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Swiftype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Canvas绘制几何图形]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8Canvas%E7%BB%98%E5%88%B6%E5%87%A0%E4%BD%95%E5%9B%BE%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[前言这是我学习自定义View系列中的使用Canvas绘制几何图形. Canvas The Canvas class holds the “draw” calls. To draw something, you need 4 basic components: A Bitmap to hold the pixels, a Canvas to host the draw calls (writing into the bitmap), a drawing primitive (e.g. Rect, Path, text, Bitmap), and a paint (to describe the colors and styles for the drawing). Developer Guides: For more information about how to use Canvas, read the Canvas and Drawables developer guide. 可以看出要使用Canvas,我们还需要一个bitmap(画在什么上),一个原型(画什么),一个Paint(用什么笔画).感觉Canvas更像是个媒介. PS:Paint不是本文重点,就不提供Paint的相关代码了(其实就换换颜色什么的). Canvas拥有各种draw方法,不过,这里我只学习记录如何绘制几何图形以及效果: 点 直线 矩形(正方形) 弧形(扇形) 椭圆(圆) 坐标系在学习这些知识之前,先来讲讲坐标系.在Android中每个View都有着自己的坐标系,都是以自己的左上角的点为原点.需要注意的是Y轴正方向是向下的 点(Point)在Android中点除了用(x,y)坐标来表示外,还可以由Point以及PointF来表示,其实它们都封装了x,y,另外再加了一些方法便于使用.顺便提一下,它们的区别在于Point的精度为int,而PointF的精度为float,仅此而已,推荐PointF. 而用canvas画点非常简单:public void drawPoint(float x, float y,@NonNull Paint paint)只要给定一个(x,y)坐标即可.由于点很简单,效果图跟线一起给. 直线(Line)直线即两点的连线,也很简单,只要给出起始点,结束点的坐标即可.public void drawLine(float startX, float startY, float stopX, float stopY,@NonNull Paint paint) 12345// 画一个点canvas.drawPoint(10, 10, mPointPaint);// 画两条直线canvas.drawLine(0, 0, 0, 300, mLinePaint);canvas.drawLine(0, 300, 300, 300, mLinePaint); 矩形(Rectangle)画矩形有以下方法: public void drawRect(float left, float top, float right, float bottom, @NonNull Paint paint) public void drawRect(@NonNull RectF rect, @NonNull Paint paint) public void drawRect(@NonNull Rect r, @NonNull Paint paint) 先不着急画,我们来看看第一个方法需要我们给定4条边的坐标值,来定位这个矩形,那么它是如何定位的呢?很简单: left,right 是距离Y轴的水平距离 top,bottom 是距离X轴的水平距离 这样给定四条边的距离后即可确定一个矩形. 我还有另外一种理解方式,可以把这四个点理解为矩形对角的两个点的坐标(left,top),(bottom,top),确定这两个点后,平移x轴,y轴与他们相交,也可以获得该矩形. 另外,跟前面的点类似,Android中有Rect以及RectF封装了这四个值以及一些方法,它们的区别跟Point与PointF一样,就不多说了,依然推荐RectF. 另外还有一个RoundRect值得一提public void drawRoundRect(@NonNull RectF rect, float rx, float ry, @NonNull Paint paint) 参数rx,ry代表两个不同的半径. PS:这个有个坑:当某一个值为0时,则无效果了. 12345canvas.translate(300, 0);canvas.drawRoundRect(mArcRectF,0,20,mRectFPaint);canvas.translate(300, 0);canvas.drawRoundRect(mArcRectF,50,70,mRectFPaint); 弧形(Arc)&amp;扇形 public void drawArc(@NonNull RectF oval, float startAngle, float sweepAngle, boolean useCenter,@NonNull Paint paint) public void drawArc(float left, float top, float right, float bottom, float startAngle,float sweepAngle, boolean useCenter, @NonNull Paint paint)(API21) 之前已经提到过RectF,其实这两个方法一样,不过第二个API等级为21.那么来理解一下参数: RectF oval 给定一个矩形,来确定一个内切圆 startAngle 弧形的起始角度 sweepAngle 弧形的角度跨度 useCenter 最后的弧形是否包括圆心(true则为扇形了) 画了个简易的图,方便理解: PS: sweepAngle&gt;=360 时则为一个内切圆,无视useCenter. 椭圆(Oval)&amp;圆(Circle)椭圆: public void drawOval(@NonNull RectF oval, @NonNull Paint paint) public void drawOval(float left, float top, float right, float bottom, @NonNull Paint paint)(API21) 参数理解:前面已经提过,给定一个矩形,即可获得一个内切圆,也就是这个椭圆. 圆:public void drawCircle(float cx, float cy, float radius, @NonNull Paint paint) 参数理解:(cx,cy)代表圆心的坐标,radius表示半径,这样即可确定一个圆,很好理解. PS: 虽然默认提供画圆的方法只有一个,但是由于圆是个特殊的椭圆,只要画椭圆时给定一个正方形也能画圆. 12345678910canvas.translate(400, 0);mOvalRectF.set(0, 30, 267, 222);//椭圆canvas.drawOval(mOvalRectF, mOvalPaint);canvas.translate(0, 300);mOvalRectF.set(0,0,200,200);//设置成正方形canvas.drawOval(mOvalRectF, mOvalPaint);canvas.translate(0, 300);canvas.drawCircle(50, 50, 100, mOvalPaint);//直接画正方形 结语好了,使用Canvas画简单的几何图形就到这里了~~代码在Github上. 如果有遗漏,有错误,欢迎指导!!!!PS:这个笔记写了两遍,第一遍被自己不小心给还原了,被自己笨哭了!]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo奇淫技巧]]></title>
    <url>%2FHexo%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[前言收集记录一些Hexo的奇淫技巧~ 自动打开刚添加的文章 在Hexo目录下新建scripts目录(有就无视) 在scripts下新建js脚本,名字随意(例子:/Users/alanchen/Documents/hexoblog/scripts/openfile.js) 在刚新建的脚本输入以下内容12345var exec = require('child_process').exec;// Hexo 3 用户复制这段hexo.on('new', function(data)&#123; exec('open -a "/Applications/Atom.app" ' + data.path);&#125;); PS:/Applications/Atom.app 为你要使用的编辑器的绝对路径! 保存退出后使用hexo n &quot;filename&quot;命令后会用指定的app打开文章,非常方便. 来源Hexo添加文章时自动打开编辑器 添加网易云音乐 去http://music.163.com/找到想添加的歌曲,点击生成外链播放器,会生成代码,加入到博客即可.1&lt;embed src="http://music.163.com/style/swf/widget.swf?sid=20657354&amp;type=2&amp;auto=1&amp;width=320&amp;height=66" width="340" height="86" allowNetworking="all"&gt;&lt;/embed&gt; 如: 自定义新菜单使用Hexo的Next主题新增菜单时,菜单名称会添加前缀Menu.,为了解决这个问题我提了个Issue最后修改了zh-Hans.yml文件后成功啦~ 置顶文章在文章的front-matter里加入top: true]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发工具汇总]]></title>
    <url>%2F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[前言开发Android不光用的只是AndroidStudio.在这里记录好用的各种类型的工具/App. Mac AppGo2Shell一个小巧而强大的工具,快速在当前位置打开Shell Dash一个非常强大的文档工具. Iterm2神器.. Oh,my zshiterm2配ohmyzsh,爽到爆. 终极 Shell OptionSpaceSublimeText Sublime Text简明教程 Sublime进阶使用 AtomGithub开发的编辑工具 Paste很好用的对剪贴板历史进行管理的软件:Paste BartenderBartender 2.0：装机必备的菜单栏工具 DaisyDiskDaisyDisk Mac版是Mac OS平台上的一款Mac系统清理工具，他可以帮助你了解磁盘使用状况，并进行准确的分析 Vim文章: flux一个可以让屏幕颜色跟随时间变化而变化的神奇的软件,能让眼睛更舒服~ retinizer制图工具ProcessOn免费在线作图工具 StarUML 2一个uml图工具~ Xmind思维导图工具. onepassword一个app保存所有密码~ 百度脑图Web SitedpicalscreensizeRGB颜色查询对照表正则表达式MD5破解Codota代码搜索工具 tinypng图片压缩,非常给力 apkleecherAPK下载工具 Json在线解析在线解析json数据,很快很清楚 jsonformatter与上一个不同,这个可以填写url jsonschema2pojo填写json生成pojo Chrome插件PostManAndroidShowJava一个可以反编译App的App,很强大. 发布工具Fir开源库资源android-arsenal其他汇总资料 开发工具 一些命令行效率工具 [必备]15个对开发人员有用的Chrome扩展插件 你不应错过的 22 款 Mac 效率工具 App5.]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SublimeText]]></title>
    <url>%2FSublimeText%2F</url>
    <content type="text"><![CDATA[SublimeTextPackage Controlsubl配置环境变量使用subl/Applications/Sublime Text.app/Contents/SharedSupport/bin 快捷键 Key 作用 command+shift+p 打开命令模式 使用subl画uml参考简明教程进阶]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>SublimeText</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava之Subscription]]></title>
    <url>%2FRxJava%E4%B9%8BSubscription%2F</url>
    <content type="text"><![CDATA[前言前面写过RxJava类似观察者模式,但是一直没提到RxJava如何取消订阅,今天就来学习一下. SubscriptionRxJava中有个叫做Subscription的接口,可以用来取消订阅.1234567891011121314151617public interface Subscription &#123; /** * Stops the receipt of notifications on the &#123;@link Subscriber&#125; that was registered when this Subscription * was received. * &lt;p&gt; * This allows unregistering an &#123;@link Subscriber&#125; before it has finished receiving all events (i.e. before * onCompleted is called). */ void unsubscribe(); /** * Indicates whether this &#123;@code Subscription&#125; is currently unsubscribed. * * @return &#123;@code true&#125; if this &#123;@code Subscription&#125; is currently unsubscribed, &#123;@code false&#125; otherwise */ boolean isUnsubscribed();&#125; 从上面可以看到,我们只需要调用unsubscribe就可以取消订阅,那么如何得到一个Subscription对象呢? 其实很简单:Observable.subscribe()方法可以返回一个Subscription的对象,即我们每次订阅都会返回.感觉Subscription就像一个订单,你下单了就会生成一个订单,而你也可以用这个订单取消订单. OK,内容其实不多,那么来练习一下吧. 实战我先写了以下代码来测试:12345678910Subscription subscription = Observable.just("Hello subscription") .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; System.out.println(s); &#125; &#125;);System.out.println(subscription.isUnsubscribed());subscription.unsubscribe();System.out.println(subscription.isUnsubscribed()); 在我想来输出的日志应该是这样的:123Hello subscriptionfalsetrue 但是,结果出乎我的意料,我运行之后是这样的:123Hello subscriptiontruetrue 诶?不对啊,明明我没有取消订阅啊,怎么就true了呢? 接下去我进源码探索了一下发现:在Observable.subscribe()里有这么一段代码:1234if (!(subscriber instanceof SafeSubscriber)) &#123; // assign to `observer` so we return the protected version subscriber = new SafeSubscriber&lt;T&gt;(subscriber);&#125; 它会把我们传递的subscriber转成SafeSubscriber,接下去跟进发现:1234567891011121314151617public void onCompleted() &#123; if (!done) &#123; done = true; try &#123; actual.onCompleted(); &#125; catch (Throwable e) &#123; // we handle here instead of another method so we don't add stacks to the frame // which can prevent it from being able to handle StackOverflow Exceptions.throwIfFatal(e); // handle errors if the onCompleted implementation fails, not just if the Observable fails _onError(e); &#125; finally &#123; // auto-unsubscribe unsubscribe(); &#125; &#125;&#125; 原来它在finally里自动取消了订阅!! 那么让onCompleted晚点执行就行了:123456789101112131415161718Subscription subscription = Observable.just("Hello subscription") .subscribeOn(Schedulers.newThread())//起线程 .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; try &#123; Thread.sleep(5000);//睡5秒,延迟一下 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(s); &#125; &#125;);//默认subscription 调用完System.out.println(subscription.isUnsubscribed());subscription.unsubscribe();System.out.println(subscription.isUnsubscribed()); Log:12falsetrue 注意,取消订阅了之后Hello subscription并不会打印,你想,你取消了订阅报纸,报社还会给你发报纸么? 好了关于Subscription暂时就探索到这里了.接下去就是项目实战了,有兴趣的可以关注一下.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建RESTAPI神器-JsonServer]]></title>
    <url>%2F%E5%88%9B%E5%BB%BARESTAPI%E7%A5%9E%E5%99%A8-JsonServer%2F</url>
    <content type="text"><![CDATA[JsonServer Get a full fake REST API with zero coding in less than 30 seconds (seriously) 可以用来创建 RestApi,非常方便. 安装应该还需要装NodeJs什么的,但是我已经安装过了.1$ sudo npm install -g json-server 基本使用 找个地方新建一个db.json文件写入一段json,如: 123456789&#123; "posts": [ &#123; "id": 1, "title": "json-server", "author": "typicode" &#125; ], "comments": [ &#123; "id": 1, "body": "some comment", "postId": 1 &#125; ], "profile": &#123; "name": "typicode" &#125;&#125; 启动server 1json-server --watch db.json 启动成功后: 接下去就可以访问了: 设置别名每次都输入json-server --watch 太麻烦了.我给它配置个别名:12#jswalias jsw="json-server --watch" 记得source ~/.zshrc,这样以后就方便了: 以后可以自己模拟写Api了~更多功能还需去Github看,不过作为一个Android程序猿,这个已经够了.]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>NodeJs</tag>
        <tag>RestApi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac抓包工具Charles]]></title>
    <url>%2FMac%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%2F</url>
    <content type="text"><![CDATA[CharlesMac下的抓包工具,去官网下载,安装.默认的Charles每天用30分后就需要再关闭再打开.破解实属无奈之举,下载破解jar替换对应的jar就行. 手机抓包准备确保手机和电脑用的同一个Wifi! 查看电脑ip 用命令1ifconfig 网络打开网络设置 手机设代理将手机网络代理到自己的电脑. 打开使用的wifi设置,设置好代理,端口默认填写8888(可以在Charles里设置). charles会弹个框,选择允许即可. OK,可以快乐的抓包了. 参考 http://www.testwo.com/blog/6343http://www.99css.com/1272/]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Charles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XCode导致Git无法使用]]></title>
    <url>%2FXCode%E5%AF%BC%E8%87%B4Git%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言今天一打开AS,发现git用不了了,想着我啥也没干呐,没Git怎么行! 点fix提示: 执行Git命令也得到提示:提示:Agreeing to the Xcode/iOS license requires admin privileges, please re-run as root via sudo.看来确实用不了,无奈google之,发现个类似的错误. 找到解决方法如下,记录一下: 打开XCode: 点击agree会让你登录,接着它会下载点什么鬼 等下载完毕,再回AS试试git: 结尾也不知道是否是XCodeGhost给影响的,真坑. 参考 Agreeing to the Xcode/iOS license requires admin privileges, please re-run as root via sudo.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>XCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过包名杀死App]]></title>
    <url>%2F%E9%80%9A%E8%BF%87%E5%8C%85%E5%90%8D%E6%9D%80%E6%AD%BBApp%2F</url>
    <content type="text"><![CDATA[前言今天游戏部门有个需求就是在某个情况下杀死他们App… 好血腥,好暴力的需求啊!从来没有杀死过别的App啊,我的双手是否会因此沾染鲜血啊… 记录一下: 首先要添加权限:&lt;uses-permission android:name=&quot;android.permission.KILL_BACKGROUND_PROCESSES&quot;/&gt; 然后代码:12ActivityManager manager = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);manager.killBackgroundProcesses(pkgname); 啊,罪孽深重啊..]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神器Vim学习]]></title>
    <url>%2F%E7%A5%9E%E5%99%A8Vim%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Vimvim 早有耳闻,这次来稍微入个门先. vim filename进入vim模式.输入a或者i,进入编辑模式.按Esc退出编辑模式.如果要保存,在浏览模式下输入:wq,保存并退出.如果有所改动但是又不想保存则输入:q!,不然会提示有错误. 移动 “h” to go left, 往左 “j” to go down, 往下 “k” to go up, 往上 “l” to go right. 往下 有些奇怪,不习惯 退出 :wq&lt;Enter&gt; 保存修改并退出 :q!&lt;Enter&gt; 退出但不保存修改 vim 模式在vim模式下输入:help可以进入help界面//todo 更多技巧 资料http://www.cnblogs.com/chijianqiang/tag/vim/]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus的使用]]></title>
    <url>%2FEventBus%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[EventBus Android optimized event bus that simplifies communication between Activities, Fragments, Threads, Services, etc. Less code, better quality. 优化的事件总线,简化app各个类之间的交互. 使用添加依赖compile &#39;de.greenrobot:eventbus:2.4.0&#39; 注意混淆使用EventBus,如果混淆的话必须要加上以下几句:1234-keepclassmembers class ** &#123; public void onEvent*(**); public void onEventMainThread(**);&#125; 必备插件当定义的Event越来越多,我们要寻找某个Event哪里接收哪里发送会比较麻烦.幸好有这么一个插件可以帮助我们: EventBus Intellij Plugin 功能:Provides actions which allow you quickly move around the event bus. EventBus.post to onEvent or onEventMainThread onEvent or onEventMainThread to EventBus.post 效果: 点击上图的图标,会帮你找到发送的地方. 同样,也能在发送的地方查找哪里接收. 源码解析EventBus-源码解析]]></content>
      <categories>
        <category>开源项目使用</category>
      </categories>
      <tags>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用HttpUrlConnection下载文件]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8HttpUrlConnection%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[记录一下使用HttpUrlConnection的Get方式下载文件的方法. Show the code: 12345678910111213141516171819202122232425262728293031323334353637private String mUrl="http://download.fir.im/v2/app/install/559d229d692d791592000016?download_token=6adb9ccc081979064c9d453b1a9d7bf5";private void download() &#123; try &#123; //file:/storage/emulated/0/test.apk File file = new File(Environment.getExternalStorageDirectory(), "test.apk"); Log.d(TAG, "download: file:" + file.getPath()); URL url = new URL(mUrl); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod("GET"); InputStream in = connection.getInputStream(); BufferedInputStream bis = new BufferedInputStream(in); if (!file.exists()) &#123; file.createNewFile(); &#125; else &#123; file.delete(); file.createNewFile(); &#125; FileOutputStream fos = new FileOutputStream(file); byte[] buffer = new byte[1024]; int size = -1; while ((size = bis.read(buffer)) != -1) &#123; fos.write(buffer, 0, size); &#125; fos.flush(); fos.close(); bis.close(); connection.disconnect(); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>HttpUrlConnection</tag>
        <tag>下载文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava多线程操作]]></title>
    <url>%2FRxJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言上一次学习了解了一些RxJava比较常用的操作符,这次来学习一下Rx的多线程操作. Scheduler-调度器 If you want to introduce multithreading into your cascade of Observable operators, you can do so by instructing those operators (or particular Observables) to operate on particular Schedulers. 如果你想给你的操作符链添加多线程,你可以通知这些操作符(或特定的Observables)运行在指定的调度器上. 也就是说RxJava的多线程是由Schedulers操作的,接下去去了解一下. 调度器种类RxJava中Schedulers有很多种下表展示了RxJava中可用的调度器种类(RxAndroid中有多少暂时不知道)： 调度器类型 效果 Schedulers.computation( ) 用于计算任务，如事件循环或和回调处理，不要用于IO操作(IO操作请使用Schedulers.io())；默认线程数等于处理器的数量 Schedulers.from(executor) 使用指定的Executor作为调度器 Schedulers.immediate( ) 在当前线程立即开始执行任务 Schedulers.io( ) 用于IO密集型任务，如异步阻塞IO操作，这个调度器的线程池会根据需要增长；对于普通的计算任务，请使用Schedulers.computation()；Schedulers.io( )默认是一个CachedThreadScheduler，很像一个有线程缓存的新线程调度器 Schedulers.newThread( ) 为每个任务创建一个新线程 Schedulers.trampoline( ) 当其它排队的任务完成后，在当前线程排队开始执行 知道了Schedulser,那么接下去就要运用了.下面介绍两个操作符,对,是操作符. SubscribeOn specify the Scheduler on which an Observable will operate SubscribeOn 指定了Observable的调度器. ObserveOn specify the Scheduler on which an observer will observe this Observable 指定observer将会在哪个Scheduler观察这个Observable. 更具体的说ObserveOn指示一个Observable在一个特定的调度器上调用观察者的onNext, onError和onCompleted方法，即影响的是subscribe()里的操作. 简单来讲:使用RxJava，你可以使用subscribeOn()指定观察者代码运行的线程，使用observerOn()指定订阅者运行的线程： 可能还是不太看得懂,来,show me the code:–出自这里1234myObservableServices.retrieveImage(url) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(bitmap -&gt; myImageView.setImageBitmap(bitmap)); 上述代码表示,在Subscriber前面执行的代码都是在I/O线程中运行。最后，操作view的代码在主线程中运行. PS:AndroidSchedulers.mainThread()是在Android中才有. 总的来说RxJava操作多线程还是比较简单方便的,而且容易控制.暂时也就只会这么点,以后学习了再补充.接下来应该是RxAndroid了,好开心. 参考 深入浅出RxJava三–响应式的好处 RxDoc-Scheduler]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio导出Jar包]]></title>
    <url>%2FAndroidStudio%E5%AF%BC%E5%87%BAJar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[工具版本:Gradle 2.4AndroidStuido 1.4Beta3 在需要打jar包的Module下的build.gradle下配置如下: PS:`rename`可以配置jar名字,`into`可以配置jar输出路径 123456789101112task clearJar(type: Delete) &#123; delete 'build/libs/yutils.jar'&#125;task makeJar(type: Copy) &#123; from('build/intermediates/bundles/release/') into('build/libs/') include('classes.jar') rename ('classes.jar', 'yutils.jar')&#125;makeJar.dependsOn(clearJar, build) 执行命令:1./gradlew makeJar 这样在build/libs/下就能出现你所需要的jar包了. 参考 how-to-export-library-to-jar-in-android-studio]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AndroidStudio</tag>
        <tag>Gradle</tag>
        <tag>Jar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio常用快捷键]]></title>
    <url>%2FAndroidStudio%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[常用快捷键(Mac) Name 作用 快捷键 Find Actions BookMarks 书签,可以留下书签,快速跳转到书签位置 F3(开关书签),cmd+F3打开书签面板 查看某个类的继承关系 选中要查看的类,ctrl+H The Call Hierarchy Popup 查看某个方法的调用路径 选中方法,ctrl+alt+h Quick Definition Lookup 快速查看某个方法或者类的实现 选中方法,cmd+Y]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AndroidStudio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[专业English,让自己更专业]]></title>
    <url>%2F%E4%B8%93%E4%B8%9AEnglish%2C%E8%AE%A9%E8%87%AA%E5%B7%B1%E6%9B%B4%E4%B8%93%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[前言记录一些专业英语,让自己更专业. 常用语记录常用于Github,SOF,Email的语句,如:礼貌用语. 句子 解释 如何应用 In most cases 大多数情况下 Please, explain it a bit more. 请再多解释一些 短语 短语 解释 例句/备注 In most cases 大多数情况下 专业词汇记录一些专业名词,让自己更专业. 词汇 解释 例句 encapsulation 封装 Encapsulation is the packing of data and functions into a single component. inheritance 继承 High Cohesion 高内聚 ISP is one of the five SOLID principles of Object-Oriented Design, similar to the High Cohesion Principle of GRASP.[3] decouple 解耦 ISP is intended to keep a system decoupled and thus easier to refactor, change, and redeploy. concurrency 并发 缩写 缩写 全拼 概念 OOP Object Oriented Programming 面向对象编程 AOP Aspect Oriented Programming 面向切面编程 POJO Plain Old Java Object 表示普通的Java对象，不是JavaBean, EntityBean 或者 SessionBean FRP Functional Reactive Programming 函数响应式编程 其他一些不太专业的,但是最好知道的. 词汇 解释 例句 microseconds 微妙 in miroseconds data stream 流量]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pidcat让你的Logcat更美更高效]]></title>
    <url>%2FPidcat%E8%AE%A9%E4%BD%A0%E7%9A%84Logcat%E6%9B%B4%E7%BE%8E%E6%9B%B4%E9%AB%98%E6%95%88%2F</url>
    <content type="text"><![CDATA[PidcatJakeWharton大神的logcat辅助工具,只显示你要看的进程,更加美观,体验更好. 用法很简单:1pidcat packagename 比如我要看网易云音乐的日志:1pidcat com.netease.cloudmusic]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监听应用安装&卸载&升级]]></title>
    <url>%2F%E7%9B%91%E5%90%AC%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85-%E5%8D%B8%E8%BD%BD-%E5%8D%87%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[前言因为公司有多个App,所以有下载其他app,并监听其安装卸载的功能需求. 主要是利用系统广播来实现,简单记录一下. 定义IntentFilter代码定义注意要加一个为”package”的scheme!1234567IntentFilter intentFilter = new IntentFilter();intentFilter.addAction(Intent.ACTION_PACKAGE_ADDED);//监听应用安装intentFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);//监听应用卸载intentFilter.addAction(Intent.ACTION_PACKAGE_REPLACED);//监听应用升级intentFilter.addAction(Intent.ACTION_MY_PACKAGE_REPLACED);//自己的应用升级intentFilter.addDataScheme("package"); // 必须要return intentFilter; Xml配置1234567&lt;intent-filter&gt; &lt;action android:name="android.intent.action.PACKAGE_ADDED"/&gt; &lt;action android:name="android.intent.action.PACKAGE_REMOVED"/&gt; &lt;action android:name="android.intent.action.PACKAGE_REPLACED"/&gt; &lt;action android:name="android.intent.action.MY_PACKAGE_REPLACED"/&gt; &lt;data android:scheme="package"/&gt;&lt;/intent-filter&gt; 处理结果获取action判断,intent.getData().getSchemeSpecificPart()获取对应包名,然后进行处理.1234567891011121314String action = intent.getAction();if (action.equals(Intent.ACTION_PACKAGE_ADDED)) &#123; String packageName = intent.getData().getSchemeSpecificPart(); Log.d(TAG, "ACTION_PACKAGE_ADDED:" + packageName);&#125;if (action.equals(Intent.ACTION_PACKAGE_REMOVED)) &#123; String packageName = intent.getData().getSchemeSpecificPart(); Log.d(TAG,"ACTION_PACKAGE_REMOVED:"+packageName);&#125;if (action.equals(Intent.ACTION_PACKAGE_REPLACED)) &#123; String packageName = intent.getData().getSchemeSpecificPart(); Log.d(TAG,"ACTION_PACKAGE_REPLACED:"+packageName);&#125; That’s all.代码保存在GistPs: 应用升级没有测试.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>监听安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(译)将Listener转换成Observable]]></title>
    <url>%2F%E5%B0%86Listener%E8%BD%AC%E6%8D%A2%E6%88%90Observable%2F</url>
    <content type="text"><![CDATA[在Java中使用listeners很常见.并且如果你使用RxJava,你会更乐意使用Observable替代listeners.但是如果你不得不处理一个你不能修改源代码的库呢? 这里有一个简单的方法去创建一个围绕listener的Observable. 假设我们有个一接口ValueUpdateListener并且一个对象ValueUpdater将会调用我们的listener:123456789101112131415161718public interface ValueUpdateListener &#123; void onValueChanged(@NonNull String value);&#125;public class ValueUpdater &#123; // in some point of the class... public void registerListener(ValueUpdateListener listener) &#123; //... &#125;; public void unregisterListener(ValueUpdateListener listener) &#123; //... &#125;;&#125; 我们可以创建一个Observable像这样: 译者注:这里有些地方缺少了final关键字. 12345678910111213141516171819202122public Observable&lt;String&gt; observableListenerWrapper() &#123; return Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; ValueUpdateListener listener = new ValueUpdateListener() &#123; @Override public void onValueChanged(@NonNull String value) &#123; if (subscriber.isUnsubscribed()) &#123; registerListener.unregisterListener(this); &#125; else &#123; subscriber.onNext(value); &#125; &#125; &#125;; registerListener.registerListener(listener); &#125; &#125;);&#125; 现在我们只需要去订阅:123observableListenerWrapper().subscribe(value -&gt; &#123; // do something with the new value&#125;); 注意这个监听将会自动注销如果onValueChanged被调用并且这个observable取消订阅. 译者注:其实有时候不需要ValueUpdater,更加简单,更多代码可以查看我的PracticeDemo 阅读原文]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
        <tag>译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符学习笔记]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[操作符操作符是为了解决对Observable对象的变换的问题，操作符用于在Observable和最终的Subscriber之间修改Observable发出的事件。RxJava提供了很多很有用的操作符。 Subscribers更应该做的事情是“响应”，响应Observable发出的事件，而不是去修改。 所以修改就交给操作符吧. Map transform the items emitted by an Observable by applying a function to each item 用来把一个事件转换为另一个事件。map()操作符就是用于变换Observable对象的，map操作符返回一个Observable对象，这样就可以实现链式调用，在一个Observable对象上多次使用map操作符，最终将最简洁的数据传递给Subscriber对象。 特性: 它不必返回Observable对象返回的类型，你可以使用map操作符返回一个发出新的数据类型的observable对象。 可以对一个Observable多次使用map 用一个例子来练习: 123456789101112131415161718//刚创建的Observable是String类型的Observable.just("Hellp Map Operator").map(new Func1&lt;String, Integer&gt;() &#123; @Override public Integer call(String s) &#123; return 2015;//通过第一个map转成Integer &#125;&#125;).map(new Func1&lt;Integer, String&gt;() &#123; @Override public String call(Integer integer) &#123; return String.valueOf(integer);//再通过第二个map转成String &#125;&#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; System.out.println(s); &#125;&#125;); Run起来输出日志:12015 From convert various other objects and data types into Observables from()接收一个集合作为输入，然后每次输出一个元素给subscriber. 看个例子,将集合的数据都输出:1234567List&lt;String&gt; s = Arrays.asList("Java", "Android", "Ruby", "Ios", "Swift");Observable.from(s).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; System.out.println(s); &#125;&#125;); Log:12345JavaAndroidRubyIosSwift 另外from也接受数组类型:123456Observable.from(new String[]&#123;"Java","Android"&#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; System.out.println(s); &#125;&#125;); FlatMap transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable Observable.flatMap()接收一个Observable的输出作为输入，同时输出另外一个Observable。 先加一个函数1234static Observable&lt;List&lt;String&gt;&gt;query()&#123; List&lt;String&gt; s = Arrays.asList("Java", "Android", "Ruby", "Ios", "Swift"); return Observable.just(s);&#125; 我们打印所有query到的语言:12345678910111213// 注意这里的参数是 query所返回的Observable的输出,并且返会一个Observable&lt;String&gt;query().flatMap(new Func1&lt;List&lt;String&gt;, Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call(List&lt;String&gt; strings) &#123; //结合from处理 return Observable.from(strings); &#125;&#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; System.out.println("_flatMap:"+s); &#125;&#125;); 日志:1234567_from:Java_from:Android_flatMap:Java_flatMap:Android_flatMap:Ruby_flatMap:Ios_flatMap:Swift 注意:query返回的Observable的输出是List&lt;String&gt;,在flatMap中变成了参数,而处理过后,返回一个Observable&lt;String&gt;. 假设这时候我们需要处理一下所获取的结果,我们加个前缀,在保证不修改subscribe的前提下我们可以这么做: 增加个函数,用来增加个前缀:123static Observable&lt;String&gt;addPre(String lan)&#123; return Observable.just("addPre_"+lan);&#125; 代码可以这么写:1234567891011121314151617query().flatMap(new Func1&lt;List&lt;String&gt;, Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call(List&lt;String&gt; strings) &#123; return Observable.from(strings); &#125;&#125;).flatMap(new Func1&lt;String, Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call(String s) &#123; //我们在这里调用`addPre`方法,就行处理 return addPre(s); &#125;&#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; System.out.println(s); &#125;&#125;); 输出日志12345addPre_JavaaddPre_AndroidaddPre_RubyaddPre_IosaddPre_Swift map与flatMap的区别(出自朱凯): map 是在一个 item 被发射之后，到达 map 处经过转换变成另一个 item ，然后继续往下走；flapMap 是 item 被发射之后，到达 flatMap 处经过转换变成一个 Observable ，而这个 Observable 并不会直接被发射出去，而是会立即被激活，然后把它发射出的每个 item 都传入流中，再继续走下去。所以 flatMap 和 map 有两个区别： 经过 Observable 的转换，相当于重新开了一个异步的流； item 被分散了，个数发生了变化。 这个flatMap还是比较难以理解,它到底是如何工作的.自己还需要多去了解一下. 更多操作符 filter 过滤,把不符合条件的过滤掉,留下符合条件的 take 指定最多输出的数量 doOnNext 允许我们在每次输出一个元素之前做一些额外的事情(其实就是在onNext里调用的) 就用一个例子来演示一下吧: 1234567891011121314151617181920212223242526272829query().flatMap(new Func1&lt;List&lt;String&gt;, Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call(List&lt;String&gt; strings) &#123; return Observable.from(strings); &#125;&#125;).flatMap(new Func1&lt;String, Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call(String s) &#123; return addPre(s); &#125;&#125;).filter(new Func1&lt;String, Boolean&gt;() &#123; @Override public Boolean call(String s) &#123; //包含a的留下 return s.contains("a"); &#125;&#125;).take(3)//最多只取3个 .doOnNext(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; //onNext之前 输出一下 System.out.println("doOnNext:"+s); &#125;&#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; System.out.println(s); &#125;&#125;); 输出:123456doOnNext:addPre_JavaaddPre_JavadoOnNext:addPre_AndroidaddPre_AndroiddoOnNext:addPre_RubyaddPre_Ruby 还有很多很多很多操作符需要去学习,这里就列举这么几个. 参考 深入浅出RxJava(二：操作符)Operators]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava初探]]></title>
    <url>%2FRxJava%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[RxJava RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM. RxJava 是java的响应式编程的扩展. Ps:RxJava 配 Lambda 更合适哦!~不过这里没用Lambda,本文只关心RxJava语法,因为现在是学好基础语法,打好基础的时候,如果你还不知道Lambda的可以看看我的使用Lambda在Android中的替代匿名类 依赖:compile &#39;io.reactivex:rxjava:1.0.12&#39; 基础知识RxJava最核心的两个东西: Observables（被观察者，事件源) Subscribers（观察者,用来响应Observables发出的事件）。 Observables发出一系列事件，Subscribers处理这些事件。这里的事件可以是任何你感兴趣的东西 （触摸事件，web接口调用返回的数据。。。） 一个Observable可以发出零个或者多个事件，知道结束或者出错。每发出一个事件，就会调用它的Subscriber的onNext方法，最后调用Subscriber.onNext()或者Subscriber.onError()结束。 粗看跟观察者模式很相似,但是有一点明显不同，那就是:如果一个Observerble没有任何的的Subscriber，那么这个Observable是不会发出任何事件的。 Talk is cheap ,show me the code.接下去练习一下~ 练习1. 创建Observable通过Observable.create方法很容易创建12345678910static Observable&lt;String&gt; mStringObservable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("Hello Rxjava"); //Notice 如果onCompleted 先调用了,那么后面的onNext onError则会被无视掉,但是不是等同于return,后面其他的代码还是会执行 subscriber.onCompleted(); System.out.println("看看onCompleted调用了还会不会有输出");// subscriber.onError(new Throwable("hehehe")); &#125;&#125;); 2. 创建Subscriber 接着我们创建一个Subscriber来处理Observable对象发出的字符串。 很简单,只是打印一下数据而已.1234567891011121314151617static Subscriber&lt;String&gt; mStringSubscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted"); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError:" + e.getMessage()); &#125; @Override public void onNext(String s) &#123; System.out.println(s); &#125; &#125;; 3. 订阅 main方法添加代码,run起来~123public static void main(String[] args) &#123; mStringObservable.subscribe(mStringSubscriber);&#125; 输出Log:123Hello RxjavaonCompleted看看onCompleted调用了还会不会有输出 注意点: 如果调用了subscriber.onCompleted(),那么在onCompleted后调用的onNext和onError都不会生效. 其实如果Rx真的每次都需要这么写的话,真的是比Java还啰嗦,接下去练习更简洁的方法. 简化代码Observable.just方法可以用来创建只发出一个事件就结束的Observable对象上面创建Observable对象的代码可以简化为一行 1static Observable&lt;String&gt; simpleObservable = Observable.just("Hell,simple observable"); 跟踪一下just方法的代码到ScalarSynchronousObservable类,会发现,其实它就是创建了一个OnSubscribe对象,顺便帮忙调用了onNext和onCompleted:12345678910protected ScalarSynchronousObservable(final T t) &#123; super(new OnSubscribe&lt;T&gt;() &#123; @Override public void call(Subscriber&lt;? super T&gt; s) &#123; s.onNext(t); s.onCompleted(); &#125; &#125;); this.t = t; &#125; 同样,订阅一下试试~ 1simpleObservable.subscribe(mStringSubscriber); 输出Log:12Hell,simple observableonCompleted 更进一步RxJava中还有Action1和Action0这两个类. 另外subscribe方法有一个重载版本，接受三个Action类型的参数，分别对应OnNext，OnComplete， OnError函数。 subscribe(onNextAction, onErrorAction, onCompleteAction); 如果我们并不关心OnComplete和OnError,那么完全可以用Action1来替代上面所写:123456static Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; System.out.println("Action1&lt;String&gt; onNextAction:" + s); &#125;&#125;; 在main中增加:1mStringObservable.subscribe(onNextAction); run起来~Log:1Action1&lt;String&gt; onNextAction:Hello Rxjava 那么再写一下onComplete和onError看:12345678910111213141516// 注意是:Throwablestatic Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable throwable) &#123; System.out.println("Action1&lt;Throwable&gt; onErrorAction:"); &#125;&#125;;//Action0static Action0 onCompleteAction = new Action0() &#123; @Override public void call() &#123; System.out.println("Action0 onCompleteAction:"); &#125;&#125;; 1234//Notice 如果调用onError 这个单个的onNextAction 会报错mStringObservable.subscribe(onNextAction);mStringObservable.subscribe(onNextAction, onErrorAction);mStringObservable.subscribe(onNextAction, onErrorAction, onCompleteAction); 需要注意的是onErrorAction 接收的是Throwable,onComplete无类型另外如果call里面调用了onError则会报错:Exception in thread &quot;main&quot; rx.exceptions.OnErrorNotImplementedException: hehehe 再简化,单个Action1可以简化成:123456Observable.just("Hello simple onaction1").subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; System.out.println(s); &#125;&#125;); 输出日志:1Hello simple onaction1 好了,基本语法部分例子学完了,例子很简单,到此结束,下一篇Rx操作符. 参考/更多 Dan Lew大神Rx系列大头鬼整理]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[听说每个人都会写单例,你会了吗?]]></title>
    <url>%2F%E5%90%AC%E8%AF%B4%E6%AF%8F%E4%B8%AA%E4%BA%BA%E9%83%BD%E4%BC%9A%E5%86%99%E5%8D%95%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[单例模式(Singleton Pattern)当我们有这样的需求:某一些类应该只存在一个实例 的时候,我们就可以用单例模式来应对. 单例模式:确保一个类只有一个实例,并提供一个全局访问点. 单例模式是所有设计模式中最简单的一个,也是大部分人最早知道的一个设计模式. 但是即使是最简单的,也有很多可以推敲的细节,要做得对也不简单. 经典的单例相信大家一定写过这样类似的单例模式代码:1234567891011public class Singleton &#123; private static Singleton ins; private Singleton() &#123;&#125; public static Singleton getIns() &#123; if (null == ins) &#123; ins = new Singleton(); &#125; return ins; &#125;&#125; 简单总结一下这样的写法: 提供一个全局静态的getIns方法,使得易于使用. 延迟Singleton的实例化,节省资源(所谓的懒汉式). 缺点是线程不安全.当多个线程同时进入if (null == ins) {}的时候就会创建多个实例. OK,接下来我们看来是要解决多线程不安全的问题了. 多线程安全这个时候可能有的人就说了,这个太简单了,加一个synchronized不就结了吗?123456public static synchronized Singleton getIns() &#123; if (null == ins) &#123; ins = new Singleton(); &#125; return ins;&#125; 确实,增加synchronized之后能够迫使每个线程在进入这个方法之前,要先等别的线程离开该方法.也即避免了多个线程同时进入getIns方法. 诚然这个能解决问题,但是我们知道synchronized是非常耗性能的.更何况:我们只需要在第一次执行这个方法的时候同步,也就是说当ins实例化后,我们不再需要同步了而如果我们加了synchronized,那么实例化后的每次调用getIns都是一种多余的消耗操作,是累赘 Ps:当然,如果哪些额外的负担你能接受(比如用的很少),那么添加`synchronized`的方法也是可以接受的,毕竟这是最简单的方式. 那么问题来了,如何改善?如何确保单例,而又不影响性能? 性能进阶接下去介绍一种更优秀的,线程安全的单例写法—双重检查锁模式(double check locking pattern) 123456789101112131415public class DoubleCheck &#123; private volatile static DoubleCheck ins; private DoubleCheck() &#123;&#125; public static DoubleCheck getIns() &#123; if (null==ins)&#123; //检查 synchronized (DoubleCheck.class)&#123; if (null == ins) &#123; //又检查一次 ins = new DoubleCheck(); &#125; &#125; &#125; return ins; &#125;&#125; 注意这里的ins用了volatile关键字来修饰,为什么呢?因为执行ins = new DoubleCheck()做了很多事情: 给ins分配内存 调用构造函数来初始化成员变量(可能会很久) 将ins对象指向分配的内存空间（执行完这步 ins才不为null） 上面的操作并不是原子操作,而jvm也可能重排序指令,导致第二三两步的执行顺序可能会被打乱,当第3步先于第2步完成,那么会导致有线程拿到了初始化未完毕的ins,那么就会错误,而这里利用了volatile的禁止指令重排序优化特性,用来解决这个问题. 注:volatile 在java 5 后才有效,原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的,当然现在不需要担心这个啦! 小结双重检查非常适用于高并发,我们熟知的开源库Eventbus,ImageLoader等都是用的双重检查锁方式实现单例 不过它,写起来稍微复杂了些,有没有简单点的呢?答案是:有! 饿汉式直接上代码吧123456public class Early &#123; private static final Early ins = new Early(); public static Early getIns() &#123; return ins; &#125;&#125; 饿汉式的原理其实是基于classloder机制来避免了多线程的同步问题 饿汉式与之前提到的懒汉式不同,它在我们调用getIns之前就实例化了(在类加载的时候就实例化了),所以不是一个懒加载,这样就有几个缺点: 延长了类加载时间 如果没用到这个类,就浪费了资源(加载了但是没用它) 不能传递参数(很显然适用的场景会减少) 静态内部类静态内部类原理同上,另外虽然它看上去有点饿汉式,但是与之前的饿汉有点不同,它在类Singleton加载完毕后并没有实例化,而是当调用getIns去加载Holder的时候才会实例化,静态内部类的方式把实例化延迟到了内部类的加载中去了!所以它比饿汉式更优秀!(偷偷告诉你Effective Java中也推荐这个方式) 例子:123456789public class Singleton &#123; private static class Holder&#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getIns()&#123; return Holder.INSTANCE; &#125;&#125; 枚举最后介绍一种,也是我在 EffectiveJava中看到的,但是在开发中我重来没看到过!123public enum Singleton&#123; INSTANCE;&#125; 优点:简单,线程安全,防反序列化.本人不太了解,也没用过,所以不敢乱说了~~~值得一提的是 EffectiveJava 也提倡这个方式 这样真的就能保证单例是个单例了吗?我们采用了很多方式来保证实例的唯一性,但是真的够了吗?如果采用反射呢?如果使用多个ClassLoder呢?那是不是会实例化多个了呢?思考一下吧~ 总结单例的实现方式有好多种,实际开发中看需求而定,个人比较推荐双重检查锁和静态内部类,这两个我比较常用,其他的说实话我一般不用.同时也可以看到单例也有很多需要学习以及思考的地方,完全弄懂也不容易~ 给自己定了一个每周一个设计模式的学习计划,希望能够坚持下去吧.以上代码可以在我的Github上找到,好了,就这样,下次见. More聊完了单例的实现方式,其实单例还有一些比较有趣的,值得思考讨论的地方,下面推荐几个,有兴趣的可以去看看~ 单例还是Util? 什么时候该使用单例?]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神器JitPack]]></title>
    <url>%2F%E7%A5%9E%E5%99%A8JitPack%2F</url>
    <content type="text"><![CDATA[神器JitPack上一次我写了一篇文章关于自己上传library到JCenter的经历,传送门:将Library上传到Jcenter需要一大堆配置,接下来介绍一个神器:JitPack. Easy to use package repository for GitHub 正如官网所写,它是基于github的,而且非常easy,easy地有点吓人! 不说了,谁用谁知道.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>JitPack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将Library上传到Jcenter]]></title>
    <url>%2F%E5%B0%86Library%E4%B8%8A%E4%BC%A0%E5%88%B0Jcenter%2F</url>
    <content type="text"><![CDATA[前言习惯了compile &#39;com.android.support:appcompat-v7:22.2.0&#39;这样一句话帅气的引用某个库. 这次自己尝试一下如何上传到’JCenter’~ 工具: AndroidStudio,Gradle 申请Bintray账号Bintray可以用Github账号登陆,很方便. 注册完,拿到昵称和ApiKey 获取方式,点击Edit: 然后点击API Key: 做过第三方授权登录的同学应该都知道apikey吧,上传到JCenter我们同样需要. 配置在上传之前,我们需要做一些配置. 配置项目修改项目里的build.gradle(注意是项目不是库)增加这两个dependencies:12classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0'classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3' 增加后如下:12345dependencies &#123; classpath 'com.android.tools.build:gradle:1.3.0' classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0' classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'&#125; 配置Librarylibrary的配置比较麻烦,我把所有的配置都贴出来好了,虽然比较粗糙,但是还能看懂.我就不一步一步写了,相信你可以的!~注意看清楚需要配置的地方就行!123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107apply plugin: 'com.android.library'apply plugin: 'com.github.dcendents.android-maven'apply plugin: 'com.jfrog.bintray'//apply plugin: 'bintray-release'// 这个version是区分library版本的，因此当我们需要更新library时记得修改这个version// 这个version影响后面的引用version = "0.0.2"android &#123; resourcePrefix "cc_" //随意填写 compileSdkVersion 22 buildToolsVersion "22.0.1" defaultConfig &#123; minSdkVersion 9 targetSdkVersion 22 versionCode 2 versionName "1.1" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:22.2.0' compile 'com.android.support:recyclerview-v7:22.2.0'&#125;def siteUrl = 'https://github.com/AlanCheen/CrashCatcher' // 项目的主页def gitUrl = 'git@github.com:AlanCheen/CrashCatcher.git' // Git仓库的urlgroup = "yifeiyuan.library.crashcatcher" // Maven Group ID for the artifact，一般填你唯一的包名install &#123; repositories.mavenInstaller &#123; // This generates POM.xml with proper parameters pom &#123; project &#123; packaging 'aar' // Add your description here name 'Android CrashCatcher' //项目的描述 你可以多写一点 url siteUrl // Set your license licenses &#123; license &#123; name 'The Apache Software License, Version 2.0' url 'http://www.apache.org/licenses/LICENSE-2.0.txt' &#125; &#125; developers &#123; developer &#123; id 'alancheen' //填写的一些基本信息 name '程序亦非猿' email 'alancheen06@gmail.com' &#125; &#125; scm &#123; connection gitUrl developerConnection gitUrl url siteUrl &#125; &#125; &#125; &#125;&#125;task sourcesJar(type: Jar) &#123; from android.sourceSets.main.java.srcDirs classifier = 'sources'&#125;task javadoc(type: Javadoc) &#123; source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClasspath().join(File.pathSeparator))&#125;task javadocJar(type: Jar, dependsOn: javadoc) &#123; classifier = 'javadoc' from javadoc.destinationDir&#125;artifacts &#123; archives javadocJar archives sourcesJar&#125;Properties properties = new Properties()properties.load(project.rootProject.file('local.properties').newDataInputStream())bintray &#123; user = properties.getProperty("bintray.user") key = properties.getProperty("bintray.apikey") configurations = ['archives'] pkg &#123; repo = "maven" name = "CrashCatcher" //发布到JCenter上的项目名字 websiteUrl = siteUrl vcsUrl = gitUrl licenses = ["Apache-2.0"] publish = true &#125;&#125; 配置apikey和昵称打开项目的local.properties,加入以下两句: 12bintray.user=your_user_namebintray.apikey=your_apikey PS: 这个文件必须忽略掉,不能上传到github上去哦~~ 执行命令好了,万事俱备,我们开始执行命令:12./gradlew install./gradlew bintrayUpload 等待上传完毕,然后去自己的仓库首页找到该库,点击Add TO JCenter,然后发送,接下来就是等待!~ 等到管理回复,我的大概是6个多小时(可能是我晚上发的原因吧),第一次会比较长,如果是更新的话很快的! 使用按照语法规则来拼写路径:groupId:库的名字:版本号所得:yifeiyuan.library.crashcatcher:crashcatcher:0.0.2 接下来添加依赖一句话即可:compile &#39;yifeiyuan.library.crashcatcher:crashcatcher:0.0.2&#39; 总结第一次配置比较麻烦,不过相信成功后的成就感还是满满的~~ 其实还有更好的工具!可以看看参考,慢慢来~ 参考 http://blog.saymagic.cn/2015/02/16/release-library-to-jcenter.html https://www.virag.si/2015/01/publishing-gradle-android-library-to-jcenter/ https://github.com/andforce/release-android-lib-to-jcenter/blob/master/README.md How to distribute your own Android library through jCenter and Maven Central from Android Studio publishing-gradle-android-library-to-jcenter http://theartofdev.com/2015/02/19/publish-android-library-to-bintray-jcenter-aar-vs-jar-and-optional-dependency/]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>JCenter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式开篇之设计原则]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BC%80%E7%AF%87%E4%B9%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[前言 PS:本人边学边记录,所以可能有欠缺有错误有不足之处,还望指导! 在学习设计模式之前我们有必要先了解一下一些设计原则.其实设计原则也是从设计模式里来的,所以暂时不需要太理解,毕竟光看原则可能有时候理解不了. SOLID设计原则)讲设计原则,则不得不先提一下SOLID设计原则.它的每个字母分别代表一个原则,接下来分别介绍一下. 单一职责原则(SRP)单一职责原则（Single Responsibility Principle,SRP） a class should have only a single responsibility (i.e. only one potential change in the software’s specification should be able to affect the specification of the class) 简单来说就是:一个类应该只有一个职责(只有一个潜在的改变能影响这个类); 每一个引起类变化的原因就是一个职责,当类具有多职责时,应该把多余职责分离出去,分别创建类来完成,否则这个类的耦合度会不断提升,不利于维护等. 比如某些所谓的多功能道具,集多少多少功能于一体,吹得很牛逼,结果呢?其中一个坏了,整个都坏了,全完蛋. 如果说我们的代码也这样,一个类又有Http请求又有IO操作的方法又封装了各种Util方法,背负各种职责,耦合度高得能吓死你,还怎么快乐地敲代码? SRP的优点很明显:高内聚,低耦合,类结构逻辑清晰明了,提高了可读性,同时也易于维护 开闭原则(OCP)开闭原则（Open Closed Principle） “software entities(classes, modules, functions, etc.) should be open for extension, but closed for modification.” 实体(类,模块..等)应该对扩展开放,对修改关闭.也就是说实体可以做到不修改源代码就可以实现功能扩展. 比如我们实现了功能A,测试完后发布.后来我们需要增加功能,在不得已的情况下我们最好是对原有的代码功能实现扩展,而不是去修改原来的代码.因为原来的代码经过了测试,而我们再次去修改很有可能破坏原来的代码,或者带来Bug,所以我们需要对修改关闭. 做到开闭原则可以做到稳定,可扩展 But,臣妾表示做不到啊! 里氏代换原则(L)里氏代换原则（Liskov Substitution Principle,LSP） It states that, in a computer program, if S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e., objects of type S may substitute objects of type T) without altering any of the desirable properties of that program (correctness, task performed, etc.). 简单来说就是:父类可以出现的地方,子类也可以出现,父类都可以被子类代替而无需改动. 其实这原则就是运用了继承,多态的特性,在很多设计模式中都有体现. 其实这个原则要求我们做的也很好理解,这么做就可以用一个方法符合所有T的类型,节省代码. 接口隔离原则(ISP)接口隔离原原则（Interface Segregation Principle,ISP） (ISP) states that no client should be forced to depend on methods it does not use. 客户端不应该被强迫地依赖那些根本用不上的方法.什么意思?假设有个接口A,A有三个方法,而我们的类B需要其中的某一个,如果让B实现A那么B就会多依赖两个用不上的方法,这就违背了该原则.另外这么做还有另外一个非常大的隐患,如果我们改变了A的其他两个方法,那么会影响到B. 在Java源码中我们可以找到很多接口都只有一个方法,比如:1234567public interface AutoCloseable &#123; void close() throws Exception;&#125;public interface Comparable&lt;T&gt; &#123; int compareTo(T another);&#125; 其实原因就在这个接口隔离原则上. ISP is intended to keep a system decoupled and thus easier to refactor, change, and redeploy. 接口隔离原则优点: 让我们的程序解耦,更容易重构,改变,重新部署. 另外个人觉得接口隔离原则跟SRP其实挺类似,它也可以提高内聚,降低耦合,提升可读性~ 依赖倒置原则(DIP)依赖倒置原则（Dependency Inversion Principle） the dependency inversion principle refers to a specific form of decoupling software modules. When following this principle, the conventional dependency relationships established from high-level, policy-setting modules to low-level, dependency modules are inverted (i.e. reversed), thus rendering high-level modules independent of the low-level module implementation details. 简单说就是:高级模块独立于低级模块的实现细节. DIP指明了: 高级模块不应该依赖低级模块,它们都应该依赖于抽象. 抽象不应该依赖细节.细节应该依赖于抽象. 其他必须知道的原则DRYDon’t repeat yourself.不要重复自己,也许你听过很多次,但它绝不是复制黏贴那么简单. 优先使用组合,少用继承在EffectiveJava 和HeadFirstDesignPattern里不止一次看到优先使用组合的建议.继承的缺点可不少. 针对接口编程,而不是实现这里的接口指interface和抽象. 封装变化把经常变化的代码封装起来,与不变的代码隔离开. 迪米特法则迪米特法则 (Law of Demeter Principle),也称为“最少知识原则（Principle of Least Knowledge)wiki百科的解释挺好的,我就照搬过来了,如下: 每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元； 每个单元只能和它的朋友交谈：不能和陌生单元交谈； 只和自己直接的朋友交谈。 很多面向对象程序设计语言用”.”表示对象的域的解析算符，因此得墨忒耳定律可以简单地陈述为“只使用一个.算符”。 因此，a.b.Method()违反了此定律，而a.Method()不违反此定律。一个简单例子是，人可以命令一条狗行走（walk），但是不应该直接指挥狗的腿行走，应该由狗去指挥控制它的腿如何行走。 优点 使得软件更好的可维护性与适应性。因为对象较少依赖其它对象的内部结构,可以改变对象容器（container）而不用改变它的调用者（caller）。 总结如果我们的目标是:Reliable,Scalable,Maintainable.,那么设计原则可以帮助我们实现,学习理解设计原则对编码大有裨益!~理论需要与实际结合,多在写代码的时候考虑一下,对提高代码质量有很大的帮助~好了,这次就写那么一点点,如有错误,欢迎批评指正,也欢迎交流! 推荐书籍HeadFirstDesignPattern.Effective Java. 参考/更多 http://colobu.com/2015/03/05/10-object-oriented-design-principles-you-should-know/编程经验之接口分离原则 设计模式之面向对象与类基础特征概念]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式前传之面向对象基础]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%89%8D%E4%BC%A0%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[前言 PS:本人边学变写,由于本人能力有限,所以在理解、解释等各方面一定会有所欠缺,如果有什么不对或者不足之处,非常欢迎各位在各种渠道批评指点!另外设计模式系列会跟随自己的能力or理解or别人的指导不定期更新 面向对象(Object-Oriented,OO)是基础中的基础,亦是重中之重.面向对象学得好,才能顺利地往设计模式的方向继续前行. JAVA面向对象最重要的特征就是：封装，继承，多态(所谓的三大特征)。就个人体会来简单讲一下. 封装封装通过合并特征和行为来创建新的数据类型. 个人体会:优点封装有个好处是实现隐藏:通过将细节私有化把接口和实现分离开来. 个人觉得封装的主要意义有: 保护私有数据,只提供方法给外部调用 抽象出方法,做成util,统一处理,复用,提高效率 缺点记住不要过度封装! 继承在Java中,对应extends关键字. 个人体会:优点子类继承父类后拥有父类的属性成员,可以很好的复用已有的类,不需要再重复写方法属性了. 缺点刚开始学习继承的时候很喜欢用,但是后来渐渐地发现继承其实有很大的缺点: 继承很重,子类拥有父类的所有东西,不管要不要,有没有用. 父类一改,牵动所有的子类,很明显这不是我们所希望发生的. 所以提倡组合,而少用继承. 多态在面向对象的程序设计语言中,多态是数据抽象和继承之后的第三种基本特征.多态也称作动态绑定、后期绑定或运行时绑定. 个人体会:多态通过分离做什么和怎么做,从另外一个角度将接口和实现分离开来； 多态不但能够改善代码的组织结构和可读性,还能够创建可扩展的程序。 说多态是最重要的基本特征也不为过吧。 多态的优点 扩展性 灵活性 可替换性 可扩充性 简化性 多态的作用: 消除类型之间的耦合关系 可实现动态绑定,增加可扩展性. 多态在设计模式中扮演着非常非常重要的角色.策略模式,里氏替换原则等就是多态的特性的最好阐述. 缺点 在定位代码的时候比较麻烦,需要去寻找具体的实现类。（有时候根本找不到- -） 资料: Thinking in JavaEffective Java]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NDK初探]]></title>
    <url>%2FNDK%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[前言原本老大让我了解一下NDK的,于是有了本笔记.Ps:本人开发环境是Mac,工具是AS. 下载NDKNDK下载 我新建了个ndk目录,把下载的文件放了进去. 接着进入该目录,执行命令:12chmod a+x android-ndk-r10c-darwin-x86_64.bin./android-ndk-r10c-darwin-x86_64.bin #需要等待一会 配置环境变量1open ~/.zshrc 把/Users/alanchen/Downloads/ndk/android-ndk-r10e 加进去(这个是我自己的) 1source ~/.zshrc #使得配置生效 输入以下命令,看看是否成功:1ndk-build Demo如果配置成功,让我们接下去看Building and Running 参考 http://blog.csdn.net/qiujuer/article/details/42040963]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>NDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反编译工具Jadx]]></title>
    <url>%2F%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7Jadx%2F</url>
    <content type="text"><![CDATA[JadxAndroid开发(/学习)有时候需要用到反编译工具,Window上有很多工具,而Mac上则不多,这里稍微介绍一下Mac上可用的反编译工具Jadx. 准备clone 仓库,编译1234mkdir jadxgit clone https://github.com/skylot/jadx.gitcd jadx./gradlew dist #这个需要等一下 开始反编译等完毕后,可以开始了,我就介绍个最简单最常用的用法 把apk改成zip 解压zip获取class.dex文件 将class.dex文件放到jadx目录下 1234cd build/jadx/bin/jadx -d out class.dex # 反编译后放入out文件夹下(如果out不存在它会自动创建)#orbin/jadx-gui class.dex # 会反编译,并且使用gui打开 OK,就这样,后续还可以配置环境变量,更加方便.]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Lambda在Android中的替代匿名类]]></title>
    <url>%2FLambda%E5%9C%A8Android%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[LambdaLambda是第十一个希腊字母,大写Λ，小写λ,额,跑题了…Lambda表达式 是Java8的新特性之一: Lambda表达式 函数式接口 流API 默认方法 新的Date 和 Time API Lambda表达式取代了匿名类，取消了模板，允许用函数式风格编写代码。 由于最近接触了RxJava,遇到了Lambda,立马就喜欢上了~所以就学习了一下. 本文主要介绍一下Lambda在Android中替代匿名类的部分使用场景. 在Android中使用Lambdagradle-retrolambda A gradle plugin for getting java lambda support in java 6, 7 and android 在Android中使用我们需要使用这个插件,按照配置配置完就行. 实战使用由于Lambda 可以取代匿名类,所以我们先来挑几个匿名类练练手. 这里先简单的提及一下Lambda的语法:() -&gt; {}咋一看可能觉得这个什么鬼啊?看不懂啊!不急,看几个例子先~ 设置监听事件Android中我们设置监听一般这么写:123456mFab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; doSomething(); &#125; &#125;); 这么写AS会提示说匿名类new View.OnClickListener()能被Lambda代替: 那么用Lambda可以如何写呢? 1mFab.setOnClickListener(v-&gt;doSomething()); 看到了么?整个匿名内部类被v-&gt;doSomething()给代替了.是不是非常简单? Ps: 本例子中的`v`代表onClick传递的参数v,参数不能省略,但是可以随意命名. 实现Runnable在Android中我们起个线程一般这么写:123456new Thread(new Runnable() &#123; @Override public void run() &#123; doSomething(); &#125; &#125;).start(); 而使用Lambda表达式的话可以这么写:1new Thread(() -&gt; doSomething()).start(); 另外实例化Runnable成员变量也可以这么写: 1Runnable runnable = ()-&gt;doSomething(); 看完这两个例子是否对Lambda感兴趣了呢?后续我还会继续学习,有兴趣的请继续关注~ 参考 http://www.importnew.com/16436.htmlhttp://javarevisited.blogspot.sg/2014/02/10-example-of-lambda-expressions-in-java8.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
        <tag>Java8</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux之常用文件操作命令]]></title>
    <url>%2FLinux%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[前言 本文记录整理了Linux较为常用的处理文件目录的命令. 文件处理命令 Linux 下一切皆文件 新建文件:touch touch [选项]… [文件名]… 一般就 touch test.md adf.md 这样就行 输出命令: echoecho [选项]... string 在屏幕打印,不知什么用- - echo string &gt; filename 覆盖写入string+换行 echo string &gt;&gt; filename 追加内容 显示文件内容: catcat filename 其实cat还有其他作用,只是常用就这个 复制文件内容到剪切板,非常实用,可以避免复制错误.1cat filename | pbcopy pbcopy pbpaste 目录处理命令建立目录: mkdir -p 用于连续创建目录以及子目录 比如我要创建language目录,并且创建它的一个子目录android:如果我写成1mkdir language/android 它会提示mkdir: language: No such file or directory而加上-p参数则执行成功1mkdir -p language/android 删除空目录: rmdir知道如何创建目录,我们当然也需要知道如何删除目录!~ 它只能删除空目录,注意必须为空目录,所以其实没什么大用,请看下一个命令 删除文件或目录 rm 删除目录: 12mkdir -p a/b/c/d/erm -r a 它会不断地问你是否删除某个目录!所以要加上-f强制删除,就不需要频繁地确认了1rm -rf a 删除多个文件:1rm -rf a.md b.md c.md 看视频说在删除目录的时候会有问你是否删除的确认,但是我在Mac下试了没有.但是个人感觉还是有确认比较好,因为玩意失误删了就木有了…废纸篓里也没有的..这要是删了什么关键的东西…那就呵呵了! Ps: 如果要加提示的话 加上-i参数,但是如果已经有f参数,i会失效 切换所在目录: cd 相对路径与绝对路径: PS: cd 后面有一个空格,需要留意 吐槽自己:以前自己老是打cd ~,并且也不知道cd -的存在,自己老是打一大串路径切来切去,这下不用麻烦啦!!~ 查询所在的目录位置:pwd当你在目录下切换来切换去不知道自己在哪里的时候,pwd就能帮上大忙啦! 很常用,一定要知道,保证你不会迷路的指南针呐!~ 复制命令:cp Ps: 似乎-r解释得不对/不全?补充: -r (recursive)递归处理，将指定目录下的文件与子目录一并处理。若源文件或目录的形态，不属于目录或符号链接，则一律视为普通文件处理 -p 或 --preserve(保存的意思) 保留源文件或目录的属性，包括所有者、所属组、权限与时间 -a 或 --archive 此参数的效果和同时指定”-dpR”参数相同 PS: 不加-p -a 则复制生成的文件的时间是执行命令时候的时间! 练习:-por -a可以顺带赋值属性 剪切或改名命令:mv 剪切将ssss.md 剪切到上一个目录1mv ssss.md ../ 重命名将ssss.md 重命名为aaa.mdmv ssss.md aaa.md Ps : 重命名的时候一定要记得写后缀]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux之文件搜索命令]]></title>
    <url>%2FLinux%E4%B9%8B%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[文件搜索命令locate在指定的数据库按文件名字搜索. 优点: 搜索速度快(在后台数据库中按文件名搜索) 数据库: /var/lib/mlocate 1locate filename 第一次执行的时候会出现:1234567WARNING: The locate database (/var/db/locate.database) does not exist.To create the database, run the following command: sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.locate.plistPlease be aware that the database can take some time to generate; oncethe database has been created, this message will no longer appear. 缺点: 不能搜所刚创建的文件(数据库默认一天一更新) 只能按文件名字搜索 那么我非要立马更新数据库呢? 1updatedb Mac 上试了 zsh: command not found: updatedb locate locate 可以搜索到数据库 特点:有配置文件,可以配置哪些不搜索/etc/updatedb.conf 发现mac 又没有 - -!! 命令搜索命令whereis 和whichwhereis可以看到命令所在路径以及帮助文档所在位置 whereis 命令名选项: -b 只查找可执行文件 -m 只查找帮助文件 只能搜索系统自带的命令还有一些类似的命令: whoami whatis which可以看到 命令的别名 which 文件名搜索命令所在路径及别名 Mac都不一样 - - PATH环境变量定义的是系统搜索命令的路径 echo $PATH 可以查看环境变量 由:分隔 文件搜索命令findfind非常强大,然而耗费资源(遍历所有文件) find [搜索范围] [搜索条件] PS: 避免大范围搜索,会非常耗费系统资源 find 实在系统当中搜索符合条件的文件名.如果需要匹配,使用通配符匹配,通配符是完全匹配. 123456➜ testlinux lsa asdfasdfasdfa.md b c.mdadad avc b.md➜ testlinux find bbb/b.md 不指定 搜索范围,默认在当前目录 通配符 匹配任意内容 ? 匹配任意一个字符 [] 匹配任意一个中括号内的字符 选项条件 -iname 不区分大小 -user root 按照所有者搜索 -nouser 查找没有所有者的文件 (一般就是垃圾文件了) 按时间查找 -atime 文件访问时间 -ctime 改变文件属性 -mtime 修改文件内容 查找10天前修改的文件: find /var/log/ -mtime +10-10 10天内修改文件10 10天当天修改的文件+10 10天前修改的文件 文件大小,inode find . -size 25k 查找文件大小是25KB的文件 -25k 小于25KB 25k 等于25KB +25k 大于25KB k M k要小写M大写,不能省略,省略的话为25个扇区(每个扇区512个字节) find . -inum 262422 查找i节点是262422的文件 逻辑 -a and 逻辑与 -o or 逻辑或 查找/etc/目录下,大于20kb并且小于50kb的文件 find /etc -size +20k -a -size -50k 查找/etc/目录下,大于20kb并且小于50kb的文件,并显示详细信息 find /etc -size +20k -a -size -50k -exec ls -lh {} \ 这里有个空格 -exec/-ok 命令{}\ ; 对搜索结果执行操作 -exec {} \ 是语法,必须这么写,中间可以写其他命令~ 1234➜ testlinux find b.md -exec ls -lh &#123;&#125; \;-rw-r--r-- 1 alanchen staff 0B 8 24 20:23 b.md➜ testlinux 字符串搜索命令 grep grep [选项] 字符串 文件名 在文件当中匹配符合条件的字符串 选项: -i 忽略大小写 -v 排除指定字符串 find 与 grep 的区别 find : 在系统当中搜索符合条件的文件名,如果需要匹配,使用通配符匹配,通配符是完全匹配.常用于搜索文件 grep : 在文件当中搜索符合条件的字符串,如果需要匹配,使用正则表达式进行匹配,正则表达式是包含匹配.常用于搜索文件内容 Linux达人养成计划]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux之链接命令]]></title>
    <url>%2FLinux%E4%B9%8B%E9%93%BE%E6%8E%A5%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[链接命令: ln 链接分两种: 软链接 -s (soft) 硬链接 硬链接特征: 请无视中间的vi命令,因为还没有学习vim 对于硬链接自己的理解备忘: 相同的硬连接文件指向同一片地址(inode一样),查询的block是一样的 修改其中一个文件,其实改的是地址所对应的内容,所以所有指向这地址的文件都”一起修改了” 删除其中某个不会影响其他文件的使用,因为地址的内存依然在 建立硬链接影响文件被引用的计数(+1)(该计数就是ll看到的 文件权限命令后的那个数字) 为什么会有引用计数呢?个人觉得正因为硬链接的inode跟block一样,所以可以通过计数来判断block是否还有引用,来决定是否删除数据(感觉像是gc,没有强引用了就代表可以回收了) 不推荐硬链接 软链接 理解备忘: 推荐使用 源文件删除后影响软链接的使用(就像失去源文件的快捷方式) 软链接拥有自己的inode和block,存的是指向源文件inode的信息,再通过源文件inode的信息找到内容,所以当源文件被删时,软链接也跟着失效了 修改软链接也同样影响硬链接以及源文件,反之亦然 软链接的文件类型是l,并且它的权限跟随源文件,而并非是ll后所看到的那样! 软链接要写绝对路径,默认会在当前文件目录下找,如果找不到就会报错!!(试了MacOS 它能找到 - -!) 软硬链接区别的个人理解: 硬链接就如我跟我妈,拥有相同的住址(inode)指向同一个block(我家),我装修了我家,我妈妈的家理所当然的跟着变了,我不见了(被删了)也不影响通过我妈找我家! 而软链接则像是我跟我的朋友的关系,他拥有自己的inode以及block,他可以用他们来找到我,然后通过我再找到我家(假设这里用的微博,朋友嘛告诉他家在哪里也正常,只不过他脑子不好,每次问完就忘记).有一天,他送给我了一份礼物,我放家里了,我妈回家也看得到(通过软链接修改,也影响其他的硬链接,其实改的就是我家!~).有一天我没上网,也就上不了微博,我朋友找不到我了(我被删了),那么朋友也找不到我家了(源文件被删,软链接跟着失效了) 至于绝对路径,那就更好说啦!~比如我告诉我朋友我家在A村,但是全国这么多A村,他就懵b了…纯属个人理解~]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux之命令基础]]></title>
    <url>%2FLinux%E4%B9%8B%E5%91%BD%E4%BB%A4%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Linux 1991 作者–Linus Torvalds Git也同样出自他手 虽然自己只是个android新手,但是个人觉得掌握一些linux命令还是很有必要的,这个是自己看Linux达人养成计划 I部分章节的学习笔记,外加自己其他所学整理.另外由于自己用的是Mac,所以实际跟Linux有差别,但是还好不太影响~由于本人也是刚学习,所以可能会出现错误,还望各位指正! 本人按照自己学习Android的需求学习的,所以东西可能不多,但是够用 命令基本格式命令提示符[root@localhost ~]# 符号 意义 root 用户 \ 根目录 ~ 用户的home目录 # 超级用户的提示符 $ 普通用户的提示符 命令格式绝大多数命令支持以下格式命令 [选项] [参数] PS: 个别命令使用不遵循此格式,当有多个选项时,可以写在一起简化选项与完整选项 -a等于--all 举个栗子 查询目录中内容: ls ls [选项] [文件或目录] 常用选项: -a 显示所有文件,包括隐藏文件(如’.’开头的文件,系统文件) -l 显示详细信息 (long list) -d 查看目录本身的属性,而不是该目录下的文件 -h 人性化显示文件大小 -i 显示inode (查看id号) 文件或目录:指定查询某个目录如果不填写,则默认当前目录 栗子1执行ls -l 栗子2ls -l self (我有个文件夹就叫self) 文件权限解释第一位代表文件类型后面每三位为一组,分别代表三个身份: u所有者 g所属组 o其他人 rw代表对该文件拥有的操作权限: r读 w写 x执行 了解以后就可以解析一下- rw- r-- r--所代表的意义了代表 这个文件(-)所有者拥有读写权限,所属组跟其他人只拥有读权限! 个人表示居然能看懂那一串什么鬼了~~~哈哈哈update: 忽然想明白了chmod 777 的意思就是将权限改为 111-111-111 也就是rwx-rwx-rwx 啊!!! 另外的一些信息: 权限后面的数字代表被引用的次数? (受硬链接影响,后面会提到ln命令) 另外还有文件大小(字节,可以加上h参数,可显示单位) 文件最后一次修改时间 文件的名字 ls -lh]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio必备插件]]></title>
    <url>%2FAndroidStudio%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[记录一下好用的AndroidStudio插件,欢迎推荐!~ ButterKnife Zelezny Drawable Importer File Grouping Eventbus Intellij Plugin Layout ID Converter Selector Generate Gson Format Lifecycle SorterSorts the lifecycle methods of an Activity or a Fragment in the order that they are called in your application. //TO BE CONTINUE 参考/更多: http://www.admin10000.com/document/6431.htmlhttp://blog.csdn.net/liang5630/article/details/46366901http://www.zhihu.com/question/28026027http://www.kuqin.com/shuoit/20150914/348061.html]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>AndroidStudio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac必备神器之Go2Shell]]></title>
    <url>%2FMac%E5%BF%85%E5%A4%87%E7%A5%9E%E5%99%A8%E4%B9%8BGo2Shell%2F</url>
    <content type="text"><![CDATA[Go2Shell一个可以快速在当前目录打开Shell的工具,小巧,非常好用! 但是它默认打开是系统的iterm,而我希望它打开iTerm2!~ 设置默认iterm而Go2Shell默认没有设置界面,需要用命令行打开(隐藏得真深啊!)在Shell中输入: 1open -a Go2Shell --args config 会打开设置界面 选择iTerm2 ,保存并退出即可!~ 配合其他利器使用Go2Shell还可以配合其他软件进一步提升效率,让你爽翻!~ 配合Alfred使用Alfred快捷打开,我这里输入2就可以快速打开 配合Finder打开Finder,按住command键,拖动Go2Shell的图标到Finder菜单就可以在Finder快捷打开Go2Shell了 配合Manico使用Manico给Go2Shell配置个快捷键,爽呆.. 吐槽一下: 推荐在App Store下载旧版本,因为官方网站最新版本已经变了,打开Go2Shell变成了设置界面,虽然不用再输入命令打开设置界面了,但是,事实上这变得更加坑了! 因为不能配合Alfred 和 Manico了!!!那还有个软用?]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态修改Shape的solid属性的color值]]></title>
    <url>%2F%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9Shape%E7%9A%84%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[Android中Shape经常会被用到,今天遇到个问题,要动态修改Shape的背景颜色,在此记录一下. Xml中的Shape一般都会写死一个颜色,如下:1234&lt;shape xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;corners android:radius="5dp" /&gt; &lt;solid android:color="@color/white" /&gt;&lt;/shape&gt; 然而当我们需要在运行时,动态去修改需要如何做呢?其实很简单:12GradientDrawable drawable =(GradientDrawable)view.getBackground();drawable.setColor(getResources().getColor(color)); 参考资料]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改WebView的背景颜色为透明]]></title>
    <url>%2F%E4%BF%AE%E6%94%B9WebView%E7%9A%84%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2%E4%B8%BA%E9%80%8F%E6%98%8E%2F</url>
    <content type="text"><![CDATA[首先想当然地想到在XML设置背景颜色 1android:background="@color/transparent" 但是运行后发现结果并非是透明的,而是白色的! 后来search之..发现 有说需要关闭硬件加速的 12//代码关闭:mWebView.setLayerType(View.LAYER_TYPE_SOFTWARE,null); 12//xml里设置:android:layerType="software" 有说的用mWebView.setBackgroundColor(0); 在4.4的小米4上尝试后发现 关闭硬件加速是没有用的,而mWebView.setBackgroundColor(0);有用~]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>UI,Tip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ItemTouchHelper之SwipeDismiss]]></title>
    <url>%2FItemTouchHelper%E4%B9%8BSwipeDismiss%2F</url>
    <content type="text"><![CDATA[ItemTouchHelper This is a utility class to add swipe to dismiss and drag &amp; drop support to RecyclerView. 它是一个非常强大的工具,感觉跟ViewDragHelper一样,不过ItemTouchHelper顾名思义是处理item的touch事件的.它能够让你非常容易实现侧滑删除,拖拽的功能. 今天,就拿它来实现以下侧滑删除!~ 开始首先我们看下ItemTouchHelper的构造方法ItemTouchHelper(Callback callback) 它需要我们传入一个Callback而刚好Android非常任性,已经帮我们实现了一个:SimpleCallback 甚至,在注释里已经给我们写好了样例!!!有兴趣的同学可以去看看,这里就不给出了. 接下来上代码!~ 定义一个Adapter这个adapter没什么特别的,挺简单的,相信大家会 12345678910111213141516171819202122232425262728293031323334353637383940414243public static class ListAdapter extends RecyclerView.Adapter&lt;ListAdapter.ViewHolder&gt; implements View.OnClickListener&#123; private Context mContext; private List&lt;String&gt;mDatas; public ListAdapter(Context context,List&lt;String&gt; data)&#123; mDatas= data; mContext = context; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.material_list_item, parent, false); return new ViewHolder(view); &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; holder.text.setText(mDatas.get(position)); holder.text.setTag(position); holder.text.setOnClickListener(this); &#125; @Override public int getItemCount() &#123; return mDatas.size(); &#125; @Override public void onClick(View v) &#123; TextView tv = (TextView) v; Toast.makeText(mContext, tv.getText()+";;"+tv.getTag(), Toast.LENGTH_SHORT).show(); &#125; public static class ViewHolder extends RecyclerView.ViewHolder&#123; TextView text; public ViewHolder(View view)&#123; super(view); text = (TextView) view.findViewById(R.id.iv_item); &#125; &#125; &#125; 定义一个RecyclerView设置为垂直list的样式,并且与上面的Adapter关联 12mRvList.setLayoutManager(new LinearLayoutManager(getActivity(), LinearLayoutManager.VERTICAL, false));mRvList.setAdapter(mAdapter); 实例化一个ItemTouchHelper再实例化ItemTouchHelper之前我们再看一下SimpleCallback的构造方法: ItemTouchHelper.SimpleCallback(int dragDirs, int swipeDirs) dragDirs 代表你想拖拽的方向 swipeDirs 你想滑动的方向 都分别有一下值,很好理解: LEFT RIGHT START END UP DOWN 动手1234567891011121314151617181920212223// 0 代表我不拖拽, ItemTouchHelper.RIGHT代表我往右滑动new ItemTouchHelper(new ItemTouchHelper.SimpleCallback(0, ItemTouchHelper.RIGHT) &#123; //在这个回调 我们处理滑动 @Override public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) &#123; Log.d(TAG, "onSwiped() called with " + "viewHolder = [" + viewHolder + "], direction = [" + direction + "]"); //这里我们通过viewHolder获取position int position = viewHolder.getAdapterPosition(); mData.remove(position); mAdapter.notifyItemRemoved(position); Toast.makeText(getActivity(), "拆散的position:"+position, Toast.LENGTH_SHORT).show(); &#125; // 暂时不处理移动事件... @Override public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) &#123; Log.d(TAG, "onMove() called with " + "recyclerView = [" + recyclerView + "], viewHolder = [" + viewHolder + "], target = [" + target + "]"); return false; &#125; &#125;).attachToRecyclerView(mRvList); 大功告成来看看效果图: 由于写在七夕,所以开启了恶搞拆情侣模式,哈哈~~~ 总结ItemTouchHelper跟ViewDragHelper一样,给我们带来了极大的方便,不经想问,Android还有什么Helper也这么牛逼而鲜为人知? 预告不出意外,下期实现拖拽功能,再见!~ 完整的代码在我的Github上~ 参考资料 Drag and Swipe with RecyclerView–泡网翻译]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
        <tag>ItemTouchHelper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客之旅]]></title>
    <url>%2F2015-08-08-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[==updated== todo 主题选择 Next: http://theme-next.iissnan.com/ 配置 评论：gitment 添加阅读时长：https://www.jianshu.com/p/baea8c95e39b 资料gitmentnext添加sitemapbusuanzi 前言一直想自己搭建一个博客,断断续续,折折腾腾了一周多时间,终于算是搭建完毕了. 为什么要搭建博客呢? 想有个属于自己的博客空间 世面上的平台不够好看 - - 佩服那些有博客的人,所以自己也想搞一个 但是不懂服务器,没有空间,不懂前端怎么破? 本博客是利用Hexo+Github搭建,主题是Jacman,感觉不错,不需要什么上面所说的知识,也能搭建成功,方便也美观,我可以,你也可以. 接下来讲讲自己的经历,说下自己遇到的坑以及注意事项~ 安装Git,Node.jsHexo的文档还算详细,按照着文档安装Git,Node.js.提醒一下: 要翻墙 网要好 有必要时 sudo 用起来..我记得当时网差,搞半天装不好… 等一切安装完毕,可以开始搭建博客了, 开始搭建博客在某个目录执行123$ hexo init &lt;folder&gt; ##如果folder没有创建,则会帮你创建$ cd &lt;folder&gt;$ (sudo) npm install ##安装一些工具? 执行完会自动生成一些必要的文件 这个时候执行1$ hexo s ##开启本地服务器就可以 在浏览器输入 http://localhost:4000/ 就可以看到博客了 部署到Github 新建github的博客仓库 将本地的ssh key 关联到github 部署本地hexo 与github关联 这里我只讲下配置hexo与github关联,其他的相信都已经做过!~Hexo提供了一个非常快速方便的一键部署功能,一个命令即可!不过不急,咱要先配置一下~ 修改_config.yml12345deploy: type: git repository: git@github.com:AlanCheen/alancheen.github.io.git branch: master message: 这里遇到了个坑,看了很多教程,都说type:github,但是那是过去式了,试了我好几次都不行,其实现在应该填git了!!!所以官方文档才是最靠谱的 安装git插件 hexo-deployer-git1$ npm install hexo-deployer-git --save 部署到github安装完毕后,执行遍可以把博客部署到github:1$ hexo d 如果一切顺利,你就能看到自己的博客了!!~ 不过github可能要同步,不一定能马上看到,过一会就可以看到啦!莫着急!~ 怎么样? 一个命令部署!! 简单方便!! 爽爆了!! 换主题hexo自带的主题并不太好看,不过幸好hexo也提供了不少的主题这里我选择了Jacman. 个人原因: 美观 有分类,标签等功能满足我的写作需求 响应式布局,在移动端观看也有很不错的阅读体验当然你可以选择其他的!~~ Jacman的作者写了个较为全面的使用教程:Jacman教程 一步一步照着修改你所要修改的即可,还算简单~ 我就配置了几个 多说 微博秀 不过这里提醒一下,配置属性的注意点 某个属性:后面一定记得跟一个空格!不然会报错 注意编码格式,最好手动敲,不要从网站上复制黏贴,不然你哪里的空格格式不对,等着哭吧… 记得使用git保存,随时commit,在你突然出错的不知所措的时候,可以还原,😄 没用git,没备份,为此我重新配置了好多遍…. 微博秀的配置需要部署上github才能看到 配置自己的域名 购买域名很多人推荐什么国外的,但是比较贵,所以我还是选择了国内的万网,值得注意的是,不是所有你想要的域名都还存在.最后买的域名: yifeiyuan.me,3年265元,价格还好~ 解析域名(dns)按照Github所提示的,在万网后台将以下两个ip解析一下 12192.30.252.154192.30.252.153 配置Hexo在根目录下/source/ 下新建一个CNAME 文件,将你的域名填入就行 部署到github 过一段时间,输入yifeiyuan.me,就可以啦~ 总结 对于一个不懂什么服务器,什么前端的人来说,Hexo+Github给搭建个人博客带来了很大的便利. 搭建博客不是心血来潮,也并不是一帆风顺的,所以需要耐心,折腾得起才行. 很多教程已经过时,多看官方文档. 搭建博客并不是必须,写笔记文章找个平台也是可以的. 搭建博客才是第一步,坚持写好文章才是关键,路还很长. 本人对Hexo的使用还只是基础的,皮毛的,可能有所遗漏,写的不好还望见谅!~ 用了一会我感觉Hexo还是挺好用的,我表示我很喜欢!~ 后面不出意外还会增加Hexo的使用心得/技巧,等我使用一段时间再说~ 感谢Hexo,jacman,以及在搭建过程中帮助过我的人!~ 希望本文能够帮助你早日搭建自己的博客! 也希望自己能写出好文章!~ 8月8,好日子!~ 再见!~]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[关于程序亦非猿]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[TLDR90后，在杭州阿里巴巴，在真一线&amp;核心部门待过，比如手机淘宝，负责过 PV 50亿 的巨型项目开发。 More一个非典型90后工程师，2014年毕业于某二本大学，虽然是 计算机科学与技术专业 出身，但是 Android 从0到1都是我自学的。 为人比较随和，喜欢分享，对代码有洁癖。 很讨厌伸手党，以及那些认为让别人帮助是理所当然的人。 在小厂待过，在中厂也做过，目前在大厂，不求改变世界，但求把世界变得更加美好。]]></content>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[友链]]></title>
    <url>%2Ffriends%2Findex.html</url>
    <content type="text"><![CDATA[MrFu: http://mrfu.me/ 网红小鄧子: http://www.jianshu.com/users/df40282480b4/latest_articles markzhai’s home: http://blog.zhaiyifan.cn 汤奇: http://itangqi.me/ Abner: http://abner-nimengbo.cn Tikitoo: http://tikitoo.me 咕咚: http://gudong.name/ 泡网: http://www.jcodecraeer.com/ 涛哥Ail: http://www.easydone.cn/ Drakeet: http://drakeet.me/ 教父大头鬼: http://blog.csdn.net/lzyzsd/ Android笔记: http://www.race604.com/ 肥皂家的Gank: http:gank.io/ 启超: http://chenqichao.me/ 脉脉不得语: http://www.inferjay.com/ stormzhang: http://stormzhang.com/posts.html/ 小黑屋: http://droidyue.com/ 郭霖: http://blog.csdn.net/sinyu890807/ 鸿洋: http://blog.csdn.net/lmj623565791 医生: http://blog.csdn.net/eclipsexys 主席: http://blog.csdn.net/singwhatiwanna 胡凯: http://hukai.me/ 开发技术前线: http://www.devtf.cn/ Simple: http://blog.csdn.net/bboyfeiyu CodeKK: http://www.codekk.com/open-source-project-analysis T大: http://www.trinea.cn/ 梁飞: http://www.liangfeizc.com/ 张涛排位十连跪: http://blog.kymjs.com/ 吴小龙同学: http://wuxiaolong.me/ 冯建: http://www.jayfeng.com/ gityuan: http://gityuan.com/ 猫猫姐姐: http://www.bingjie.me/ 香脆的大鸡排: http://www.dajipai.cc/ 加友链请微信联系我，注明来意。]]></content>
  </entry>
</search>
